// Code generated by mockery v2.14.0. DO NOT EDIT.

package sqldb

import (
	context "context"

	goqu "github.com/doug-martin/goqu/v9"
	mock "github.com/stretchr/testify/mock"
)

// MockGoquRepositoryApi is an autogenerated mock type for the GoquRepositoryApi type
type MockGoquRepositoryApi struct {
	mock.Mock
}

// Delete provides a mock function with given fields: ctx, table
func (_m *MockGoquRepositoryApi) Delete(ctx context.Context, table string) (*goqu.DeleteDataset, error) {
	ret := _m.Called(ctx, table)

	var r0 *goqu.DeleteDataset
	if rf, ok := ret.Get(0).(func(context.Context, string) *goqu.DeleteDataset); ok {
		r0 = rf(ctx, table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*goqu.DeleteDataset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecuteDelete provides a mock function with given fields: ctx, ds
func (_m *MockGoquRepositoryApi) ExecuteDelete(ctx context.Context, ds *goqu.DeleteDataset) error {
	ret := _m.Called(ctx, ds)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *goqu.DeleteDataset) error); ok {
		r0 = rf(ctx, ds)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteGet provides a mock function with given fields: ctx, ds, dest
func (_m *MockGoquRepositoryApi) ExecuteGet(ctx context.Context, ds *goqu.SelectDataset, dest interface{}) error {
	ret := _m.Called(ctx, ds, dest)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *goqu.SelectDataset, interface{}) error); ok {
		r0 = rf(ctx, ds, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteInsert provides a mock function with given fields: ctx, ds
func (_m *MockGoquRepositoryApi) ExecuteInsert(ctx context.Context, ds *goqu.InsertDataset) error {
	ret := _m.Called(ctx, ds)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *goqu.InsertDataset) error); ok {
		r0 = rf(ctx, ds)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteSelect provides a mock function with given fields: ctx, ds, dest
func (_m *MockGoquRepositoryApi) ExecuteSelect(ctx context.Context, ds *goqu.SelectDataset, dest interface{}) error {
	ret := _m.Called(ctx, ds, dest)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *goqu.SelectDataset, interface{}) error); ok {
		r0 = rf(ctx, ds, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteTruncate provides a mock function with given fields: ctx, ds
func (_m *MockGoquRepositoryApi) ExecuteTruncate(ctx context.Context, ds *goqu.TruncateDataset) error {
	ret := _m.Called(ctx, ds)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *goqu.TruncateDataset) error); ok {
		r0 = rf(ctx, ds)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteUpdate provides a mock function with given fields: ctx, ds
func (_m *MockGoquRepositoryApi) ExecuteUpdate(ctx context.Context, ds *goqu.UpdateDataset) error {
	ret := _m.Called(ctx, ds)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *goqu.UpdateDataset) error); ok {
		r0 = rf(ctx, ds)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteUpsert provides a mock function with given fields: ctx, ds
func (_m *MockGoquRepositoryApi) ExecuteUpsert(ctx context.Context, ds *goqu.InsertDataset) error {
	ret := _m.Called(ctx, ds)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *goqu.InsertDataset) error); ok {
		r0 = rf(ctx, ds)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, table
func (_m *MockGoquRepositoryApi) Get(ctx context.Context, table string) (*goqu.SelectDataset, error) {
	ret := _m.Called(ctx, table)

	var r0 *goqu.SelectDataset
	if rf, ok := ret.Get(0).(func(context.Context, string) *goqu.SelectDataset); ok {
		r0 = rf(ctx, table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*goqu.SelectDataset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Insert provides a mock function with given fields: ctx, table
func (_m *MockGoquRepositoryApi) Insert(ctx context.Context, table string) (*goqu.InsertDataset, error) {
	ret := _m.Called(ctx, table)

	var r0 *goqu.InsertDataset
	if rf, ok := ret.Get(0).(func(context.Context, string) *goqu.InsertDataset); ok {
		r0 = rf(ctx, table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*goqu.InsertDataset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Select provides a mock function with given fields: ctx, table
func (_m *MockGoquRepositoryApi) Select(ctx context.Context, table string) (*goqu.SelectDataset, error) {
	ret := _m.Called(ctx, table)

	var r0 *goqu.SelectDataset
	if rf, ok := ret.Get(0).(func(context.Context, string) *goqu.SelectDataset); ok {
		r0 = rf(ctx, table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*goqu.SelectDataset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Truncate provides a mock function with given fields: ctx, table
func (_m *MockGoquRepositoryApi) Truncate(ctx context.Context, table string) (*goqu.TruncateDataset, error) {
	ret := _m.Called(ctx, table)

	var r0 *goqu.TruncateDataset
	if rf, ok := ret.Get(0).(func(context.Context, string) *goqu.TruncateDataset); ok {
		r0 = rf(ctx, table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*goqu.TruncateDataset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, table
func (_m *MockGoquRepositoryApi) Update(ctx context.Context, table string) (*goqu.UpdateDataset, error) {
	ret := _m.Called(ctx, table)

	var r0 *goqu.UpdateDataset
	if rf, ok := ret.Get(0).(func(context.Context, string) *goqu.UpdateDataset); ok {
		r0 = rf(ctx, table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*goqu.UpdateDataset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Upsert provides a mock function with given fields: ctx, table
func (_m *MockGoquRepositoryApi) Upsert(ctx context.Context, table string) (*goqu.InsertDataset, error) {
	ret := _m.Called(ctx, table)

	var r0 *goqu.InsertDataset
	if rf, ok := ret.Get(0).(func(context.Context, string) *goqu.InsertDataset); ok {
		r0 = rf(ctx, table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*goqu.InsertDataset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewMockGoquRepositoryApi interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockGoquRepositoryApi creates a new instance of MockGoquRepositoryApi. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockGoquRepositoryApi(t mockConstructorTestingTNewMockGoquRepositoryApi) *MockGoquRepositoryApi {
	mock := &MockGoquRepositoryApi{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
