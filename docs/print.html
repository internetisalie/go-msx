<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>go-msx</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cross-Cutting Concerns</li><li class="chapter-item expanded "><a href="log/index.html"><strong aria-hidden="true">1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="config/index.html"><strong aria-hidden="true">2.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="app/index.html"><strong aria-hidden="true">3.</strong> Lifecycle</a></li><li class="chapter-item expanded "><a href="app/context.html"><strong aria-hidden="true">4.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="stats/index.html"><strong aria-hidden="true">5.</strong> Stats</a></li><li class="chapter-item expanded "><a href="trace/index.html"><strong aria-hidden="true">6.</strong> Tracing</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Application Components</li><li class="chapter-item expanded "><a href="webservice/controller.html"><strong aria-hidden="true">7.</strong> Controller</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Filter</div></li><li class="chapter-item expanded "><a href="sqldb/repository.html"><strong aria-hidden="true">9.</strong> Repository</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Migration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Integration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Streaming</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Utilities</li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Audit Events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Auditable Models</div></li><li class="chapter-item expanded "><a href="cache/lru/index.html"><strong aria-hidden="true">15.</strong> Cache</a></li><li class="chapter-item expanded "><a href="certificate/index.html"><strong aria-hidden="true">16.</strong> Certificates and TLS</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Executing Commands</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Health Checks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Http Client</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Leader Election</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Pagination</div></li><li class="chapter-item expanded "><a href="resource/index.html"><strong aria-hidden="true">22.</strong> Resources</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Retry</div></li><li class="chapter-item expanded "><a href="sanitize/index.html"><strong aria-hidden="true">24.</strong> Sanitization</a></li><li class="chapter-item expanded "><a href="scheduled/index.html"><strong aria-hidden="true">25.</strong> Scheduled Tasks</a></li><li class="chapter-item expanded "><a href="transit/index.html"><strong aria-hidden="true">26.</strong> Transit Encryption</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Validation</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">go-msx</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-msx"><a class="header" href="#go-msx">go-msx</a></h1>
<p>go-msx is a Go library for microservices and tools interacting with MSX. </p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>Currently this library and tools are in a pre-alpha state.  They are subject to
backwards-incompatible changes at <em>any</em> time.  After reaching the first stable release (v1.0.0),
<a href="https://semver.org/">SemVer</a> will be used per industry and golang best practices.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>
<p>Go 1.16+</p>
<ul>
<li>
<p>Ensure your GOPATH is correctly set and referenced in your PATH.  For example:</p>
<pre><code class="language-bash">export GOPATH=~/go
export PATH=$PATH:$GOPATH/bin
</code></pre>
</li>
<li>
<p>Be sure to set your Go proxy settings correctly.  For example:</p>
<pre><code class="language-bash">go env -w GOPRIVATE=cto-github.cisco.com/NFV-BU
</code></pre>
</li>
</ul>
</li>
<li>
<p>Git SSH configuration for <code>cto-github.cisco.com</code></p>
<ul>
<li>
<p>Ensure you have a registered SSH key referenced in your <code>~/.ssh/config</code>:</p>
<pre><code>Host cto-github.cisco.com
      HostName cto-github.cisco.com
      User git
      IdentityFile ~/.ssh/github.key
</code></pre>
<p>Note that this key must be registered via the <a href="https://cto-github.cisco.com/settings/keys">Github UI</a>.</p>
</li>
<li>
<p>Ensure you have SSH protocol override for git HTTPS urls to our github in your <code>~/.gitconfig</code>:</p>
<pre><code>[url &quot;ssh://git@cto-github.cisco.com/&quot;]
        insteadOf = https://cto-github.cisco.com/
</code></pre>
</li>
</ul>
</li>
<li>
<p>Skel tool for code generation</p>
<ul>
<li>
<p>Check out go-msx into your local workspace:</p>
<pre><code class="language-bash">mkdir -p $HOME/msx &amp;&amp; cd $HOME/msx
git clone git@cto-github.cisco.com:NFV-BU/go-msx.git
cd go-msx
go mod download
</code></pre>
</li>
<li>
<p>Install <code>skel</code>:</p>
<pre><code class="language-bash">make install-skel
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<ul>
<li>
<p>To continue working on an existing go-msx project:</p>
<ul>
<li>Return to the original project README instructions
and continue.</li>
</ul>
</li>
<li>
<p>To add go-msx to an existing module-enabled go project:</p>
<pre><code class="language-bash">go get -u cto-github.cisco.com/NFV-BU/go-msx
</code></pre>
</li>
<li>
<p>To create a new go-msx microservice skeleton project:</p>
<pre><code class="language-bash">cd $HOME/msx
skel
</code></pre>
</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<ul>
<li>
<p>Ensure you create a meaningfully named topic branch for your code:</p>
<p><code>feature/sql-transactions</code></p>
<p><code>bugfix/populate-error-handling</code></p>
</li>
<li>
<p>Make your code changes</p>
</li>
<li>
<p>Run <code>make precommit</code> to regenerate and reformat.  You will likely need to
install the <code>staticfiles</code> package the first time:</p>
<p><code>go get bou.ke/staticfiles</code></p>
</li>
<li>
<p>Commit your code to your topic branch</p>
</li>
<li>
<p>Rebase your topic branch onto master (do not reverse merge master into your branch)</p>
</li>
<li>
<p>Ensure your commits are cohesive, or just squash them</p>
</li>
<li>
<p>Create a Pull Request with a meaningful title similar to your topic branch name</p>
</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<h3 id="cross-cutting-concerns"><a class="header" href="#cross-cutting-concerns">Cross-Cutting Concerns</a></h3>
<ul>
<li><a href="log/README.html">Logging</a></li>
<li><a href="config/README.html">Configuration</a></li>
<li><a href="app/README.html">Lifecycle</a></li>
<li><a href="app/context.html">Dependencies</a></li>
<li><a href="stats/README.html">Stats</a></li>
<li><a href="trace/README.html">Tracing</a></li>
</ul>
<h3 id="application-components"><a class="header" href="#application-components">Application Components</a></h3>
<ul>
<li>
<p>Web Service</p>
<ul>
<li><a href="webservice/controller.html">Controller</a></li>
<li><a href="index.html#">Filter</a></li>
</ul>
</li>
<li>
<p>Persistence</p>
<ul>
<li><a href="sqldb/repository.html">Repository</a></li>
<li><a href="index.html#">Migration</a></li>
</ul>
</li>
<li>
<p>Communication</p>
<ul>
<li><a href="index.html#">Integration</a></li>
<li><a href="index.html#">Streaming</a></li>
</ul>
</li>
</ul>
<h3 id="utilities"><a class="header" href="#utilities">Utilities</a></h3>
<ul>
<li><a href="index.html#">Audit Events</a></li>
<li><a href="index.html#">Auditable Models</a></li>
<li><a href="cache/lru/README.html">Cache</a></li>
<li><a href="certificate/README.html">Certificates and TLS</a></li>
<li><a href="index.html#">Executing Commands</a></li>
<li><a href="index.html#">Health Checks</a></li>
<li><a href="index.html#">Http Client</a></li>
<li><a href="index.html#">Leader Election</a></li>
<li><a href="index.html#">Pagination</a></li>
<li><a href="resource/README.html">Resources</a></li>
<li><a href="index.html#">Retry</a></li>
<li><a href="sanitize/README.html">Sanitization</a></li>
<li><a href="scheduled/README.html">Scheduled Tasks</a></li>
<li><a href="transit/README.html">Transit Encryption</a></li>
<li><a href="index.html#">Validation</a></li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright (C) 2020 Cisco Systems, Inc.  All rights reserved.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-logging-module"><a class="header" href="#msx-logging-module">MSX Logging Module</a></h1>
<p>MSX logging is an extension of the popular <code>logrus</code> logging library, to include:</p>
<ul>
<li>Log names</li>
<li>Level-specific loggers</li>
<li>Improved context handling</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>After importing the MSX log package, you can use the default named logger <code>msx</code> simply:</p>
<pre><code class="language-go">import &quot;cto-github.cisco.com/NFV-BU/go-msx/log&quot;

var logger = log.StandardLogger()

func main() {
    var action = &quot;started&quot;
    logger.Infof(&quot;Something happened: %s&quot;, action) 
}
</code></pre>
<p>To use a logger with a custom name:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;alert.api&quot;)
</code></pre>
<p>To create a levelled logger, which outputs print at the defined log level:</p>
<pre><code class="language-go">debugLogger := logger.Level(log.DebugLevel)
debugLogger.Printf(&quot;Some template: %s&quot;, &quot;inserted&quot;)
</code></pre>
<p>To record a golang <code>error</code> object:</p>
<pre><code class="language-go">func DeployResource(data []byte) {
    var body ResourceDeployment
    if err := json.Unmarshal(data, &amp;body); err != nil {
        logger.
            WithError(err).
            Error(&quot;Failed to parse Resource Deployment request&quot;)
    }
}
</code></pre>
<p>To use the log context that was embedded in a Context object:</p>
<pre><code class="language-go">func HandleRequest(ctx context.Context) {
    requestLogger := logger.WithContext(ctx)
    ...
}
</code></pre>
<p>To add one-time custom diagnostic fields:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;tenant&quot;)

func HandleGetTenantRequest(tenantId string) {
    logger.
        WithExtendedField(&quot;tenantId&quot;, tenantId).
        Debug(&quot;Tenant retrieval requested&quot;)
}
</code></pre>
<p>To create a sub-logger with custom diagnostic fields:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;services.tenant&quot;)

func HandleGetTenantRequest(tenantId string) {
    requestLogger := logger.WithExtendedField(&quot;tenantId&quot;, tenantId)
    requestLogger.Debugf(&quot;some message&quot;)
}
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="logging-levels"><a class="header" href="#logging-levels">Logging Levels</a></h3>
<p>MSX Logging defines the following log levels:</p>
<ul>
<li>Trace</li>
<li>Debug</li>
<li>Info</li>
<li>Warn</li>
<li>Error</li>
<li>Panic</li>
<li>Fatal</li>
</ul>
<p>A logging level filter can be set globally:</p>
<pre><code class="language-go">log.SetLevel(log.WarnLevelName)
</code></pre>
<p>This will ensure all loggers not configured at a more strict level only output messages with a level of <code>WARN</code> or above.</p>
<p>An individual logger (and its sub-loggers) can be set to a minimum level:</p>
<pre><code class="language-go">logger = log.NewLogger(&quot;msx.beats&quot;)
logger.SetLevel(log.LevelByName(log.InfoLevelName)))
</code></pre>
<p>Configuration (eg. command line options) can be used to set a logger minimum level:</p>
<pre><code class="language-bash">myapp --logger.msx.beats=debug
</code></pre>
<p>This will set the minimum level of the <code>msx.beats</code> logger tree to <code>DEBUG</code> after
the application configuration has been loaded.</p>
<h3 id="output-format"><a class="header" href="#output-format">Output Format</a></h3>
<p>Output can be switched to JSON formatting:</p>
<pre><code class="language-go">log.SetFormat(log.LogFormatJson)
</code></pre>
<p>And back to LogFmt formatting:</p>
<pre><code class="language-go">log.SetFormat(log.LogFormatLogFmt)
</code></pre>
<p>By default, all output is sent to standard output, with high-resolution
timestamps. See <a href="log/init.go">init.go</a> for specifics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-configuration-module"><a class="header" href="#msx-configuration-module">MSX Configuration Module</a></h1>
<p>MSX configuration is a spring-compatible dynamic configuration library.  It includes support for:</p>
<ul>
<li>remote configuration stores</li>
<li>dynamic configuration updates</li>
<li>JSON, JSON5, YAML, INI and Properties files </li>
<li>key normalization </li>
<li>structure population</li>
</ul>
<h2 id="model"><a class="header" href="#model">Model</a></h2>
<p>MSX Configuration has three main components: <strong>providers</strong>, <strong>settings</strong>, and the <strong>config</strong> object. </p>
<ul>
<li><strong>Providers</strong> load settings for your application. This could be from a file, environment variables, or some other source of configuration.</li>
<li><strong>Settings</strong> represent the configuration options for your application. Settings are represented as key/value pairs. </li>
<li><strong>Config</strong> holds all of the providers and loaded settings. This object allows you to load, watch, retrieve, apply and convert your settings.</li>
</ul>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h3>
<p>When using MSX Configuration inside the MSX Application context, you can retrieve the configuration object from the <code>ctx context.Context</code>:</p>
<pre><code class="language-go">cfg := config.MustFromContext(ctx)
</code></pre>
<p>When using MSX Configuration outside of the MSX Application context, you can instantiate your own providers.  For example, to consume the environment variables from the current process:</p>
<pre><code class="language-go">environmentProvider := config.NewEnvironment(&quot;env&quot;)
cfg := config.NewConfig(environmentProvider)
</code></pre>
<h3 id="value-retrieval"><a class="header" href="#value-retrieval">Value Retrieval</a></h3>
<p>Using one of the above <code>cfg</code> objects, you can retrieve the user's home directory from the <code>HOME</code> environment variable.  Note that all config keys are normalized to be lowercase, no hyphens, period-separated.  This means the <code>HOME</code> environment variable will be mapped to <code>home</code>:</p>
<pre><code class="language-go">homePath, err := cfg.String(&quot;home&quot;)
</code></pre>
<p>The <code>cfg</code> object presents a number of functions to return a strongly-typed value:</p>
<ul>
<li><code>String(key string)</code></li>
<li><code>Int(key string)</code></li>
<li><code>Float(key string)</code></li>
<li><code>Bool(key string)</code></li>
</ul>
<p>These functions will look up the specified key in the configuration, and if found, will attempt to convert the value to the specified type.  If the key is not found or configuration has not yet been loaded, an appropriate error will be returned.</p>
<p>If you wish to use an alternative (default) value in case the lookup fails, you can use the <code>Or</code> functions:</p>
<ul>
<li><code>StringOr(key string, other string)</code></li>
<li><code>Int(key string, other int)</code></li>
<li><code>Float(key string, other float)</code></li>
<li><code>Bool(key string, other bool)</code></li>
</ul>
<p>The specified <code>other</code> value will be returned if the config has been loaded, but lookup fails:</p>
<pre><code class="language-go">buildPath, err := cfg.StringOr(&quot;build.path&quot;, &quot;./build&quot;)
</code></pre>
<h3 id="structure-population"><a class="header" href="#structure-population">Structure Population</a></h3>
<p>You can also populate appropriately defined structures:</p>
<pre><code class="language-go">type ConnectionConfig struct {
    Name string
    Skipped bool `config:&quot;-&quot;`
    AnotherName int `config:&quot;somethingelse&quot;`
}

var connectionConfig ConnectionConfig
err := cfg.Populate(&amp;connectionConfig, &quot;some.connection&quot;)
</code></pre>
<p>Each structure field is treated a little differently based on the contents/existence of the <code>config</code> struct tag:</p>
<ul>
<li><code>Name</code>: populated from <code>some.connection.name</code> (default behaviour)</li>
<li><code>Skipped</code>: not populated due to the <code>config:&quot;-&quot;</code> (omit when source name is a hyphen)</li>
<li><code>AnotherName</code>: populated from <code>some.connection.somethingelse</code> (overridden field name)</li>
</ul>
<h2 id="spring-compatibility"><a class="header" href="#spring-compatibility">Spring Compatibility</a></h2>
<p>One of the primary goals for MSX Configuration is close compatibility with Spring-style configuration.
Several known incompatibilities and limitations currently exist:</p>
<ol>
<li>Key Normalization
<ul>
<li>Configuration keys in MSX Configuration are simply normalized to be lowercase, no hyphens, period-separated. As of Spring 2.0, configuration keys are expected to be snake-case, period-separated. MSX Configuration cannot distinguish between the <code>app.some-data</code> and <code>app.somedata</code> keys, and normalizes them both to <code>app.somedata</code>.</li>
</ul>
</li>
<li>Arbitrary Population
<ul>
<li>MSX Configuration currently supports <code>@ConfigurationProperties</code> style structure population.  As a consequence, all data used to populate a structure must be direct descendants of the key used to populate the structure.  We intend to support arbitrary key specification for structures in the future.</li>
</ul>
</li>
</ol>
<h2 id="built-in-providers"><a class="header" href="#built-in-providers">Built-In Providers</a></h2>
<p>MSX Configuration has many built-in providers, allowing the application to unify configuration from a wide variety of sources:</p>
<ul>
<li><code>INIFile</code> - Loads settings from a <code>.ini</code> file</li>
<li><code>JSONFile</code>  - Loads settings from a <code>.json</code> or <code>.json5</code> file</li>
<li><code>YAMLFile</code> - Loads settings from a <code>.yaml</code> or <code>.yml</code> file</li>
<li><code>TOMLFile</code> - Loads settings from a <code>.toml</code> file</li>
<li><code>PropertiesFile</code> - Loads settings from a <code>.properties</code> file</li>
<li><code>CobraProvider</code> - Loads settings from a Cobra command context</li>
<li><code>PFlagProvider</code> - Loads settings from PFlag flagset</li>
<li><code>GoFlagProvider</code> - Loads settings from a go flag flagset</li>
<li><code>ConsulProvider</code> - Loads settings from Consul</li>
<li><code>VaultProvider</code> - Loads settings from Vault</li>
<li><code>Environment</code> - Loads settings from environment variables </li>
<li><code>Static</code> - Loads settings from an in-memory map</li>
</ul>
<h3 id="helpers"><a class="header" href="#helpers">Helpers</a></h3>
<p>Along with the above providers, there are some wrappers for managing config lifecycle:</p>
<ul>
<li><code>CachedLoader</code> - Caches settings in memory until flushed by <code>Invalidate()</code></li>
<li><code>OnceLoader</code> - Caches settings in memory permanently</li>
<li><code>Resolver</code> - Remaps settings from one key to another</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-application-module"><a class="header" href="#msx-application-module">MSX Application Module</a></h1>
<p>MSX Application is a simple state machine for managing application lifecycle.  It installs observers to configure and instantiate the standard components for use with MSX applications.  This includes listeners for external events to advance the state machine (e.g. POSIX signals, configuration changes).</p>
<h2 id="lifecycle-events"><a class="header" href="#lifecycle-events">Lifecycle Events</a></h2>
<p>MSX Application defines various lifecycle events:</p>
<ul>
<li><code>app.EventCommand</code> - mode selection based on CLI sub-commands</li>
<li><code>app.EventInit</code> - pre-configure application </li>
<li><code>app.EventConfigure</code> - application and component configuration </li>
<li><code>app.EventStart</code> - start services for consumers</li>
<li><code>app.EventReady</code> - application fully initialized and ready to service requests</li>
<li><code>app.EventRefresh</code> - update configuration after change</li>
<li><code>app.EventStop</code> - stop services for consumers</li>
<li><code>app.EventFinalize</code> - pre-termination cleanup</li>
</ul>
<p>Each event (except <code>app.EventCommand</code>) proceeds with three phases:</p>
<ul>
<li><code>app.PhaseBefore</code> - early</li>
<li><code>app.PhaseDuring</code> - normal</li>
<li><code>app.PhaseAfter</code> - late</li>
</ul>
<p>The <code>app.EventCommand</code> event will be execute with the <code>phase</code> containing the command being executed.  The following commands are pre-defined:</p>
<ul>
<li><code>app.CommandRoot</code> - Root (default)</li>
<li><code>app.CommandMigrate</code> - Migrate</li>
<li><code>app.CommandPopulate</code> - Populate</li>
</ul>
<h3 id="event-observers"><a class="header" href="#event-observers">Event Observers</a></h3>
<p>When a lifecycle event phase is occurring, the MSX Application will call each of the <code>Observer</code>s registered for the event phase.  These callbacks can be registered during any previous lifecycle event callback or during your module <code>init()</code>.</p>
<p>For example, to call the <code>addWebService</code> observer during <code>start.before</code> for all commands:</p>
<pre><code class="language-go">func init() {
    app.OnEvent(app.EventStart, app.PhaseBefore, addWebService)
}
</code></pre>
<p>To see an example showing command-specific event observers, see <a href="app/index.html#Commanding">Commanding</a>, below.</p>
<h3 id="short-circuiting"><a class="header" href="#short-circuiting">Short-Circuiting</a></h3>
<p>Sometimes an application is not able to correctly execute a lifecycle phase, or receives an external interruption.  This will result in a short-circuit of the lifecycle.  If an error is returned from one of the observers in the following phases, the lifecycle will move to the specified phase:</p>
<ul>
<li><code>app.EventInit</code> =&gt; <code>app.EventFinalize</code></li>
<li><code>app.EventConfigure</code> =&gt; <code>app.EventFinalize</code></li>
<li><code>app.EventStart</code> =&gt; <code>app.EventStop</code></li>
<li><code>app.EventReady</code> =&gt; <code>app.EventStop</code></li>
</ul>
<h2 id="application-observers"><a class="header" href="#application-observers">Application Observers</a></h2>
<h3 id="command"><a class="header" href="#command">Command</a></h3>
<p>The <code>app.EventCommand</code> events are the first events fired during startup.  They provide the opportunity to execute custom logic and register event observers specific to the command.</p>
<p>As above, the <code>app.EventCommand</code> event will be executed with the phase containing the command being executed.  For example the phase could be one of the default commands:</p>
<ul>
<li>Root (<code>app.CommandRoot</code>)</li>
<li>Migrate (<code>app.CommandMigrate</code>)</li>
<li>Populate (<code>app.CommandPopulate</code>)</li>
</ul>
<p>To add a new command:</p>
<pre><code class="language-go">func main() {
    if _, err := app.AddCommand(&quot;token&quot;, &quot;Create OAuth2 token&quot;, renew, app.Noop); err != nil {
        cli.Fatal(err)
    }
}
</code></pre>
<p>To configure event observers in response to a specific command being executed:</p>
<pre><code class="language-go">func init() {
    app.OnEvent(app.EventCommand, app.CommandRoot, func(ctx context.Context) error {
        app.OnEvent(app.EventStart, app.PhaseBefore, addWebService)
        return nil
    })
}
</code></pre>
<h3 id="init"><a class="header" href="#init">Init</a></h3>
<p>The <code>app.EventInit</code> events are fired second, after the <code>app.EventCommand</code> events.</p>
<p>Observers attached to the <code>app.EventInit</code> events should be restricted to modifying the application environment.  This includes registering custom config providers or custom context injectors.</p>
<h3 id="configure"><a class="header" href="#configure">Configure</a></h3>
<p>The <code>app.EventConfigure</code> events are fired third during startup, after the <code>app.EventInit</code> events.</p>
<p>By default, the application is configured:</p>
<ul>
<li><code>app.PhaseBefore</code>
<ul>
<li>Register remote config providers</li>
</ul>
</li>
<li><code>app.PhaseDuring</code>
<ul>
<li><a href="app/index.html#configuration-loading">Load configuration</a></li>
</ul>
</li>
<li><code>app.PhaseAfter</code>
<ul>
<li>HTTP Client</li>
<li>Consul connection pool</li>
<li>Vault connection pool</li>
<li>Cassandra connection pool</li>
<li>Redis connection pool</li>
<li>Kafka connection pool</li>
<li>Web server</li>
<li>Create Cassandra Keyspace</li>
</ul>
</li>
</ul>
<p>Typically, user applications will not register new event handlers for the <code>app.EventConfigure</code> events.</p>
<h3 id="start"><a class="header" href="#start">Start</a></h3>
<p>The <code>app.EventStart</code> events are fired fourth during startup, after the <code>app.EventConfigure</code> events.</p>
<p>By default, application infrastructure is connected:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Authentication Providers</li>
<li>Spring Actuators</li>
<li>Swagger</li>
<li>Prometheus Actuator</li>
<li>Stats Pusher</li>
</ul>
</li>
<li><code>app.PhaseAfter</code>:
<ul>
<li>Health logging</li>
<li>Stream Router</li>
<li>Web Server</li>
<li>Config Watcher</li>
</ul>
</li>
</ul>
<p>Custom application startup code is expected to run inside the <code>app.PhaseDuring</code> phase.  This would include starting any long-running services or scheduling background tasks.</p>
<h3 id="ready"><a class="header" href="#ready">Ready</a></h3>
<p>The <code>app.EventReady</code> events are fired fifth during startup, after the <code>app.EventStart</code> events.</p>
<p>By default, application ready observers are executed:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Service Registration (consul)</li>
</ul>
</li>
<li><code>app.PhaseAfter</code>:
<ul>
<li>Command Execution (sub-commands)</li>
</ul>
</li>
</ul>
<h3 id="refresh"><a class="header" href="#refresh">Refresh</a></h3>
<p><em>TBD</em></p>
<h3 id="stop"><a class="header" href="#stop">Stop</a></h3>
<p>The <code>app.EventStop</code> events are fired first during shutdown.</p>
<p>By default, application services are stopped and infrastructure and disconnected:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Service De-Registration (consul)</li>
<li>Health logging</li>
<li>Stream router</li>
<li>Web Server</li>
<li>Stats Pusher</li>
</ul>
</li>
</ul>
<p>Any custom application code running in the background should be shutdown during <code>app.PhaseDuring</code>.</p>
<h3 id="finalize"><a class="header" href="#finalize">Finalize</a></h3>
<p>The <code>app.EventFinal</code> events are fired last during shutdown.</p>
<p>By default, tracing is stopped during <code>app.PhaseAfter</code> to allow trace collection to include <code>app.EventStop</code>.</p>
<h2 id="configuration-loading"><a class="header" href="#configuration-loading">Configuration Loading</a></h2>
<p>In response to the <code>app.EventConfigure</code> event, MSX Application combines all registered sources of configuration.  This occurs in three phases:</p>
<ul>
<li><strong>Phase 1</strong> - In-Memory
<ul>
<li>Application Static Defaults</li>
<li>Environment Variables</li>
<li>Application Runtime Overrides</li>
<li>Command Line</li>
</ul>
</li>
<li><strong>Phase 2</strong> - Filesystem
<ul>
<li>Defaults Files</li>
<li>Bootstrap Files</li>
<li>Application Files</li>
<li>Profile Files </li>
<li>Build Files</li>
</ul>
</li>
<li><strong>Phase 3</strong> - Remote
<ul>
<li>Consul</li>
<li>Vault</li>
</ul>
</li>
</ul>
<p>Note that this loading order is not the same as the order of precendence for calculating values:</p>
<ul>
<li>Application Static Defaults</li>
<li>Defaults Files</li>
<li>Bootstrap Files</li>
<li>Application Files</li>
<li>Build Files</li>
<li>Consul</li>
<li>Vault</li>
<li>Profile Files</li>
<li>Environment Variables</li>
<li>Command Line</li>
<li>Application Runtime Overrides</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-dependencies"><a class="header" href="#msx-dependencies">MSX Dependencies</a></h1>
<p>In large applications, inter-object dependency management becomes more challenging.  Within the go standard library, the <a href="https://blog.golang.org/context"><code>Context</code></a> object is provided to share dependencies and cancellation.  This simplifies writing unit tests, since dependencies can be injected via the context.</p>
<p>MSX Application provides a <code>Context</code> object to event <code>Observer</code>s so they may inject new dependencies for their subsystems.  The context object also carries Trace information for logging and trace publishing.</p>
<p>By default, the following dependencies are added to the MSX Application context:</p>
<ul>
<li>Configuration</li>
<li>Cassandra client pool</li>
<li>Cockroach client pool</li>
<li>Consul client pool</li>
<li>Vault client pool</li>
<li>Redis client pool</li>
<li>Kafka client pool</li>
<li>Http client factory</li>
</ul>
<p>During <code>migrate</code> execution, the Migration Manifest is also available from the context.</p>
<h2 id="accessing-dependencies"><a class="header" href="#accessing-dependencies">Accessing Dependencies</a></h2>
<p>To support adding a custom dependency to any context, define the standard context chaining pattern:</p>
<pre><code class="language-go">type DomainServiceApi interface {
}

type domainContextKey int

const contextKeyDomainService domainContextKey = iota

func ContextWithDomainService(ctx context.Context, domainService DomainServiceApi) context.Context {
	return context.WithValue(ctx, contextKeyDomainService, domainService)
}

func DomainServiceFromContext(ctx context.Context) DomainServiceApi {
    return ctx.Value(contextKeyDomainService).(DomainServiceApi)
}
</code></pre>
<p>To inject your custom dependency to the current context:</p>
<pre><code class="language-go">ctx := domain.ContextWithDomainService(ctx, domainService)
</code></pre>
<p>To retrieve a dependency from the current context:</p>
<pre><code class="language-go">domainServiceApi := domain.DomainServiceFromContext(ctx)
</code></pre>
<h2 id="logging-and-tracing"><a class="header" href="#logging-and-tracing">Logging and Tracing</a></h2>
<p>To apply logging and tracing fields from the current context:</p>
<pre><code class="language-go">myLogger.WithContext(ctx).Info(&quot;My log message&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-statistics"><a class="header" href="#msx-statistics">MSX Statistics</a></h1>
<p>MSX Statistics allows applications to monitor and record application metrics for display on dashboards and generation of application alarms.  We have chosen to support Prometheus and its OpenMetrics format to expose collected data.</p>
<h2 id="statistics-types"><a class="header" href="#statistics-types">Statistics Types</a></h2>
<p>MSX Statistics supports several base data collection types:</p>
<ul>
<li>
<p><strong>Counter</strong></p>
<p>A counter is an ever-increasing number. For example, &quot;Completed Requests&quot; will continuously increase throughout the lifetime of the application.  It is initialized to zero on application startup.</p>
</li>
<li>
<p><strong>Gauge</strong></p>
<p>A gauge is a metric that represents a single numerical value that can arbitrarily go up and down. For example, &quot;Active Requests&quot; increases when a new request arrives, and decreases when a request is fully serviced.</p>
</li>
<li>
<p><strong>Histogram</strong></p>
<p>A histogram samples observations (usually things like request durations or response sizes) and counts them in configurable buckets. It also provides a sum of all observed values.  For example, &quot;Query Duration&quot; has a range of time values (from 0 seconds and up).  These can be put into buckets to see what the 99th percentile Query Duration is (using the prometheus <code>histogram_quantile</code> function in the dashboard).</p>
</li>
</ul>
<p>If you wish to further group the data, you can use the Vector version of each of the above types.  For example, we can group a &quot;Request Duration Histogram&quot; by API endpoint, in order to see the distribution of request duration distributions for each endpoint separated from other endpoints.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="instantiation-1"><a class="header" href="#instantiation-1">Instantiation</a></h3>
<p>To start collecting a statistic, you must first initialize its collector.  This can be accomplished during module initialization by assigning the collector to a module-global variable:</p>
<pre><code class="language-go">const (
    statsSubsystemConsul               = &quot;consul&quot;
    statsHistogramConsulCallTime       = &quot;call_time&quot;
    statsGaugeConsulCalls              = &quot;calls&quot;
    statsCounterConsulCallErrors       = &quot;call_errors&quot;
    statsGaugeConsulRegisteredServices = &quot;registrations&quot;
)

var (
    // Collect the number of errors for each api
    countVecConsulCallErrors = stats.NewCounterVec(
        statsSubsystemConsul, 
        statsCounterConsulCallErrors, 
        &quot;api&quot;, &quot;param&quot;)

    // Collect the number of active requests for each api
    gaugeVecConsulCalls      = stats.NewGaugeVec(
        statsSubsystemConsul, 
        statsGaugeConsulCalls, 
        &quot;api&quot;, &quot;param&quot;)

    // Collect the distribution of call execution times for each api
    histVecConsulCallTime    = stats.NewHistogramVec(
        statsSubsystemConsul, 
        statsHistogramConsulCallTime, 
        nil, 
        &quot;api&quot;, &quot;param&quot;)
)
</code></pre>
<p>As you can see above, each of the collector constructors start with two required arguments:</p>
<ul>
<li>
<p><strong>Subsystem</strong></p>
<p>Identifies the application subsystem being monitored.  In this case, <code>consul</code>.</p>
</li>
<li>
<p><strong>Metric Name</strong></p>
<p>Identifies the individual metric dimension.  By convention, duration histograms end with <code>_time</code>, and counters are pluralized.</p>
</li>
</ul>
<p>The histogram (and histogram vector) constructors require an argument specifying the buckets and their upper limits.  To use the default buckets, pass <code>nil</code> for this argument.  The current default buckets are calculated by executing <code>prometheus.ExponentialBuckets(10, 2, 16)</code>: this evaluates to <code>[10, 20, 40, ..., 655360]</code>.  For more information about histograms, you can visit the <a href="https://prometheus.io/docs/practices/histograms/">Prometheus documentation</a>.</p>
<p>Vector constructors, as shown above, accept a final series of dimensions to be applied to each of the measurements.  In the example above, each of our vectors accepts the <code>api</code> and <code>param</code> groupings.  In the consul stats collector:</p>
<ul>
<li><code>api</code> identifies which Consul API endpoint is being called (by path)</li>
<li><code>param</code> identifies eg. the servicename for discovery</li>
</ul>
<h3 id="collection"><a class="header" href="#collection">Collection</a></h3>
<p>After initializing your collectors, you can start to measure your application as the relevant events occur.</p>
<p>A common pattern is define a wrapper function whose only purpose is to collect statistics.  In the Consul package, we can see an example of this:</p>
<pre><code class="language-go">func observeConsulCall(api, param string, fn func() error) (err error) {
    // Collect the start time of the call
    start := time.Now()
    // Increase the number of active calls
    gaugeVecConsulCalls.WithLabelValues(api, param).Inc()

    // Execute this code before returning, even in case of panic()
    defer func() {
        // Reduce the number of active calls
        gaugeVecConsulCalls.WithLabelValues(api, param).Dec()
        
        // Bucket the call duration in the histogram
        histVecConsulCallTime.WithLabelValues(api, param).Observe(
            float64(time.Since(start)) / float64(time.Millisecond))

        if err != nil {
            // Increase the error count if an error was returned from fn
            countVecConsulCallErrors.WithLabelValues(api, param).Inc()
        }
    }()

    // Call the wrapped function and intercept it's error return value
    err = fn()
    
    // Return the wrapped function's value, after the defer block
    return err
}
</code></pre>
<p>There are a few things to note here not covered in the inline comments:</p>
<ol>
<li>We directly pass <code>api</code> and <code>param</code> group values to each of the vectors from the wrapper using <code>.WithLabelValues()</code>.  These must be passed in the same order as in the constructor.</li>
<li>Time periods should be calculated as <code>float64</code> milliseconds.</li>
<li>Counters and Gauges can be incremented by <code>1.0</code> using the <code>.Inc()</code> method.</li>
<li>Gauges can be decremented by <code>1.0</code> using the <code>.Dec()</code> method.</li>
<li>Histograms can record an observation using the <code>.Observe()</code> method.</li>
</ol>
<h2 id="push-gateway"><a class="header" href="#push-gateway">Push Gateway</a></h2>
<p>By default, the MSX Statistics package expects the statistics to be polled by an external application.  If such a poller is not available, MSX Statistics can be configured to push
to an external Prometheus push gateway.</p>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<p>The following configuration settings can be specified to configure the stats pusher:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>stats.push.enabled</code></td><td>enable the stats pusher</td><td><code>false</code></td></tr>
<tr><td><code>stats.push.url</code></td><td>url to push stats too</td><td></td></tr>
<tr><td><code>stats.push.job-name</code></td><td>prometheus job name to send</td><td><code>go_msx</code></td></tr>
<tr><td><code>stats.push.frequency</code></td><td>duration between pushes</td><td><code>15s</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="msx-distributed-tracing"><a class="header" href="#msx-distributed-tracing">MSX Distributed Tracing</a></h1>
<p>MSX Distributed Tracing allows the collection of an operational flow graph. Based
on <a href="https://opentracing.io/docs/overview/">OpenTracing</a>, tracing helps pinpoint where failures occur and what causes
poor performance.</p>
<h2 id="model-1"><a class="header" href="#model-1">Model</a></h2>
<ul>
<li>
<p><strong>Span</strong></p>
<p>A span is a named, timed operation representing a piece of the operational flow. Spans can have parents and children.</p>
</li>
<li>
<p><strong>Trace</strong></p>
<p>A trace is the complete tree of spans from an entire operational flow. A new trace (with a new root span) is created
by input from an external system, such as a REST API client. Traces extend across synchronous and asynchronous message
flows (interal RPC and events).</p>
</li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>The most common usage of tracing is to create a new child span within the current span, and execute an operation inside
it. To facilitate this, you can use the <code>trace.Operation()</code> function:</p>
<pre><code class="language-go">err := trace.Operation(ctx, &quot;myChildOperation&quot;, func(ctx context.Context) error {
myLogger.WithContext(ctx).Info(&quot;Inside myChildOperation...&quot;)
return nil
})
</code></pre>
<p>To create a new child span and attach data to it, you can use the <code>trace.NewSpan()</code> function:</p>
<pre><code class="language-go">// Create the new span
ctx, span := trace.NewSpan(ctx, spanName)
defer span.Finish()

// Tag the operation name
span.SetTag(trace.FieldOperation, operationName)

// Execute the operation and record the result
if err := myOperation(); err != nil {
span.LogFields(trace.Status(&quot;ERROR&quot;), trace.Error(err))
} else {
span.LogFields(trace.Status(&quot;OK&quot;))
}
</code></pre>
<p>Common trace log tags include:</p>
<ul>
<li><code>trace.FieldOperation</code>: Generic operation name</li>
<li><code>trace.FieldStatus</code>: Terminal status of the operation</li>
<li><code>trace.FieldHttpCode</code>: Response status code</li>
<li><code>trace.FieldHttpUrl</code>: Request url</li>
<li><code>trace.FieldHttpMethod</code>: Request method</li>
</ul>
<p>Other tags can be defined as needed using simple period-separated strings (e.g. <code>grpc.response.code</code>).</p>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<p>When writing a new driver for external input (such as a new RPC transport listener), you can retrieve the untraced
context:</p>
<pre><code class="language-go">ctx = trace.UntracedContextFromContext(ctx)
</code></pre>
<p>This context object should be passed to the input handlers, who will be responsible for starting a new (root) span:</p>
<pre><code class="language-go">err := trace.Operation(ctx, &quot;myInputReceiver&quot;, myInputHandler)
</code></pre>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>By default, MSX tracing will send trace data to a Jaeger listener at <code>udp://localhost:6831</code>.</p>
<p>The following configuration settings can be specified to override the default behaviour:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>trace.service-name</code></td><td>name of service to supply with the trace</td><td><code>${info.app.name}</code></td></tr>
<tr><td><code>trace.service-version</code></td><td>version of service to supply with the trace</td><td><code>${info.app.name}</code></td></tr>
<tr><td><code>trace.collector</code></td><td>which collector to use, <code>jaeger</code>,<code>datadog</code></td><td><code>jaeger</code></td></tr>
<tr><td><code>trace.reporter.enabled</code></td><td>report distributed tracing data</td><td><code>false</code></td></tr>
<tr><td><code>trace.reporter.host</code></td><td>jaeger/datadog host</td><td><code>localhost</code></td></tr>
<tr><td><code>trace.reporter.port</code></td><td>jaeger/datadog port</td><td><code>6831</code></td></tr>
<tr><td><code>trace.reporter.url</code></td><td>zipkin url</td><td><code>http://localhost:9411/api/v1/spans</code></td></tr>
</tbody></table>
</div>
<h3 id="datadog"><a class="header" href="#datadog">Datadog</a></h3>
<p>To configure for datadog, set the following values in consul:</p>
<pre><code class="language-yaml">trace.collector: datadog
trace.reporter.enabled: true
trace.reporter.port: 8126
</code></pre>
<p>and in the kubernetes manifest:</p>
<pre><code class="language-yaml">env:
- name: TRACE_REPORTER_HOST
  valueFrom:
    fieldRef:
      fieldPath: status.hostIP
</code></pre>
<p>That will send traces to the collector on the same host.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api-controller"><a class="header" href="#rest-api-controller">REST API Controller</a></h1>
<p>MSX promotes the usage of the common Controller &gt; Service &gt; Repository layered architecture within microservices.</p>
<p>The role of the Controller is to accept REST-based API requests from callers (UI, swagger, other microservices),
and route them to the service.</p>
<h2 id="defining-the-controller-structure"><a class="header" href="#defining-the-controller-structure">Defining the Controller structure</a></h2>
<p>To define a controller, create a standard Go structure with fields for its required dependencies:</p>
<pre><code class="language-go">type productController struct {
    productService   *productService
    productConverter *productConverter
}
</code></pre>
<p>This example shows two common dependencies:</p>
<ul>
<li>Service
<ul>
<li>The service is responsible for responding to the requests.  The controller acts as an HTTP gateway
to the service functionality.</li>
</ul>
</li>
<li>Converter
<ul>
<li>The converter transforms data transfer objects (requests and response) to and from domain models.</li>
</ul>
</li>
</ul>
<h2 id="implementing-the-restcontroller-interface"><a class="header" href="#implementing-the-restcontroller-interface">Implementing the RestController interface</a></h2>
<p>For registration with the web server, the <code>webservice.RestController</code> interface defines a single required method, <code>Routes</code>.
Add a standard implementation to your controller, for example:</p>
<pre><code class="language-go">func (c *productController) Routes(svc *restful.WebService) {
	tag := webservice.TagDefinition(&quot;Products&quot;, &quot;Products Controller&quot;)
	webservice.Routes(svc, tag,
		c.listProducts,
		c.getProduct,
		c.createProduct,
		c.updateProduct,
		c.deleteProduct)
}
</code></pre>
<p>This implementation demonstrates:</p>
<ul>
<li>Adding each endpoint implementation to the supplied WebService.</li>
<li>Tagging the routes for Swagger.  This allows the Swagger UI to show the human-readable controller name and group endpoints properly.
Note that the tag does not have to be unique, and can be declared at module level to be used across multiple controllers (eg v1, v2).
This will show all of the endpoints from the chosen controllers in a single group.</li>
</ul>
<h2 id="implementing-an-endpoint"><a class="header" href="#implementing-an-endpoint">Implementing an Endpoint</a></h2>
<p>Each endpoint on your controller should be declared inside its own method.  Here's an example implementation of a List endpoint
for the Products controller:</p>
<pre><code class="language-go">var viewPermissionFilter   = webservice.PermissionsFilter(rbac.PermissionViewProduct)

func (c *productController) listProducts(svc *restful.WebService) *restful.RouteBuilder {
    type params struct {
        Category *string `req:&quot;query&quot;`
    }

    return svc.GET(&quot;&quot;).
        Operation(&quot;listProducts&quot;).
        Doc(&quot;Retrieve the list of products, optionally filtering by the specified criteria.&quot;).
        Do(webservice.StandardList).
        Do(webservice.ResponsePayload(api.ProductListResponse{})).
        Do(webservice.PopulateParams(params{})).
        Filter(viewPermissionFilter).
        To(webservice.Controller(
            func(req *restful.Request) (body interface{}, err error) {
                params = webservice.Params(req).(*params)
        
                products, err := c.productService.ListProducts(req.Request.Context(), params.Category)
                if err != nil {
                    return nil, err
                }
        
                return c.productConverter.ToProductListResponse(products), nil
            }))
}
</code></pre>
<p>Here we are declaring the endpoint:</p>
<ul>
<li><code>type params ...</code>
<ul>
<li>accepts an optional string parameter <code>category</code> as a query parameter</li>
</ul>
</li>
<li><code>svc.GET</code>
<ul>
<li>will use the GET HTTP method</li>
</ul>
</li>
<li><code>GET(&quot;&quot;)</code>
<ul>
<li>has the same path as the controller</li>
</ul>
</li>
<li><code>Operation(&quot;listProducts&quot;)</code>
<ul>
<li>has the operation name <code>listProducts</code>.  This will appear in tracing, logs, and in the swagger definition.</li>
</ul>
</li>
<li><code>Doc(&quot;...&quot;)</code>
<ul>
<li>has the supplied description in the Swagger UI</li>
</ul>
</li>
<li><code>Do(webservice.StandardList)</code>
<ul>
<li>is an implementation of a List Collection endpoint.  Returns 200 by default.</li>
</ul>
</li>
<li><code>Do(webservice.PopulateParams(params{}))</code>
<ul>
<li>populates request parameters into the supplied structure</li>
</ul>
</li>
<li><code>Do(webservice.ResponsePayload(api.ProductListResponse{}))</code>
<ul>
<li>will return the specified response DTO, wrapped <em>inside</em> an MsxEnvelope object.</li>
</ul>
</li>
<li><code>Filter(viewPermissionFilter)</code>
<ul>
<li>will check that callers have the &quot;VIEW_PRODUCT&quot; permission, as defined in
the viewPermissionFilter object</li>
</ul>
</li>
<li><code>To(webservice.Controller(func ...))</code>
<ul>
<li>will execute the supplied function when this endpoint is called</li>
</ul>
</li>
</ul>
<p>These are some possible route building functions available in go-msx.  You may use the go-restful routing functions, along with the <a href="webservice/routes.go">go-msx routing functions</a> to define many aspects of your endpoint.</p>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<p>Controller parameter validation can be performed in two ways:</p>
<ol>
<li>
<p>Any member of the <code>params</code> struct passed into <code>webservice.PopulateParams</code> which implement the <code>validate.Validatable</code> interface
will be validated before being passed into the controller via a request attribute.</p>
<p>Create and Update request bodies will generally implement this interface.  For example:</p>
<pre><code class="language-go">type SubscriptionCreateRequest struct {
    OfferId   string `json:&quot;offerId&quot;`
    TenantId  string `json:&quot;tenantId&quot;`
    ServiceId string `json:&quot;serviceId&quot;`
}

func (s *SubscriptionCreateRequest) Validate() error {
    return types.ErrorMap{
        &quot;offerId&quot;: validation.Validate(&amp;s.OfferId, validation.Required, is.UUID),
        &quot;tenantId&quot;: validation.Validate(&amp;s.TenantId, validation.Required, is.UUID),
        &quot;serviceId&quot;: validation.Validate(&amp;s.ServiceId, validation.Required, is.UUID),
    }
}
</code></pre>
</li>
<li>
<p>A custom validation function may be provided using <code>.Do(requestValidatorFunc)</code>.  Extending the example above
which contains a <code>Category</code> parameter:</p>
<pre><code class="language-go">    ...
    Do(webservice.ValidateParams(func(req *restful.Request) (err error) {
        params, ok := webservice.Params(req).(*params)
        if !ok {
            return webservice.NewInternalError(errors.New(&quot;incorrect params type&quot;))
        }
        return types.ErrorMap{
            &quot;category&quot;: validation.Validate(&amp;params.Category, 
                                            validation.Required, 
                                            validation.In(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),
        }
    })).
</code></pre>
</li>
</ol>
<p>Any non-nil errors returned by the validation function will cause a <code>400 BAD REQUEST</code> response detailing
the validation errors.</p>
<p>Common validators are provided by the <a href="https://github.com/go-ozzo/ozzo-validation">github.com/go-ozzo/ozzo-validation</a> package.
A few custom validators are available in the <a href="webservice/../validate/README.html">validate</a> package.</p>
<h2 id="implementing-a-constructor"><a class="header" href="#implementing-a-constructor">Implementing a Constructor</a></h2>
<p>To allow instantiation of your controller, you can provide a constructor:</p>
<pre><code class="language-go">func newProductController(ctx context.Context) webservice.RestController {
	return &amp;productController{
        productService:   newProductService(ctx),
        productConverter: productConverter{},
	}
}
</code></pre>
<p>In this case, we expect the product service to be injectable, so we use its constructor function
to create an instance of the dependency. This simplifies unit testing by allowing us to inject
a mock for the service.</p>
<p>In contrast, we do not expect to use a mock converter, so it is instantiated directly.</p>
<h2 id="connecting-the-controller-to-the-application-lifecycle"><a class="header" href="#connecting-the-controller-to-the-application-lifecycle">Connecting the Controller to the Application Lifecycle</a></h2>
<p>In order to instantiate your controller during application startup, you can register a simple
<code>init</code> function:</p>
<pre><code class="language-go">func init() {
	app.OnEvent(app.EventCommand, app.CommandRoot, func(ctx context.Context) error {
		app.OnEvent(app.EventStart, app.PhaseBefore, func(ctx context.Context) error {
			controller := newProductController(ctx)
			return webservice.
				WebServerFromContext(ctx).
				RegisterRestController(pathRoot, controller)
		})
		return nil
	})
}
</code></pre>
<p>This will register your controller during normal microservice startup.  Since it
is only registering for <code>CommandRoot</code>, it will not be created during <code>migrate</code>, 
<code>populate</code> or other custom command execution.</p>
<p>To ensure your module is included in the built microservice, include the module from your <code>main.go</code>:</p>
<pre><code class="language-go">import _ &quot;cto-github.cisco.com/NFV-BU/productservice/internal/products&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-database-repository"><a class="header" href="#sql-database-repository">SQL Database Repository</a></h1>
<p>MSX promotes the usage of the common Controller &gt; Service &gt; Repository layered architecture within microservices.</p>
<p>The role of the Repository is to query and mutate the persistent storage of Models.</p>
<h2 id="defining-the-repository"><a class="header" href="#defining-the-repository">Defining the Repository</a></h2>
<p>To define a repository, create a standard Go structure with an anonymous field for the CrudRepository:</p>
<pre><code class="language-go">type deviceSqlRepository struct {
    sqldb.CrudRepositoryApi
}
</code></pre>
<p>The <code>CrudRepositoryApi</code> object provides access to the SQL database underneath using generic objects 
and slices.</p>
<h2 id="writing-a-constructor"><a class="header" href="#writing-a-constructor">Writing a Constructor</a></h2>
<p>A standard repository constructor allows for dependency injection (during testing) and normal creation (during runtme):</p>
<pre><code class="language-go">func newDeviceRepository(ctx context.Context) deviceRepositoryApi {
	repo := deviceRepositoryFromContext(ctx)
	if repo == nil {
		repo = &amp;deviceSqlRepository{
			CrudRepositoryApi: sqldb.
				CrudRepositoryFactoryFromContext(ctx).
				NewCrudRepository(&quot;device&quot;),
		}
	}
	return repo
}
</code></pre>
<ul>
<li>The <code>CrudRepositoryFactory</code> allows us to test the repository without requiring an actual database implementation.</li>
<li>The <code>deviceRepositoryFromContext</code> allows us to test this repositories reverse-dependencies without requiring
an actual <code>deviceSqlRepository</code>.</li>
</ul>
<h2 id="implementing-common-access-methods"><a class="header" href="#implementing-common-access-methods">Implementing Common Access Methods</a></h2>
<p>A basic repository will likely have the following common methods:</p>
<ul>
<li><code>FindAll</code>
<ul>
<li>Retrieve all models</li>
</ul>
</li>
<li><code>FindByKey</code>
<ul>
<li>Retrieve a single model by its primary key</li>
</ul>
</li>
<li><code>Save</code>
<ul>
<li>Store a single model</li>
</ul>
</li>
<li><code>Delete</code>
<ul>
<li>Remove a single model</li>
</ul>
</li>
</ul>
<p>More advanced repositories may have some less-common methods:</p>
<ul>
<li><code>FindAllByIndexXXX</code>
<ul>
<li>Retrieve all models matching the specified criteria using an index</li>
</ul>
</li>
<li><code>FindAllPagedBy</code>
<ul>
<li>Retrieve a subset of models matching the specified criteria, using the specified sorting and pagination</li>
</ul>
</li>
<li><code>Truncate</code>
<ul>
<li>Remove all models</li>
</ul>
</li>
</ul>
<h3 id="findall"><a class="header" href="#findall">FindAll</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) FindAll(ctx context.Context) (results []device, err error) {
	logger.WithContext(ctx).Info(&quot;Retrieving all Device records&quot;)
	err = r.CrudRepositoryApi.FindAll(ctx, &amp;results)
	return
}
</code></pre>
<ol>
<li>Log method intention</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.</li>
</ol>
<h3 id="findbykey"><a class="header" href="#findbykey">FindByKey</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) FindByKey(ctx context.Context, name string) (result *device, err error) {
	logger.WithContext(ctx).Infof(&quot;Retrieving Device by key %q&quot;, name)
	var res device
	err = r.CrudRepositoryApi.FindOneBy(ctx, map[string]interface{}{
		&quot;name&quot;: name,
	}, &amp;res)
	if err == sqldb.ErrNotFound {
		err = repository.ErrNotFound
	} else if err == nil {
		result = &amp;res
	}
	return
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.FindOneBy</code> method accepts a map of criteria to search by -- 
in this case, the primary key.</li>
</ul>
</li>
<li>Normalize the <code>sqldb</code> error code to use <code>repository</code> error codes.</li>
</ol>
<h3 id="save"><a class="header" href="#save">Save</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) Save(ctx context.Context, device device) (err error) {
	logger.WithContext(ctx).Infof(&quot;Storing Device with key %q&quot;, device.Name)
	return r.CrudRepositoryApi.Save(ctx, device)
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record storage and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.Save</code> method performs an <code>UPSERT</code> query in Cockroach so it behaves
in much the same way as the <code>Save</code> method from a KV repository.</li>
</ul>
</li>
</ol>
<h3 id="delete"><a class="header" href="#delete">Delete</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) Delete(ctx context.Context, name string) (err error) {
	logger.WithContext(ctx).Infof(&quot;Deleting Device by key %q&quot;, name)
	return r.CrudRepositoryApi.DeleteBy(ctx, map[string]interface{}{
		columnDeviceName: name,
	})
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.DeleteBy</code> method accepts a map of criteria to delete by -- 
in this case, the primary key.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-lru-cache"><a class="header" href="#msx-lru-cache">MSX LRU Cache</a></h1>
<p>An LRU cache implementation which expires key/value pairs based on a TTL duration.
Inspired by <a href="https://github.com/karlseguin/rcache">rcache</a>.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<h3 id="instantiation-2"><a class="header" href="#instantiation-2">Instantiation</a></h3>
<p>To create a new cache with 120 second retention, which expires up to 100 keys every 15 seconds:</p>
<pre><code class="language-go">myCache := lru.NewCache(120 * time.Second, 100, 15 * time.Second)
</code></pre>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>To store a key/value pair:</p>
<pre><code class="language-go">myCache.Set(&quot;somekey&quot;, &quot;myvalue&quot;)
</code></pre>
<h3 id="retrieval"><a class="header" href="#retrieval">Retrieval</a></h3>
<p>To retrieve a key/value pair:</p>
<pre><code class="language-go">value, exists := myCache.get(&quot;somekey&quot;)
if !exists { 
  // fill cache for &quot;somekey&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-certificate"><a class="header" href="#msx-certificate">MSX Certificate</a></h1>
<p>The certificate module provides access to static and dynamic TLS/x509
certificate sources, including the following providers:</p>
<ul>
<li>File - load certs and keys from the filesystem</li>
<li>Vault - generate and renew certs and keys from Vault</li>
<li>Cache - save upstream certs and keys to disk</li>
</ul>
<p>The certificate module also provides a common configuration parser for
TLS configuration.</p>
<h2 id="sources"><a class="header" href="#sources">Sources</a></h2>
<p>A source identifies the provider and provider parameters required to obtain identity and authority certificates.</p>
<p>Each source is defined in the configuration using a unique name (lowercase alphanumeric only).
Source properties are configured under <code>certificate.source.&lt;sourcename&gt;</code>, for example:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
      provider: ...
      property1: ...
      property2: ...
      property3: ...
</code></pre>
<h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<p>Each source specifies a provider and its parameters.
Individual providers are detailed in the following sections.</p>
<h3 id="file"><a class="header" href="#file">File</a></h3>
<p>To specify the local filesystem as the source for certificates, use the File provider:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
    provider: file
    ca-cert-file: /etc/pki/tls/certs/ca-identity.crt
    cert-file: /etc/pki/tls/certs/spokeservice.pem
    key-file: /etc/pki/tls/private/spokeservice-key.pem
</code></pre>
<p>When a subsystem requests certificates from the <code>identity</code> source, it will:</p>
<ul>
<li>Load certificates from the filesystem for each TLS connection</li>
</ul>
<p>While <em>active</em> renewal is not supported, the file provider does read in changes
to the file for each connection.  The cert/key files may be rotated as convenient.</p>
<h4 id="configuration-properties"><a class="header" href="#configuration-properties">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ca-cert-file</code></td><td>-</td><td>Required</td><td>CA Certificate File, PEM format</td></tr>
<tr><td><code>cert-file</code></td><td>-</td><td>Required</td><td>Identity Certificate File, PEM format</td></tr>
<tr><td><code>key-file</code></td><td>-</td><td>Required</td><td>Identity Private Key File, PEM format</td></tr>
</tbody></table>
</div>
<h3 id="vault"><a class="header" href="#vault">Vault</a></h3>
<p>To specify Vault as the source for certificates, use the Vault provider:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
    provider: vault
    path: pki/vms
    role: &quot;${spring.application.name}&quot;
    cn: &quot;${spring.application.name}&quot;
    alt-names:
      - &quot;${network.hostname}&quot;
      - &quot;${spring.application.name}.svc.kubernetes.cluster.local&quot;
      - &quot;${spring.application.name}.service.consul&quot;
    ip-sans:
      - &quot;${network.outbound.address}&quot;
</code></pre>
<p>When a subsystem requests certificates from the <code>identity</code> source, it will:</p>
<ul>
<li>Generate an identity certificate and private key</li>
<li>Renew the identity certificate half-way through its lifetime.</li>
</ul>
<h4 id="configuration-properties-1"><a class="header" href="#configuration-properties-1">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>path</code></td><td>-</td><td>Required</td><td>Vault PKI mount point</td></tr>
<tr><td><code>role</code></td><td>-</td><td>Required</td><td>Vault PKI issuer role name</td></tr>
<tr><td><code>cn</code></td><td>-</td><td>Required</td><td>Desired identity certificate CN</td></tr>
<tr><td><code>alt-names</code></td><td>-</td><td>Optional</td><td>Desired identity certificate subject alternative names</td></tr>
<tr><td><code>ip-sans</code></td><td>-</td><td>Optional</td><td>Desired identity certificate IP subject alternative names</td></tr>
</tbody></table>
</div>
<p>Note: <code>alt-names</code> and <code>ip-sans</code> will be stripped of empty entries so may include
undefined variables with empty defaults:</p>
<pre><code>- ${some.undefined.variable:}
</code></pre>
<h3 id="cache"><a class="header" href="#cache">Cache</a></h3>
<p>To configure a cache for a remote certificate source, use the Cache provider:</p>
<pre><code class="language-yaml">certificate.source:

  identity:
    provider: vault
    path: pki/vms
    role: &quot;${spring.application.name}&quot;
    cn: &quot;${spring.application.name}&quot;
    alt-names:
      - &quot;${remote.service.hostname}&quot;
    ip-sans:
      - &quot;${kubernetes.pod.ip}&quot;
      - &quot;${remote.service.ip}&quot;
      
  identitycache:
    provider: cache
    upstream-source: identity
    key-file: &quot;/certs/${spring.application.name}-key.pem&quot;
    cert-file: &quot;/certs/${spring.application.name}.pem&quot;
    ca-cert-file: &quot;/etc/ssl/certs/ca-identity.crt&quot;
</code></pre>
<p>When a subsystem requests certificates from the <code>identitycache</code> source, it will:</p>
<ul>
<li>Generate and store an identity certificate and private key under <code>/certs</code></li>
<li>Retrieve and store the authority certificate under <code>/etc/ssl/certs</code>.</li>
<li>Renew the identity certificate half-way through its lifetime.</li>
</ul>
<h4 id="configuration-properties-2"><a class="header" href="#configuration-properties-2">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ca-cert-file</code></td><td>-</td><td>Required</td><td>CA Certificate File, PEM format</td></tr>
<tr><td><code>cert-file</code></td><td>-</td><td>Required</td><td>Identity Certificate File, PEM format</td></tr>
<tr><td><code>key-file</code></td><td>-</td><td>Required</td><td>Identity Private Key File, PEM format</td></tr>
</tbody></table>
</div>
<h2 id="tls-configuration"><a class="header" href="#tls-configuration">TLS Configuration</a></h2>
<p>TLS connection configuration is used in many places in go-msx, including:</p>
<ul>
<li>Kafka client</li>
<li>Web server</li>
</ul>
<p>For ease of use, these configurations have been unified into a single format.</p>
<h4 id="configuration-properties-3"><a class="header" href="#configuration-properties-3">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td><code>false</code></td><td>Optional</td><td>TLS should be enabled for this client/server</td></tr>
<tr><td><code>insecure-skip-verify</code></td><td><code>false</code></td><td>Optional</td><td>Verify the server's certificate chain and host name</td></tr>
<tr><td><code>min-version</code></td><td><code>tls12</code></td><td>Optional</td><td>Minimum TLS version to support.  One of: tls10, tls11, tls12, tls13</td></tr>
<tr><td><code>certificate-source</code></td><td>-</td><td>Optional</td><td>Server or Client certificate source.  Required for server.</td></tr>
<tr><td><code>cipher-suites</code></td><td><sup>1</sup></td><td>Optional</td><td>Cipher suites to enable.</td></tr>
<tr><td><code>server-name</code></td><td>-</td><td>Optional</td><td>Server name to check in certificate when connecting from client.</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> Current default cipher suites are:</p>
<ul>
<li>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305</li>
<li>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</li>
<li>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</li>
<li>TLS_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_RSA_WITH_AES_256_CBC_SHA</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-resource-module"><a class="header" href="#msx-resource-module">MSX Resource Module</a></h1>
<p>MSX Resource manages locating and accessing files from the source, staging, and runtime filesystems in a consistent fashion.</p>
<h2 id="filesystem"><a class="header" href="#filesystem">Filesystem</a></h2>
<p>To correctly use resources, it is first important to understand the resource filesystem, and how it is used to locate files during development and inside containers.</p>
<p>The resource filesystem contains one or more of the following layers, if found:</p>
<ul>
<li><strong>production</strong> - rooted in the Docker image at <code>/var/lib/${app.name}</code></li>
<li><strong>staging</strong> - rooted at <code>dist/root/var/lib/${app.name}</code> underneath the <strong>source</strong> root</li>
<li><strong>source</strong> - rooted at the folder containing the repository's <code>go.mod</code></li>
</ul>
<p>The resource filesystem will attempt to locate each of these folders and if found, will search it for your resource references.</p>
<h2 id="resource-references"><a class="header" href="#resource-references">Resource References</a></h2>
<p>The primary data type of the MSX resource module is the resource reference.  It represents the resource file subpath.  All resource paths use the forward-slash (<code>/</code>) as the path component separator. </p>
<p>Two types of paths can be used:</p>
<ul>
<li><strong>relative</strong> - No leading forward-slash (<code>data/my-resource.json</code>): File path is relative to the code file consuming the reference.</li>
<li><strong>absolute</strong> - Leading forward-slash (<code>/internal/migrate/resource.json</code>): File path is relative to the resource filesystem root.</li>
</ul>
<h3 id="obtaining-a-single-resource-reference"><a class="header" href="#obtaining-a-single-resource-reference">Obtaining a Single Resource Reference</a></h3>
<p>To work with a resource you must first create a reference to it using the <code>resource.Reference</code> function:</p>
<pre><code class="language-go">func processMyResource(ctx context.Context) error {
  myResourceRef := resource.Reference(&quot;data/my-resource.json&quot;)
}
</code></pre>
<p>This returns a <code>resource.Ref</code> object pointing to the specified path.</p>
<h3 id="obtaining-multiple-resource-references"><a class="header" href="#obtaining-multiple-resource-references">Obtaining Multiple Resource References</a></h3>
<p>To retrieve multiple resource references using a glob pattern you can call the <code>resource.References</code> function:</p>
<pre><code>func processMyResources(ctx context.Context) error {
  myResourceRefs := resource.References(&quot;data/*.json&quot;)
}
</code></pre>
<p>This returns a <code>[]resource.Ref</code> slice with an entry for each matching resource.</p>
<h2 id="consuming-resources"><a class="header" href="#consuming-resources">Consuming Resources</a></h2>
<p>Once you have obtained one or more resource references, you can access their contents using one of its methods.</p>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<p>To read in the contents of the resource as JSON and unmarshal it to an object, use the <code>Unmarshal()</code> method:</p>
<pre><code class="language-go">var myResourceContents MyResourceStruct
err := resource.Reference(&quot;data/my-resource.json&quot;).Unmarshal(&amp;myResourceContents)
</code></pre>
<h3 id="bytes"><a class="header" href="#bytes">Bytes</a></h3>
<p>To read in the contents of the resource as a  <code>[]byte</code>, use the <code>ReadAll()</code> method:</p>
<pre><code class="language-go">data, err := resource.Reference(&quot;data/my-resource.json&quot;).ReadAll()
</code></pre>
<h3 id="httpfile"><a class="header" href="#httpfile">http.File</a></h3>
<p>To open the file and return an <code>http.File</code>, use the <code>Open()</code> method:</p>
<pre><code class="language-go">file, err := resource.Reference(&quot;data/my-resource.json&quot;).Open()
</code></pre>
<p>Note that <code>http.File</code> also meets the requirements of the <code>io.ReadCloser</code> interface, and can therefore be used with <code>io</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sanitize"><a class="header" href="#sanitize">Sanitize</a></h1>
<p>MSX Sanitize allows request data to be pre-processed (before validation) to ensure potentially dangerous content is
removed. For example XSS and arbitrary HTML can be removed from plain-text strings.  MSX Sanitize also auto-sanitizes
log messages.</p>
<h2 id="sanitizing-input"><a class="header" href="#sanitizing-input">Sanitizing Input</a></h2>
<p>To explicitly sanitize a tree of data, including maps, slices, structs in-place:</p>
<pre><code class="language-go">if err := sanitize.Input(&amp;mydata, sanitize.NewOptions(&quot;xss&quot;)); err != nil {
	return err
}
</code></pre>
<p>After returning, mydata will be sanitized based on the supplied Options.</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>Options are available for each of the sanitizers from</p>
<pre><code>github.com/kennygrant/sanitize
</code></pre>
<p>including:</p>
<ul>
<li>Accents (<code>accents</code>) </li>
<li>BaseName (<code>basename</code>)</li>
<li>Xss (<code>xss</code>) </li>
<li>Name (<code>name</code>)</li>
<li>Path (<code>path</code>)</li>
</ul>
<p>Custom sanitizers provided by MSX Sanitize include:</p>
<ul>
<li>Secret (<code>secret</code>)</li>
</ul>
<h3 id="struct-tags"><a class="header" href="#struct-tags">Struct Tags</a></h3>
<p>To specify these options on a struct field, use the <code>san:&quot;...&quot;</code> tag, for example:</p>
<pre><code class="language-go">type MyRequest struct {
	Name 		string `json:&quot;name&quot; san:&quot;xss&quot;`
	Description string `json:&quot;description&quot; san:&quot;xss&quot;`
	Ignored 	string `json:&quot;ignored&quot; san:&quot;-&quot;`
}
</code></pre>
<p>In this struct, <code>Name</code> and <code>Description</code> fields indicate they must be sanitized for XSS/HTML content (<code>xss</code>),
and <code>Ignored</code> should not be sanitized at all (<code>-</code>).</p>
<p>NOTE: If a struct field does not have the <code>san</code> tag, it will inherit from its ancestors, up to the options passed
into the <code>sanitize.Input</code> call.</p>
<h2 id="sanitizing-logs"><a class="header" href="#sanitizing-logs">Sanitizing Logs</a></h2>
<p>Logs are auto-sanitized using some base rules.  These can be augmented by the microservice using the 
<code>sanitize.secrets</code> configuration:</p>
<pre><code class="language-yaml">sanitize.secrets:
  keys:
    - status
  custom:
    enabled: true
    patterns:
        - from: &quot;\\[userviceconfiguration/\\w+\\]&quot;
          to: &quot;[userviceconfiguration/...]&quot;
        - from: &quot;\\[secret/\\w+\\]&quot;
          to: &quot;[secret/...]&quot;
</code></pre>
<p>Within <code>sanitize.secrets</code> you can configure the following options:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>true</td><td>Optional</td><td>Enable secret replacement</td></tr>
<tr><td><code>keys</code></td><td>-</td><td>Optional</td><td>A set of XML/JSON/ToString attributes and objects to flag as sensitive</td></tr>
<tr><td><code>custom.*</code></td><td>-</td><td>Optional</td><td>Custom go regex replacement.  Does not use <code>keys</code>.</td></tr>
<tr><td><code>json.*</code></td><td>-</td><td>Optional</td><td>JSON replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
<tr><td><code>xml.*</code></td><td>-</td><td>Optional</td><td>XML replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
<tr><td><code>to-string.*</code></td><td>-</td><td>Optional</td><td>Stringer replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
</tbody></table>
</div>
<p>For <code>custom</code>, specify a list of regexes and replacements in <code>custom.patterns</code>, as above.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>custom.patterns[*].from</code></td><td>-</td><td>Required</td><td>Regex to match</td></tr>
<tr><td><code>custom.patterns[*].to</code></td><td>-</td><td>Required</td><td>Replacement (including variables)</td></tr>
</tbody></table>
</div>
<p>For <code>json</code>, <code>xml</code>, <code>tostring</code>, specify a list of regexes to match, including the named capture groups
<code>prefix</code> and <code>postfix</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>.enabled</code></td><td>true</td><td>Optional</td><td>Enable this set of patterns (<code>json</code>, <code>xml</code>, <code>to-string</code>)</td></tr>
<tr><td><code>.patterns[*].from</code></td><td>-</td><td>Required</td><td>Regex to match</td></tr>
<tr><td><code>.patterns[*].to</code></td><td><code>${prefix}*****${postfix}</code></td><td>Optional</td><td>Replacement (including regex variables)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="msx-scheduled-module"><a class="header" href="#msx-scheduled-module">MSX Scheduled Module</a></h1>
<p>MSX Scheduled manages the periodic execution of tasks within microservices.</p>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<p>The work to be performed on a periodic basis must be surrounded in an Action (a function signature matching<code>types.ActionFunc</code>):</p>
<pre><code class="language-go">func doWork(ctx context.Context) error {
  // TODO: perform the desired work.
} 
</code></pre>
<p>Actions can be anonymous functions, struct methods (as above), or static methods, and can also be derived from Operations (<code>types.Operation</code>).</p>
<h2 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h2>
<p>Scheduling a task requires two steps: Configuration and Registration.</p>
<h3 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h3>
<p>To configure the periodic execution, your task will need a simple name to identify its configuration.  For example, the <code>do-work</code> task can be configured as:</p>
<pre><code class="language-yaml">scheduled.tasks:
    do-work:
        fixed-interval: 10m
        # fixed-delay: 5m
        # initial-delay: 15m
        # cron-expression: &quot;0 0 0 * *&quot;
</code></pre>
<p>This example configuration will execute the <code>do-work</code> task (once registered) every 10 minutes.</p>
<p>To ensure a fixed period <em>between</em> executions, use the <code>fixed-delay</code> configuration instead.</p>
<p>To specify an initial delay before first execution that is different from <code>fixed-delay</code> or <code>fixed-interval</code>, specify the <code>initial-delay</code>.</p>
<p>To use a CRON expression to specify the execution schedule, use the <code>cron-expression</code> configuration.  For an overview of CRON expressions, see <a href="https://en.wikipedia.org/wiki/Cron">here</a>.</p>
<h3 id="registration"><a class="header" href="#registration">Registration</a></h3>
<p>To register your task at runtime, call the <code>scheduled.ScheduleTask</code> function during the application Start:</p>
<pre><code class="language-go">const taskNameDoWork = &quot;do-work&quot;

func init() {
  app.OnRootEvent(app.EventStart, app.PhaseAfter, func(ctx context.Context) error {
        return scheduled.ScheduleTask(ctx, taskNameDoWork, doWork)
  })
}
</code></pre>
<p>This will load the configuration using the supplied task name, and schedule the task according to the configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-transit-module"><a class="header" href="#msx-transit-module">MSX Transit Module</a></h1>
<p>MSX transit is an implementation of transit encryption.  It allows swappable encryption implementations via the <code>Provider</code> interface.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<p>The primary mode of consumption for MSX Transit is within business Models.  To add transit encryption support to your model, add an anonymous <code>transit.WithSecureData</code> member to your model structure:</p>
<pre><code class="language-go">type Organization struct {
	transit.WithSecureData
	OrganizationId string     `db:&quot;organization_id&quot;`
	TenantId       gocql.UUID `db:&quot;tenant_id&quot;`
}
</code></pre>
<p>This embedded struct will store its data in a field named <code>secure_data</code>, so a migration will need to add such a field if the table already exists:</p>
<pre><code class="language-sql">ALTER TABLE organization ADD COLUMN secure_data TEXT;
</code></pre>
<p>To store and retrieve individual encrypted fields from your model, add accessors:</p>
<pre><code class="language-go">const secureDataMerakiApiKey = &quot;merakiApiKey&quot;

func (o *Organization) MerakiApiKey(ctx context.Context) (string, error) {
	return o.SecureValue(ctx, organizationSecureFieldMerakiApiKey)
}

func (o *Organization) SetMerakiApiKey(ctx context.Context, value *string) error {
	return o.SetSecureValue(ctx, o.TenantId.Bytes(), secureDataMerakiApiKey, value)
}
</code></pre>
<p>You can then use these accessors in your converter and services to retrieve and store the values from your model.</p>
<h3 id="per-application-encryption"><a class="header" href="#per-application-encryption">Per-Application Encryption</a></h3>
<p>Sometimes you will want values to be encrypted, but non on a per-tenant basis.  In this case, define your key id within your domain package, and use it in place of the TenantId in your property setters:</p>
<pre><code class="language-go">var appKeyId := types.MustParseUUID(&quot;3e246fc7-12d8-4626-a739-1fd22bbf47f0&quot;)

func (o *Organization) SetMerakiApiKey(ctx context.Context, value *string) error {
	return o.SetSecureValue(ctx, appKeyId.Bytes(), secureDataMerakiApiKey, value)
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
