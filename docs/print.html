<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>go-msx</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="CONTRIBUTING.html">Contributing</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Cross-Cutting Concerns</li><li class="chapter-item expanded "><a href="log/index.html"><strong aria-hidden="true">1.</strong> Logging</a></li><li class="chapter-item expanded "><a href="types/docs/errors.html"><strong aria-hidden="true">2.</strong> Errors</a></li><li class="chapter-item expanded "><a href="config/index.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="app/index.html"><strong aria-hidden="true">4.</strong> Lifecycle</a></li><li class="chapter-item expanded "><a href="app/context.html"><strong aria-hidden="true">5.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="stats/index.html"><strong aria-hidden="true">6.</strong> Stats</a></li><li class="chapter-item expanded "><a href="trace/index.html"><strong aria-hidden="true">7.</strong> Tracing</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Application Components</li><li class="chapter-item expanded "><a href="webservice/controller.html"><strong aria-hidden="true">8.</strong> Controller</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Filter</div></li><li class="chapter-item expanded "><a href="sqldb/repository.html"><strong aria-hidden="true">10.</strong> Repository</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Migration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Integration</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="integration/docs/openapi.html"><strong aria-hidden="true">12.1.</strong> OpenAPI Client ðŸŽ‰</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Streaming</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ops/streamops/index.html"><strong aria-hidden="true">13.1.</strong> Stream Operations ðŸŽ‰</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ops/streamops/ports.html"><strong aria-hidden="true">13.1.1.</strong> Ports</a></li><li class="chapter-item expanded "><a href="ops/streamops/validation.html"><strong aria-hidden="true">13.1.2.</strong> Validation</a></li><li class="chapter-item expanded "><a href="ops/streamops/publishers.html"><strong aria-hidden="true">13.1.3.</strong> Publishers</a></li><li class="chapter-item expanded "><a href="ops/streamops/subscribers.html"><strong aria-hidden="true">13.1.4.</strong> Subscribers</a></li><li class="chapter-item expanded "><a href="schema/asyncapi/index.html"><strong aria-hidden="true">13.1.5.</strong> AsyncApi</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.</strong> Stream Providers</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.1.</strong> Kafka</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.2.</strong> SQL</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.3.</strong> GoChannel</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.4.</strong> Redis</div></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Utilities</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Audit Events</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Auditable Models</div></li><li class="chapter-item expanded "><a href="cache/lru/index.html"><strong aria-hidden="true">16.</strong> Cache</a></li><li class="chapter-item expanded "><a href="certificate/index.html"><strong aria-hidden="true">17.</strong> Certificates and TLS</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Executing Commands</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Health Checks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Http Client</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Leader Election</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Pagination</div></li><li class="chapter-item expanded "><a href="resource/index.html"><strong aria-hidden="true">23.</strong> Resources</a></li><li class="chapter-item expanded "><a href="retry/index.html"><strong aria-hidden="true">24.</strong> Retry</a></li><li class="chapter-item expanded "><a href="sanitize/index.html"><strong aria-hidden="true">25.</strong> Sanitization</a></li><li class="chapter-item expanded "><a href="scheduled/index.html"><strong aria-hidden="true">26.</strong> Scheduled Tasks</a></li><li class="chapter-item expanded "><a href="transit/index.html"><strong aria-hidden="true">27.</strong> Transit Encryption</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Validation</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Code Generation</li><li class="chapter-item expanded "><a href="skel/index.html"><strong aria-hidden="true">29.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="skel/docs/installation.html"><strong aria-hidden="true">30.</strong> Installation</a></li><li class="chapter-item expanded "><a href="skel/docs/usage.html"><strong aria-hidden="true">31.</strong> Usage</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.</strong> Projects</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="skel/docs/projects-generic.html"><strong aria-hidden="true">32.1.</strong> Generic Microservice</a></li><li class="chapter-item expanded "><a href="skel/docs/projects-beats.html"><strong aria-hidden="true">32.2.</strong> Probes (Beats)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.3.</strong> Service Pack Microservice</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.4.</strong> Service Pack UI</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.</strong> Continuous Integration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.</strong> Web Services</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">34.1.</strong> Domains</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.2.</strong> OpenAPI</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">35.</strong> Stream Services</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="skel/asyncapi/channels.html"><strong aria-hidden="true">35.1.</strong> Channels</a></li><li class="chapter-item expanded "><a href="skel/asyncapi/spec.html"><strong aria-hidden="true">35.2.</strong> AsyncAPI</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Builds ðŸŽ‰</li><li class="chapter-item expanded "><div><strong aria-hidden="true">36.</strong> Introduction</div></li><li class="chapter-item expanded "><a href="build/docs/usage-make.html"><strong aria-hidden="true">37.</strong> Makefile Usage</a></li><li class="chapter-item expanded "><a href="build/docs/usage-build.html"><strong aria-hidden="true">38.</strong> Build Usage</a></li><li class="chapter-item expanded "><a href="build/docs/config.html"><strong aria-hidden="true">39.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="build/docs/targets.html"><strong aria-hidden="true">40.</strong> Build Targets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="build/docs/targets-project.html"><strong aria-hidden="true">40.1.</strong> Project Maintenance</a></li><li class="chapter-item expanded "><a href="build/docs/targets-development.html"><strong aria-hidden="true">40.2.</strong> Development</a></li><li class="chapter-item expanded "><a href="build/docs/targets-artifacts.html"><strong aria-hidden="true">40.3.</strong> Artifacts</a></li><li class="chapter-item expanded "><a href="build/docs/targets-verification.html"><strong aria-hidden="true">40.4.</strong> Verification</a></li><li class="chapter-item expanded "><a href="build/docs/targets-publishing.html"><strong aria-hidden="true">40.5.</strong> Publishing</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Continuous Integration</li><li class="chapter-item expanded "><a href="checks/index.html"><strong aria-hidden="true">41.</strong> Checks ðŸŽ‰</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">42.</strong> Jenkins</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">go-msx</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-msx"><a class="header" href="#go-msx">go-msx</a></h1>
<p>go-msx is a Go library for microservices and tools interacting with MSX. </p>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<p>Support for go-msx and related projects is available on the <a href="https://ciscovms.slack.com/messages/go-msx">#go-msx</a>
channel on the <a href="https://ciscovms.slack.com/">MSX slack workspace</a>.</p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>Currently this library and tools are in a pre-alpha state.  They are subject to
backwards-incompatible changes at <em>any</em> time.  After reaching the first stable release (v1.0.0),
<a href="https://semver.org/">SemVer</a> will be used per industry and golang best practices.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>
<p>Go 1.18+</p>
<ul>
<li>
<p>Ensure your GOPATH is correctly set and referenced in your PATH.  For example:</p>
<pre><code class="language-bash">export GOPATH=~/go
export PATH=$PATH:$GOPATH/bin
</code></pre>
</li>
<li>
<p>Be sure to set your Go proxy settings correctly.  For example:</p>
<pre><code class="language-bash">go env -w GOPRIVATE=cto-github.cisco.com/NFV-BU
</code></pre>
</li>
</ul>
</li>
<li>
<p>Git SSH configuration for <code>cto-github.cisco.com</code></p>
<ul>
<li>
<p>Ensure you have a registered SSH key referenced in your <code>~/.ssh/config</code>:</p>
<pre><code>Host cto-github.cisco.com
      HostName cto-github.cisco.com
      User git
      IdentityFile ~/.ssh/github.key
</code></pre>
<p>Note that this key must be registered via the <a href="https://cto-github.cisco.com/settings/keys">Github UI</a>.</p>
</li>
<li>
<p>Ensure you have SSH protocol override for git HTTPS urls to our github in your <code>~/.gitconfig</code>:</p>
<pre><code>[url &quot;ssh://git@cto-github.cisco.com/&quot;]
        insteadOf = https://cto-github.cisco.com/
</code></pre>
</li>
</ul>
</li>
<li>
<p>Skel tool for code generation</p>
<ul>
<li>
<p>Check out go-msx into your local workspace:</p>
<pre><code class="language-bash">mkdir -p $HOME/msx &amp;&amp; cd $HOME/msx
git clone git@cto-github.cisco.com:NFV-BU/go-msx.git
cd go-msx
go mod download
</code></pre>
</li>
<li>
<p>Install <code>skel</code>:</p>
<pre><code class="language-bash">make install-skel
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<ul>
<li>
<p>To continue working on an existing go-msx project:</p>
<ul>
<li>Return to the original project README instructions
and continue.</li>
</ul>
</li>
<li>
<p>To add go-msx to an existing module-enabled go project:</p>
<pre><code class="language-bash">go get -u cto-github.cisco.com/NFV-BU/go-msx
</code></pre>
</li>
<li>
<p>To create a new go-msx microservice skeleton project:</p>
<pre><code class="language-bash">cd $HOME/msx
skel
</code></pre>
</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>Please visit our <a href="https://cto-github.cisco.com/pages/NFV-BU/go-msx">internal site</a>
or <a href="https://mcrawfo2.github.io/go-msx/">public site</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright Â© 2019-2022, Cisco Systems Inc.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<ul>
<li>
<p>Ensure you create a meaningfully named topic branch for your code:</p>
<p><code>feature/sql-transactions</code></p>
<p><code>bugfix/populate-error-handling</code></p>
</li>
<li>
<p>Make your code changes</p>
</li>
<li>
<p>Run <code>make precommit</code> to regenerate, reformat, license, etc.</p>
</li>
<li>
<p>Commit your code to your topic branch</p>
</li>
<li>
<p>Rebase your topic branch onto master (do not reverse merge master into your branch)</p>
</li>
<li>
<p>Ensure your commits are cohesive, or just squash them</p>
</li>
<li>
<p>Create a Pull Request with a meaningful title similar to your topic branch name</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-logging-module"><a class="header" href="#msx-logging-module">MSX Logging Module</a></h1>
<p>MSX logging is an extension of the popular <code>logrus</code> logging library, to include:</p>
<ul>
<li>Log names</li>
<li>Level-specific loggers</li>
<li>Improved context handling</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>After importing the MSX log package, you can use the default named logger <code>msx</code> simply:</p>
<pre><code class="language-go">import &quot;cto-github.cisco.com/NFV-BU/go-msx/log&quot;

var logger = log.StandardLogger()

func main() {
    var action = &quot;started&quot;
    logger.Infof(&quot;Something happened: %s&quot;, action) 
}
</code></pre>
<p>To use a logger with a custom name:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;alert.api&quot;)
</code></pre>
<p>To create a logger named after the current module:</p>
<pre><code class="language-go">var logger = log.NewPackageLogger()
</code></pre>
<p>To create a levelled logger, which outputs print at the defined log level:</p>
<pre><code class="language-go">debugLogger := logger.Level(log.DebugLevel)
debugLogger.Printf(&quot;Some template: %s&quot;, &quot;inserted&quot;)
</code></pre>
<p>To record a golang <code>error</code> object:</p>
<pre><code class="language-go">func DeployResource(data []byte) {
    var body ResourceDeployment
    if err := json.Unmarshal(data, &amp;body); err != nil {
        logger.
            WithError(err).
            Error(&quot;Failed to parse Resource Deployment request&quot;)
    }
}
</code></pre>
<p>To use the log context that was embedded in a Context object:</p>
<pre><code class="language-go">func HandleRequest(ctx context.Context) {
    requestLogger := logger.WithContext(ctx)
    ...
}
</code></pre>
<p>To add one-time custom diagnostic fields:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;tenant&quot;)

func HandleGetTenantRequest(tenantId string) {
    logger.
        WithExtendedField(&quot;tenantId&quot;, tenantId).
        Debug(&quot;Tenant retrieval requested&quot;)
}
</code></pre>
<p>To create a sub-logger with custom diagnostic fields:</p>
<pre><code class="language-go">var logger = log.NewLogger(&quot;services.tenant&quot;)

func HandleGetTenantRequest(tenantId string) {
    requestLogger := logger.WithExtendedField(&quot;tenantId&quot;, tenantId)
    requestLogger.Debugf(&quot;some message&quot;)
}
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="logging-levels"><a class="header" href="#logging-levels">Logging Levels</a></h3>
<p>MSX Logging defines the following log levels:</p>
<ul>
<li>Trace</li>
<li>Debug</li>
<li>Info</li>
<li>Warn</li>
<li>Error</li>
<li>Panic</li>
<li>Fatal</li>
</ul>
<p>A logging level filter can be set globally:</p>
<pre><code class="language-go">log.SetLevel(log.WarnLevelName)
</code></pre>
<p>This will ensure all loggers not configured at a more strict level only output messages with a level of <code>WARN</code> or above.</p>
<p>An individual logger (and its sub-loggers) can be set to a minimum level:</p>
<pre><code class="language-go">logger = log.NewLogger(&quot;msx.beats&quot;)
logger.SetLevel(log.LevelByName(log.InfoLevelName)))
</code></pre>
<p>Configuration (eg. command line options) can be used to set a logger minimum level:</p>
<pre><code class="language-bash">myapp --logger.msx.beats=debug
</code></pre>
<p>This will set the minimum level of the <code>msx.beats</code> logger tree to <code>DEBUG</code> after
the application configuration has been loaded.</p>
<h3 id="output-format"><a class="header" href="#output-format">Output Format</a></h3>
<p>Output can be switched to JSON formatting:</p>
<pre><code class="language-go">log.SetFormat(log.LogFormatJson)
</code></pre>
<p>And back to LogFmt formatting:</p>
<pre><code class="language-go">log.SetFormat(log.LogFormatLogFmt)
</code></pre>
<p>By default, all output is sent to standard output, with high-resolution
timestamps. See <a href="log/init.go">init.go</a> for specifics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<p>Go has a built-in <code>error</code> interface to be implemented by error
models.</p>
<p>go-msx has chosen to use the <code>github.com/pkg/errors</code>
module to implement errors.  This custom error module enables collecting
stack traces, critical for logging and debugging of errors.</p>
<p>When instantiating or wrapping an error,
use this package instead of the standard library <code>errors</code> package.</p>
<pre><code class="language-go">
import (
	&quot;context&quot;
	&quot;github.com/pkg/errors&quot;
)

// Create a globally visible error
var MyStaticError = errors.New(&quot;Static error occurred&quot;)
var MyOtherError = errors.New(&quot;Other error occurred&quot;)
	
// Return the global error
func mine(ctx context.Context) error {
  return MyStaticError
}

// Wrap the error into your own domain
func yours(ctx context.Context) error {
  return errors.Wrap(mine(ctx), &quot;Something bad happened&quot;)
}

func callYours(ctx context.Context) error {
  err := yours(ctx)
  if errors.Is(err, MyStaticError) {
    // Special handling for this error type		
  } else {
    // General hanlding for any other error types
    return err
  }
  return nil
}
</code></pre>
<p>The above example shows how to create a global error, and how to re-contextualize (wrap)
inside the parent.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Composite errors implement the <code>CompositeError</code> interface:</p>
<pre><code class="language-go">type CompositeError interface {
  Errors() interface{}
}
</code></pre>
<p>go-msx provides two composite error models: <code>ErrorMap</code> and <code>ErrorList</code>.
Each of these represents a set of errors.</p>
<ul>
<li>
<p><code>ErrorMap</code> : Represents a set of key-error pairs, intended to map to sub-parts
of a structured parent component.</p>
<pre><code class="language-go">return types.ErrorMap{
    &quot;element1&quot;: validation.Validate(&amp;element1, validation.Required)
    &quot;element2&quot;: validation.Validate(&amp;element2, validation.MinLength(1))
}
</code></pre>
</li>
<li>
<p><code>ErrorList</code> : Represents a series of error instances (or nils), intended to map
to elements in a parent sequence.</p>
<pre><code class="language-go">return types.ErrorList{
    validation.Validate(&amp;parent[0], validation.Required)
    validation.Validate(&amp;parent[1], validation.MinLength(1))
}
</code></pre>
</li>
</ul>
<p>The above error models also implement <code>Filterable</code>:</p>
<pre><code class="language-go">type Filterable interface {
  Filter() error
}
</code></pre>
<p>This allows the composite error to collect non-error (nil) values, which will
be removed from the return value of <code>Filter()</code>.  This feature is used by the 
validate package during DTO validation.</p>
<h2 id="log-customization"><a class="header" href="#log-customization">Log Customization</a></h2>
<p>To enable attaching custom log fields from your error, the logging
subsystem checks if your error implements the LogFielder interface:</p>
<pre><code class="language-go">type LogFielder interface {
  LogFields() map[string]interface{}
}
</code></pre>
<p>Any fields returned by the <code>LogFields()</code> function will be added
as log fields if the error is output to the log via <code>WithError()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-configuration-module"><a class="header" href="#msx-configuration-module">MSX Configuration Module</a></h1>
<p>MSX configuration is a spring-compatible dynamic configuration library.  It includes support for:</p>
<ul>
<li>remote configuration stores</li>
<li>dynamic configuration updates</li>
<li>JSON, JSON5, YAML, INI and Properties files </li>
<li>key normalization </li>
<li>structure population</li>
</ul>
<h2 id="model"><a class="header" href="#model">Model</a></h2>
<p>MSX Configuration has three main components: <strong>providers</strong>, <strong>settings</strong>, and the <strong>config</strong> object. </p>
<ul>
<li><strong>Providers</strong> load settings for your application. This could be from a file, environment variables, or some other source of configuration.</li>
<li><strong>Settings</strong> represent the configuration options for your application. Settings are represented as key/value pairs. </li>
<li><strong>Config</strong> holds all of the providers and loaded settings. This object allows you to load, watch, retrieve, apply and convert your settings.</li>
</ul>
<p>Each provider combines its contents together into a single keyspace; these are then superposed (like a &quot;1000-layer lasagna&quot;) in order to produce a final combined keyspace and key/value mapping.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h3>
<p>When using MSX Configuration inside the MSX Application context, you can retrieve the configuration object from the <code>ctx context.Context</code>:</p>
<pre><code class="language-go">cfg := config.MustFromContext(ctx)
</code></pre>
<p>When using MSX Configuration outside of the MSX Application context, you can instantiate your own providers.  For example, to consume the environment variables from the current process:</p>
<pre><code class="language-go">environmentProvider := config.NewEnvironment(&quot;env&quot;)
cfg := config.NewConfig(environmentProvider)
</code></pre>
<h3 id="value-retrieval"><a class="header" href="#value-retrieval">Value Retrieval</a></h3>
<p>Using one of the above <code>cfg</code> objects, you can retrieve the user's home directory from the <code>HOME</code> environment variable.  Note that all config keys are normalized to be lowercase, no hyphens, period-separated.  This means the <code>HOME</code> environment variable will be mapped to <code>home</code>:</p>
<pre><code class="language-go">homePath, err := cfg.String(&quot;home&quot;)
</code></pre>
<p>The <code>cfg</code> object presents a number of functions to return a strongly-typed value:</p>
<ul>
<li><code>String(key string)</code></li>
<li><code>Int(key string)</code></li>
<li><code>Float(key string)</code></li>
<li><code>Bool(key string)</code></li>
</ul>
<p>These functions will look up the specified key in the configuration, and if found, will attempt to convert the value to the specified type.  If the key is not found or configuration has not yet been loaded, an appropriate error will be returned.</p>
<p>If you wish to use an alternative (default) value in case the lookup fails, you can use the <code>Or</code> functions:</p>
<ul>
<li><code>StringOr(key string, other string)</code></li>
<li><code>Int(key string, other int)</code></li>
<li><code>Float(key string, other float)</code></li>
<li><code>Bool(key string, other bool)</code></li>
</ul>
<p>The specified <code>other</code> value will be returned if the config has been loaded, but lookup fails:</p>
<pre><code class="language-go">buildPath, err := cfg.StringOr(&quot;build.path&quot;, &quot;./build&quot;)
</code></pre>
<h3 id="structure-population"><a class="header" href="#structure-population">Structure Population</a></h3>
<p>You can also populate appropriately defined structures:</p>
<pre><code class="language-go">type ConnectionConfig struct {
    Name string
    Skipped bool `config:&quot;-&quot;`
    AnotherName int `config:&quot;somethingelse&quot;`
}

var connectionConfig ConnectionConfig
err := cfg.Populate(&amp;connectionConfig, &quot;some.connection&quot;)
</code></pre>
<p>Each structure field is treated a little differently based on the contents/existence of the <code>config</code> struct tag:</p>
<ul>
<li><code>Name</code>: populated from <code>some.connection.name</code> (default behaviour)</li>
<li><code>Skipped</code>: not populated due to the <code>config:&quot;-&quot;</code> (omit when source name is a hyphen)</li>
<li><code>AnotherName</code>: populated from <code>some.connection.somethingelse</code> (overridden field name)</li>
</ul>
<h2 id="spring-compatibility"><a class="header" href="#spring-compatibility">Spring Compatibility</a></h2>
<p>One of the primary goals for MSX Configuration is close compatibility with Spring-style configuration.
Several known incompatibilities and limitations currently exist:</p>
<ol>
<li>Key Normalization
<ul>
<li>Configuration keys in MSX Configuration are simply normalized to be lowercase, no hyphens, period-separated. As of Spring 2.0, configuration keys are expected to be snake-case, period-separated. MSX Configuration cannot distinguish between the <code>app.some-data</code> and <code>app.somedata</code> keys, and normalizes them both to <code>app.somedata</code>.</li>
</ul>
</li>
<li>Arbitrary Population
<ul>
<li>MSX Configuration currently supports <code>@ConfigurationProperties</code> style structure population.  As a consequence, all data used to populate a structure must be direct descendants of the key used to populate the structure.  We intend to support arbitrary key specification for structures in the future.</li>
</ul>
</li>
</ol>
<h2 id="built-in-providers"><a class="header" href="#built-in-providers">Built-In Providers</a></h2>
<p>MSX Configuration has many built-in providers, allowing the application to unify configuration from a wide variety of sources:</p>
<ul>
<li><code>INIFile</code> - Loads settings from a <code>.ini</code> file</li>
<li><code>JSONFile</code>  - Loads settings from a <code>.json</code> or <code>.json5</code> file</li>
<li><code>YAMLFile</code> - Loads settings from a <code>.yaml</code> or <code>.yml</code> file</li>
<li><code>TOMLFile</code> - Loads settings from a <code>.toml</code> file</li>
<li><code>PropertiesFile</code> - Loads settings from a <code>.properties</code> file</li>
<li><code>CobraProvider</code> - Loads settings from a Cobra command context</li>
<li><code>PFlagProvider</code> - Loads settings from PFlag flagset</li>
<li><code>GoFlagProvider</code> - Loads settings from a go flag flagset</li>
<li><code>ConsulProvider</code> - Loads settings from Consul</li>
<li><code>VaultProvider</code> - Loads settings from Vault</li>
<li><code>Environment</code> - Loads settings from environment variables </li>
<li><code>Static</code> - Loads settings from an in-memory map</li>
</ul>
<h3 id="helpers"><a class="header" href="#helpers">Helpers</a></h3>
<p>Along with the above providers, there are some wrappers for managing config lifecycle:</p>
<ul>
<li><code>CachedLoader</code> - Caches settings in memory until flushed by <code>Invalidate()</code></li>
<li><code>OnceLoader</code> - Caches settings in memory permanently</li>
<li><code>Resolver</code> - Remaps settings from one key to another</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-application-module"><a class="header" href="#msx-application-module">MSX Application Module</a></h1>
<p>MSX Application is a simple state machine for managing application lifecycle.  It installs observers to configure and instantiate the standard components for use with MSX applications.  This includes listeners for external events to advance the state machine (e.g. POSIX signals, configuration changes).</p>
<h2 id="lifecycle-events"><a class="header" href="#lifecycle-events">Lifecycle Events</a></h2>
<p>MSX Application defines various lifecycle events:</p>
<ul>
<li><code>app.EventCommand</code> - mode selection based on CLI sub-commands</li>
<li><code>app.EventInit</code> - pre-configure application </li>
<li><code>app.EventConfigure</code> - application and component configuration </li>
<li><code>app.EventStart</code> - start services for consumers</li>
<li><code>app.EventReady</code> - application fully initialized and ready to service requests</li>
<li><code>app.EventRefresh</code> - update configuration after change</li>
<li><code>app.EventStop</code> - stop services for consumers</li>
<li><code>app.EventFinalize</code> - pre-termination cleanup</li>
</ul>
<p>Each event (except <code>app.EventCommand</code>) proceeds with three phases:</p>
<ul>
<li><code>app.PhaseBefore</code> - early</li>
<li><code>app.PhaseDuring</code> - normal</li>
<li><code>app.PhaseAfter</code> - late</li>
</ul>
<p>The <code>app.EventCommand</code> event will be execute with the <code>phase</code> containing the command being executed.  The following commands are pre-defined:</p>
<ul>
<li><code>app.CommandRoot</code> - Root (default)</li>
<li><code>app.CommandMigrate</code> - Migrate</li>
<li><code>app.CommandPopulate</code> - Populate</li>
</ul>
<h3 id="event-observers"><a class="header" href="#event-observers">Event Observers</a></h3>
<p>When a lifecycle event phase is occurring, the MSX Application will call each of the <code>Observer</code>s registered for the event phase.  These callbacks can be registered during any previous lifecycle event callback or during your module <code>init()</code>.</p>
<p>For example, to call the <code>addWebService</code> observer during <code>start.before</code> for all commands:</p>
<pre><code class="language-go">func init() {
    app.OnEvent(app.EventStart, app.PhaseBefore, addWebService)
}
</code></pre>
<p>To see an example showing command-specific event observers, see <a href="app/index.html#Commanding">Commanding</a>, below.</p>
<h3 id="short-circuiting"><a class="header" href="#short-circuiting">Short-Circuiting</a></h3>
<p>Sometimes an application is not able to correctly execute a lifecycle phase, or receives an external interruption.  This will result in a short-circuit of the lifecycle.  If an error is returned from one of the observers in the following phases, the lifecycle will move to the specified phase:</p>
<ul>
<li><code>app.EventInit</code> =&gt; <code>app.EventFinalize</code></li>
<li><code>app.EventConfigure</code> =&gt; <code>app.EventFinalize</code></li>
<li><code>app.EventStart</code> =&gt; <code>app.EventStop</code></li>
<li><code>app.EventReady</code> =&gt; <code>app.EventStop</code></li>
</ul>
<h2 id="application-observers"><a class="header" href="#application-observers">Application Observers</a></h2>
<h3 id="command"><a class="header" href="#command">Command</a></h3>
<p>The <code>app.EventCommand</code> events are the first events fired during startup.  They provide the opportunity to execute custom logic and register event observers specific to the command.</p>
<p>As above, the <code>app.EventCommand</code> event will be executed with the phase containing the command being executed.  For example the phase could be one of the default commands:</p>
<ul>
<li>Root (<code>app.CommandRoot</code>)</li>
<li>Migrate (<code>app.CommandMigrate</code>)</li>
<li>Populate (<code>app.CommandPopulate</code>)</li>
</ul>
<p>To add a new command:</p>
<pre><code class="language-go">func main() {
    if _, err := app.AddCommand(&quot;token&quot;, &quot;Create OAuth2 token&quot;, renew, app.Noop); err != nil {
        cli.Fatal(err)
    }
}
</code></pre>
<p>To configure event observers in response to a specific command being executed:</p>
<pre><code class="language-go">func init() {
    app.OnEvent(app.EventCommand, app.CommandRoot, func(ctx context.Context) error {
        app.OnEvent(app.EventStart, app.PhaseBefore, addWebService)
        return nil
    })
}
</code></pre>
<h3 id="init"><a class="header" href="#init">Init</a></h3>
<p>The <code>app.EventInit</code> events are fired second, after the <code>app.EventCommand</code> events.</p>
<p>Observers attached to the <code>app.EventInit</code> events should be restricted to modifying the application environment.  This includes registering custom config providers or custom context injectors.</p>
<h3 id="configure"><a class="header" href="#configure">Configure</a></h3>
<p>The <code>app.EventConfigure</code> events are fired third during startup, after the <code>app.EventInit</code> events.</p>
<p>By default, the application is configured:</p>
<ul>
<li><code>app.PhaseBefore</code>
<ul>
<li>Register remote config providers</li>
</ul>
</li>
<li><code>app.PhaseDuring</code>
<ul>
<li><a href="app/index.html#configuration-loading">Load configuration</a></li>
</ul>
</li>
<li><code>app.PhaseAfter</code>
<ul>
<li>HTTP Client</li>
<li>Consul connection pool</li>
<li>Vault connection pool</li>
<li>Cassandra connection pool</li>
<li>Redis connection pool</li>
<li>Kafka connection pool</li>
<li>Web server</li>
<li>Create Cassandra Keyspace</li>
</ul>
</li>
</ul>
<p>Typically, user applications will not register new event handlers for the <code>app.EventConfigure</code> events.</p>
<h3 id="start"><a class="header" href="#start">Start</a></h3>
<p>The <code>app.EventStart</code> events are fired fourth during startup, after the <code>app.EventConfigure</code> events.</p>
<p>By default, application infrastructure is connected:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Authentication Providers</li>
<li>Spring Actuators</li>
<li>Swagger</li>
<li>Prometheus Actuator</li>
<li>Stats Pusher</li>
</ul>
</li>
<li><code>app.PhaseAfter</code>:
<ul>
<li>Health logging</li>
<li>Stream Router</li>
<li>Web Server</li>
<li>Config Watcher</li>
</ul>
</li>
</ul>
<p>Custom application startup code is expected to run inside the <code>app.PhaseDuring</code> phase.  This would include starting any long-running services or scheduling background tasks.</p>
<h3 id="ready"><a class="header" href="#ready">Ready</a></h3>
<p>The <code>app.EventReady</code> events are fired fifth during startup, after the <code>app.EventStart</code> events.</p>
<p>By default, application ready observers are executed:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Service Registration (consul)</li>
</ul>
</li>
<li><code>app.PhaseAfter</code>:
<ul>
<li>Command Execution (sub-commands)</li>
</ul>
</li>
</ul>
<h3 id="refresh"><a class="header" href="#refresh">Refresh</a></h3>
<p><em>TBD</em></p>
<h3 id="stop"><a class="header" href="#stop">Stop</a></h3>
<p>The <code>app.EventStop</code> events are fired first during shutdown.</p>
<p>By default, application services are stopped and infrastructure and disconnected:</p>
<ul>
<li><code>app.PhaseBefore</code>:
<ul>
<li>Service De-Registration (consul)</li>
<li>Health logging</li>
<li>Stream router</li>
<li>Web Server</li>
<li>Stats Pusher</li>
</ul>
</li>
</ul>
<p>Any custom application code running in the background should be shutdown during <code>app.PhaseDuring</code>.</p>
<h3 id="finalize"><a class="header" href="#finalize">Finalize</a></h3>
<p>The <code>app.EventFinal</code> events are fired last during shutdown.</p>
<p>By default, tracing is stopped during <code>app.PhaseAfter</code> to allow trace collection to include <code>app.EventStop</code>.</p>
<h2 id="configuration-loading"><a class="header" href="#configuration-loading">Configuration Loading</a></h2>
<p>In response to the <code>app.EventConfigure</code> event, MSX Application combines all registered sources of configuration.  This occurs in three phases:</p>
<ul>
<li><strong>Phase 1</strong> - In-Memory
<ul>
<li>Application Static Defaults</li>
<li>Environment Variables</li>
<li>Application Runtime Overrides</li>
<li>Command Line</li>
</ul>
</li>
<li><strong>Phase 2</strong> - Filesystem
<ul>
<li>Defaults Files</li>
<li>Bootstrap Files</li>
<li>Application Files</li>
<li>Profile Files </li>
<li>Build Files</li>
</ul>
</li>
<li><strong>Phase 3</strong> - Remote
<ul>
<li>Consul</li>
<li>Vault</li>
</ul>
</li>
</ul>
<p>Note that this loading order is not the same as the order of precendence for calculating values:</p>
<ul>
<li>Application Static Defaults</li>
<li>Defaults Files</li>
<li>Bootstrap Files</li>
<li>Application Files</li>
<li>Build Files</li>
<li>Consul</li>
<li>Vault</li>
<li>Profile Files</li>
<li>Environment Variables</li>
<li>Command Line</li>
<li>Application Runtime Overrides</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-dependencies"><a class="header" href="#msx-dependencies">MSX Dependencies</a></h1>
<p>In large applications, inter-object dependency management becomes more challenging.  Within the go standard library, the <a href="https://blog.golang.org/context"><code>Context</code></a> object is provided to share dependencies and cancellation.  This simplifies writing unit tests, since dependencies can be injected via the context.</p>
<p>MSX Application provides a <code>Context</code> object to event <code>Observer</code>s so they may inject new dependencies for their subsystems.  The context object also carries Trace information for logging and trace publishing.</p>
<p>By default, the following dependencies are added to the MSX Application context:</p>
<ul>
<li>Configuration</li>
<li>Cassandra client pool</li>
<li>Cockroach client pool</li>
<li>Consul client pool</li>
<li>Vault client pool</li>
<li>Redis client pool</li>
<li>Kafka client pool</li>
<li>Http client factory</li>
</ul>
<p>During <code>migrate</code> execution, the Migration Manifest is also available from the context.</p>
<h2 id="accessing-dependencies"><a class="header" href="#accessing-dependencies">Accessing Dependencies</a></h2>
<p>To support adding a custom dependency to any context, define the standard context chaining pattern:</p>
<pre><code class="language-go">type DomainServiceApi interface {
}

type domainContextKey int

const contextKeyDomainService domainContextKey = iota

func ContextWithDomainService(ctx context.Context, domainService DomainServiceApi) context.Context {
	return context.WithValue(ctx, contextKeyDomainService, domainService)
}

func DomainServiceFromContext(ctx context.Context) DomainServiceApi {
    return ctx.Value(contextKeyDomainService).(DomainServiceApi)
}
</code></pre>
<p>To inject your custom dependency to the current context:</p>
<pre><code class="language-go">ctx := domain.ContextWithDomainService(ctx, domainService)
</code></pre>
<p>To retrieve a dependency from the current context:</p>
<pre><code class="language-go">domainServiceApi := domain.DomainServiceFromContext(ctx)
</code></pre>
<h2 id="logging-and-tracing"><a class="header" href="#logging-and-tracing">Logging and Tracing</a></h2>
<p>To apply logging and tracing fields from the current context:</p>
<pre><code class="language-go">myLogger.WithContext(ctx).Info(&quot;My log message&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-statistics"><a class="header" href="#msx-statistics">MSX Statistics</a></h1>
<p>MSX Statistics allows applications to monitor and record application metrics for display on dashboards and generation of application alarms.  We have chosen to support Prometheus and its OpenMetrics format to expose collected data.</p>
<h2 id="statistics-types"><a class="header" href="#statistics-types">Statistics Types</a></h2>
<p>MSX Statistics supports several base data collection types:</p>
<ul>
<li>
<p><strong>Counter</strong></p>
<p>A counter is an ever-increasing number. For example, &quot;Completed Requests&quot; will continuously increase throughout the lifetime of the application.  It is initialized to zero on application startup.</p>
</li>
<li>
<p><strong>Gauge</strong></p>
<p>A gauge is a metric that represents a single numerical value that can arbitrarily go up and down. For example, &quot;Active Requests&quot; increases when a new request arrives, and decreases when a request is fully serviced.</p>
</li>
<li>
<p><strong>Histogram</strong></p>
<p>A histogram samples observations (usually things like request durations or response sizes) and counts them in configurable buckets. It also provides a sum of all observed values.  For example, &quot;Query Duration&quot; has a range of time values (from 0 seconds and up).  These can be put into buckets to see what the 99th percentile Query Duration is (using the prometheus <code>histogram_quantile</code> function in the dashboard).</p>
</li>
</ul>
<p>If you wish to further group the data, you can use the Vector version of each of the above types.  For example, we can group a &quot;Request Duration Histogram&quot; by API endpoint, in order to see the distribution of request duration distributions for each endpoint separated from other endpoints.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<h3 id="instantiation-1"><a class="header" href="#instantiation-1">Instantiation</a></h3>
<p>To start collecting a statistic, you must first initialize its collector.  This can be accomplished during module initialization by assigning the collector to a module-global variable:</p>
<pre><code class="language-go">const (
    statsSubsystemConsul               = &quot;consul&quot;
    statsHistogramConsulCallTime       = &quot;call_time&quot;
    statsGaugeConsulCalls              = &quot;calls&quot;
    statsCounterConsulCallErrors       = &quot;call_errors&quot;
    statsGaugeConsulRegisteredServices = &quot;registrations&quot;
)

var (
    // Collect the number of errors for each api
    countVecConsulCallErrors = stats.NewCounterVec(
        statsSubsystemConsul, 
        statsCounterConsulCallErrors, 
        &quot;api&quot;, &quot;param&quot;)

    // Collect the number of active requests for each api
    gaugeVecConsulCalls      = stats.NewGaugeVec(
        statsSubsystemConsul, 
        statsGaugeConsulCalls, 
        &quot;api&quot;, &quot;param&quot;)

    // Collect the distribution of call execution times for each api
    histVecConsulCallTime    = stats.NewHistogramVec(
        statsSubsystemConsul, 
        statsHistogramConsulCallTime, 
        nil, 
        &quot;api&quot;, &quot;param&quot;)
)
</code></pre>
<p>As you can see above, each of the collector constructors start with two required arguments:</p>
<ul>
<li>
<p><strong>Subsystem</strong></p>
<p>Identifies the application subsystem being monitored.  In this case, <code>consul</code>.</p>
</li>
<li>
<p><strong>Metric Name</strong></p>
<p>Identifies the individual metric dimension.  By convention, duration histograms end with <code>_time</code>, and counters are pluralized.</p>
</li>
</ul>
<p>The histogram (and histogram vector) constructors require an argument specifying the buckets and their upper limits.  To use the default buckets, pass <code>nil</code> for this argument.  The current default buckets are calculated by executing <code>prometheus.ExponentialBuckets(10, 2, 16)</code>: this evaluates to <code>[10, 20, 40, ..., 655360]</code>.  For more information about histograms, you can visit the <a href="https://prometheus.io/docs/practices/histograms/">Prometheus documentation</a>.</p>
<p>Vector constructors, as shown above, accept a final series of dimensions to be applied to each of the measurements.  In the example above, each of our vectors accepts the <code>api</code> and <code>param</code> groupings.  In the consul stats collector:</p>
<ul>
<li><code>api</code> identifies which Consul API endpoint is being called (by path)</li>
<li><code>param</code> identifies eg. the servicename for discovery</li>
</ul>
<h3 id="collection"><a class="header" href="#collection">Collection</a></h3>
<p>After initializing your collectors, you can start to measure your application as the relevant events occur.</p>
<p>A common pattern is define a wrapper function whose only purpose is to collect statistics.  In the Consul package, we can see an example of this:</p>
<pre><code class="language-go">func observeConsulCall(api, param string, fn func() error) (err error) {
    // Collect the start time of the call
    start := time.Now()
    // Increase the number of active calls
    gaugeVecConsulCalls.WithLabelValues(api, param).Inc()

    // Execute this code before returning, even in case of panic()
    defer func() {
        // Reduce the number of active calls
        gaugeVecConsulCalls.WithLabelValues(api, param).Dec()
        
        // Bucket the call duration in the histogram
        histVecConsulCallTime.WithLabelValues(api, param).Observe(
            float64(time.Since(start)) / float64(time.Millisecond))

        if err != nil {
            // Increase the error count if an error was returned from fn
            countVecConsulCallErrors.WithLabelValues(api, param).Inc()
        }
    }()

    // Call the wrapped function and intercept it's error return value
    err = fn()
    
    // Return the wrapped function's value, after the defer block
    return err
}
</code></pre>
<p>There are a few things to note here not covered in the inline comments:</p>
<ol>
<li>We directly pass <code>api</code> and <code>param</code> group values to each of the vectors from the wrapper using <code>.WithLabelValues()</code>.  These must be passed in the same order as in the constructor.</li>
<li>Time periods should be calculated as <code>float64</code> milliseconds.</li>
<li>Counters and Gauges can be incremented by <code>1.0</code> using the <code>.Inc()</code> method.</li>
<li>Gauges can be decremented by <code>1.0</code> using the <code>.Dec()</code> method.</li>
<li>Histograms can record an observation using the <code>.Observe()</code> method.</li>
</ol>
<h2 id="push-gateway"><a class="header" href="#push-gateway">Push Gateway</a></h2>
<p>By default, the MSX Statistics package expects the statistics to be polled by an external application.  If such a poller is not available, MSX Statistics can be configured to push
to an external Prometheus push gateway.</p>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<p>The following configuration settings can be specified to configure the stats pusher:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>stats.push.enabled</code></td><td>enable the stats pusher</td><td><code>false</code></td></tr>
<tr><td><code>stats.push.url</code></td><td>url to push stats too</td><td></td></tr>
<tr><td><code>stats.push.job-name</code></td><td>prometheus job name to send</td><td><code>go_msx</code></td></tr>
<tr><td><code>stats.push.frequency</code></td><td>duration between pushes</td><td><code>15s</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="msx-distributed-tracing"><a class="header" href="#msx-distributed-tracing">MSX Distributed Tracing</a></h1>
<p>MSX Distributed Tracing allows the collection of an operational flow graph. Based
on <a href="https://opentracing.io/docs/overview/">OpenTracing</a>, tracing helps pinpoint where failures occur and what causes
poor performance.</p>
<h2 id="model-1"><a class="header" href="#model-1">Model</a></h2>
<ul>
<li>
<p><strong>Span</strong></p>
<p>A span is a named, timed operation representing a piece of the operational flow. Spans can have parents and children.</p>
</li>
<li>
<p><strong>Trace</strong></p>
<p>A trace is the complete tree of spans from an entire operational flow. A new trace (with a new root span) is created
by input from an external system, such as a REST API client. Traces extend across synchronous and asynchronous message
flows (interal RPC and events).</p>
</li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>The most common usage of tracing is to create a new child span within the current span, and execute an operation inside
it. To facilitate this, you can use the <code>trace.Operation()</code> function:</p>
<pre><code class="language-go">err := trace.Operation(ctx, &quot;myChildOperation&quot;, func(ctx context.Context) error {
myLogger.WithContext(ctx).Info(&quot;Inside myChildOperation...&quot;)
return nil
})
</code></pre>
<p>To create a new child span and attach data to it, you can use the <code>trace.NewSpan()</code> function:</p>
<pre><code class="language-go">// Create the new span
ctx, span := trace.NewSpan(ctx, spanName)
defer span.Finish()

// Tag the operation name
span.SetTag(trace.FieldOperation, operationName)

// Execute the operation and record the result
if err := myOperation(); err != nil {
span.LogFields(trace.Status(&quot;ERROR&quot;), trace.Error(err))
} else {
span.LogFields(trace.Status(&quot;OK&quot;))
}
</code></pre>
<p>Common trace log tags include:</p>
<ul>
<li><code>trace.FieldOperation</code>: Generic operation name</li>
<li><code>trace.FieldStatus</code>: Terminal status of the operation</li>
<li><code>trace.FieldHttpCode</code>: Response status code</li>
<li><code>trace.FieldHttpUrl</code>: Request url</li>
<li><code>trace.FieldHttpMethod</code>: Request method</li>
</ul>
<p>Other tags can be defined as needed using simple period-separated strings (e.g. <code>grpc.response.code</code>).</p>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<p>When writing a new driver for external input (such as a new RPC transport listener), you can retrieve the untraced
context:</p>
<pre><code class="language-go">ctx = trace.UntracedContextFromContext(ctx)
</code></pre>
<p>This context object should be passed to the input handlers, who will be responsible for starting a new (root) span:</p>
<pre><code class="language-go">err := trace.Operation(ctx, &quot;myInputReceiver&quot;, myInputHandler)
</code></pre>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>By default, MSX tracing will send trace data to a Jaeger listener at <code>udp://localhost:6831</code>.</p>
<p>The following configuration settings can be specified to override the default behaviour:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>trace.service-name</code></td><td>name of service to supply with the trace</td><td><code>${info.app.name}</code></td></tr>
<tr><td><code>trace.service-version</code></td><td>version of service to supply with the trace</td><td><code>${info.app.name}</code></td></tr>
<tr><td><code>trace.collector</code></td><td>which collector to use, <code>jaeger</code>,<code>datadog</code></td><td><code>jaeger</code></td></tr>
<tr><td><code>trace.reporter.enabled</code></td><td>report distributed tracing data</td><td><code>false</code></td></tr>
<tr><td><code>trace.reporter.host</code></td><td>jaeger/datadog host</td><td><code>localhost</code></td></tr>
<tr><td><code>trace.reporter.port</code></td><td>jaeger/datadog port</td><td><code>6831</code></td></tr>
<tr><td><code>trace.reporter.url</code></td><td>zipkin url</td><td><code>http://localhost:9411/api/v1/spans</code></td></tr>
</tbody></table>
</div>
<h3 id="datadog"><a class="header" href="#datadog">Datadog</a></h3>
<p>To configure for datadog, set the following values in consul:</p>
<pre><code class="language-yaml">trace.collector: datadog
trace.reporter.enabled: true
trace.reporter.port: 8126
</code></pre>
<p>and in the kubernetes manifest:</p>
<pre><code class="language-yaml">env:
- name: TRACE_REPORTER_HOST
  valueFrom:
    fieldRef:
      fieldPath: status.hostIP
</code></pre>
<p>That will send traces to the collector on the same host.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api-controller"><a class="header" href="#rest-api-controller">REST API Controller</a></h1>
<p>MSX promotes the usage of the common Controller &gt; Service &gt; Repository layered architecture within microservices.</p>
<p>The role of the Controller is to accept REST-based API requests from callers (UI, swagger, other microservices),
and route them to the service.</p>
<h2 id="defining-the-controller-structure"><a class="header" href="#defining-the-controller-structure">Defining the Controller structure</a></h2>
<p>To define a controller, create a standard Go structure with fields for its required dependencies:</p>
<pre><code class="language-go">type productController struct {
    productService   *productService
    productConverter *productConverter
}
</code></pre>
<p>This example shows two common dependencies:</p>
<ul>
<li>Service
<ul>
<li>The service is responsible for responding to the requests.  The controller acts as an HTTP gateway
to the service functionality.</li>
</ul>
</li>
<li>Converter
<ul>
<li>The converter transforms data transfer objects (requests and response) to and from domain models.</li>
</ul>
</li>
</ul>
<h2 id="implementing-the-restcontroller-interface"><a class="header" href="#implementing-the-restcontroller-interface">Implementing the RestController interface</a></h2>
<p>For registration with the web server, the <code>webservice.RestController</code> interface defines a single required method, <code>Routes</code>.
Add a standard implementation to your controller, for example:</p>
<pre><code class="language-go">func (c *productController) Routes(svc *restful.WebService) {
	tag := webservice.TagDefinition(&quot;Products&quot;, &quot;Products Controller&quot;)
	webservice.Routes(svc, tag,
		c.listProducts,
		c.getProduct,
		c.createProduct,
		c.updateProduct,
		c.deleteProduct)
}
</code></pre>
<p>This implementation demonstrates:</p>
<ul>
<li>Adding each endpoint implementation to the supplied WebService.</li>
<li>Tagging the routes for Swagger.  This allows the Swagger UI to show the human-readable controller name and group endpoints properly.
Note that the tag does not have to be unique, and can be declared at module level to be used across multiple controllers (eg v1, v2).
This will show all of the endpoints from the chosen controllers in a single group.</li>
</ul>
<h2 id="implementing-an-endpoint"><a class="header" href="#implementing-an-endpoint">Implementing an Endpoint</a></h2>
<p>Each endpoint on your controller should be declared inside its own method.  Here's an example implementation of a List endpoint
for the Products controller:</p>
<pre><code class="language-go">var viewPermissionFilter   = webservice.PermissionsFilter(rbac.PermissionViewProduct)

func (c *productController) listProducts(svc *restful.WebService) *restful.RouteBuilder {
    type params struct {
        Category *string `req:&quot;query&quot;`
    }

    return svc.GET(&quot;&quot;).
        Operation(&quot;listProducts&quot;).
        Doc(&quot;Retrieve the list of products, optionally filtering by the specified criteria.&quot;).
        Do(webservice.StandardList).
        Do(webservice.ResponsePayload(api.ProductListResponse{})).
        Do(webservice.PopulateParams(params{})).
        Filter(viewPermissionFilter).
        To(webservice.Controller(
            func(req *restful.Request) (body interface{}, err error) {
                params = webservice.Params(req).(*params)
        
                products, err := c.productService.ListProducts(req.Request.Context(), params.Category)
                if err != nil {
                    return nil, err
                }
        
                return c.productConverter.ToProductListResponse(products), nil
            }))
}
</code></pre>
<p>Here we are declaring the endpoint:</p>
<ul>
<li><code>type params ...</code>
<ul>
<li>accepts an optional string parameter <code>category</code> as a query parameter</li>
</ul>
</li>
<li><code>svc.GET</code>
<ul>
<li>will use the GET HTTP method</li>
</ul>
</li>
<li><code>GET(&quot;&quot;)</code>
<ul>
<li>has the same path as the controller</li>
</ul>
</li>
<li><code>Operation(&quot;listProducts&quot;)</code>
<ul>
<li>has the operation name <code>listProducts</code>.  This will appear in tracing, logs, and in the swagger definition.</li>
</ul>
</li>
<li><code>Doc(&quot;...&quot;)</code>
<ul>
<li>has the supplied description in the Swagger UI</li>
</ul>
</li>
<li><code>Do(webservice.StandardList)</code>
<ul>
<li>is an implementation of a List Collection endpoint.  Returns 200 by default.</li>
</ul>
</li>
<li><code>Do(webservice.PopulateParams(params{}))</code>
<ul>
<li>populates request parameters into the supplied structure</li>
</ul>
</li>
<li><code>Do(webservice.ResponsePayload(api.ProductListResponse{}))</code>
<ul>
<li>will return the specified response DTO, wrapped <em>inside</em> an MsxEnvelope object.</li>
</ul>
</li>
<li><code>Filter(viewPermissionFilter)</code>
<ul>
<li>will check that callers have the &quot;VIEW_PRODUCT&quot; permission, as defined in
the viewPermissionFilter object</li>
</ul>
</li>
<li><code>To(webservice.Controller(func ...))</code>
<ul>
<li>will execute the supplied function when this endpoint is called</li>
</ul>
</li>
</ul>
<p>These are some possible route building functions available in go-msx.  You may use the go-restful routing functions, along with the <a href="webservice/routes.go">go-msx routing functions</a> to define many aspects of your endpoint.</p>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<p>Controller parameter validation can be performed in two ways:</p>
<ol>
<li>
<p>Any member of the <code>params</code> struct passed into <code>webservice.PopulateParams</code> which implement the <code>validate.Validatable</code> interface
will be validated before being passed into the controller via a request attribute.</p>
<p>Create and Update request bodies will generally implement this interface.  For example:</p>
<pre><code class="language-go">type SubscriptionCreateRequest struct {
    OfferId   string `json:&quot;offerId&quot;`
    TenantId  string `json:&quot;tenantId&quot;`
    ServiceId string `json:&quot;serviceId&quot;`
}

func (s *SubscriptionCreateRequest) Validate() error {
    return types.ErrorMap{
        &quot;offerId&quot;: validation.Validate(&amp;s.OfferId, validation.Required, is.UUID),
        &quot;tenantId&quot;: validation.Validate(&amp;s.TenantId, validation.Required, is.UUID),
        &quot;serviceId&quot;: validation.Validate(&amp;s.ServiceId, validation.Required, is.UUID),
    }
}
</code></pre>
</li>
<li>
<p>A custom validation function may be provided using <code>.Do(requestValidatorFunc)</code>.  Extending the example above
which contains a <code>Category</code> parameter:</p>
<pre><code class="language-go">    ...
    Do(webservice.ValidateParams(func(req *restful.Request) (err error) {
        params, ok := webservice.Params(req).(*params)
        if !ok {
            return webservice.NewInternalError(errors.New(&quot;incorrect params type&quot;))
        }
        return types.ErrorMap{
            &quot;category&quot;: validation.Validate(&amp;params.Category, 
                                            validation.Required, 
                                            validation.In(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),
        }
    })).
</code></pre>
</li>
</ol>
<p>Any non-nil errors returned by the validation function will cause a <code>400 BAD REQUEST</code> response detailing
the validation errors.</p>
<p>Common validators are provided by the <a href="https://github.com/go-ozzo/ozzo-validation">github.com/go-ozzo/ozzo-validation</a> package.
A few custom validators are available in the <a href="webservice/../validate/README.html">validate</a> package.</p>
<h2 id="implementing-a-constructor"><a class="header" href="#implementing-a-constructor">Implementing a Constructor</a></h2>
<p>To allow instantiation of your controller, you can provide a constructor:</p>
<pre><code class="language-go">func newProductController(ctx context.Context) webservice.RestController {
	return &amp;productController{
        productService:   newProductService(ctx),
        productConverter: productConverter{},
	}
}
</code></pre>
<p>In this case, we expect the product service to be injectable, so we use its constructor function
to create an instance of the dependency. This simplifies unit testing by allowing us to inject
a mock for the service.</p>
<p>In contrast, we do not expect to use a mock converter, so it is instantiated directly.</p>
<h2 id="connecting-the-controller-to-the-application-lifecycle"><a class="header" href="#connecting-the-controller-to-the-application-lifecycle">Connecting the Controller to the Application Lifecycle</a></h2>
<p>In order to instantiate your controller during application startup, you can register a simple
<code>init</code> function:</p>
<pre><code class="language-go">func init() {
	app.OnEvent(app.EventCommand, app.CommandRoot, func(ctx context.Context) error {
		app.OnEvent(app.EventStart, app.PhaseBefore, func(ctx context.Context) error {
			controller := newProductController(ctx)
			return webservice.
				WebServerFromContext(ctx).
				RegisterRestController(pathRoot, controller)
		})
		return nil
	})
}
</code></pre>
<p>This will register your controller during normal microservice startup.  Since it
is only registering for <code>CommandRoot</code>, it will not be created during <code>migrate</code>, 
<code>populate</code> or other custom command execution.</p>
<p>To ensure your module is included in the built microservice, include the module from your <code>main.go</code>:</p>
<pre><code class="language-go">import _ &quot;cto-github.cisco.com/NFV-BU/productservice/internal/products&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql-database-repository"><a class="header" href="#sql-database-repository">SQL Database Repository</a></h1>
<p>MSX promotes the usage of the common Controller &gt; Service &gt; Repository layered architecture within microservices.</p>
<p>The role of the Repository is to query and mutate the persistent storage of Models.</p>
<h2 id="defining-the-repository"><a class="header" href="#defining-the-repository">Defining the Repository</a></h2>
<p>To define a repository, create a standard Go structure with an anonymous field for the CrudRepository:</p>
<pre><code class="language-go">type deviceSqlRepository struct {
    sqldb.CrudRepositoryApi
}
</code></pre>
<p>The <code>CrudRepositoryApi</code> object provides access to the SQL database underneath using generic objects 
and slices.</p>
<h2 id="writing-a-constructor"><a class="header" href="#writing-a-constructor">Writing a Constructor</a></h2>
<p>A standard repository constructor allows for dependency injection (during testing) and normal creation (during runtme):</p>
<pre><code class="language-go">func newDeviceRepository(ctx context.Context) deviceRepositoryApi {
	repo := deviceRepositoryFromContext(ctx)
	if repo == nil {
		repo = &amp;deviceSqlRepository{
			CrudRepositoryApi: sqldb.
				CrudRepositoryFactoryFromContext(ctx).
				NewCrudRepository(&quot;device&quot;),
		}
	}
	return repo
}
</code></pre>
<ul>
<li>The <code>CrudRepositoryFactory</code> allows us to test the repository without requiring an actual database implementation.</li>
<li>The <code>deviceRepositoryFromContext</code> allows us to test this repositories reverse-dependencies without requiring
an actual <code>deviceSqlRepository</code>.</li>
</ul>
<h2 id="implementing-common-access-methods"><a class="header" href="#implementing-common-access-methods">Implementing Common Access Methods</a></h2>
<p>A basic repository will likely have the following common methods:</p>
<ul>
<li><code>FindAll</code>
<ul>
<li>Retrieve all models</li>
</ul>
</li>
<li><code>FindByKey</code>
<ul>
<li>Retrieve a single model by its primary key</li>
</ul>
</li>
<li><code>Save</code>
<ul>
<li>Store a single model</li>
</ul>
</li>
<li><code>Delete</code>
<ul>
<li>Remove a single model</li>
</ul>
</li>
</ul>
<p>More advanced repositories may have some less-common methods:</p>
<ul>
<li><code>FindAllByIndexXXX</code>
<ul>
<li>Retrieve all models matching the specified criteria using an index</li>
</ul>
</li>
<li><code>FindAllPagedBy</code>
<ul>
<li>Retrieve a subset of models matching the specified criteria, using the specified sorting and pagination</li>
</ul>
</li>
<li><code>Truncate</code>
<ul>
<li>Remove all models</li>
</ul>
</li>
</ul>
<h3 id="findall"><a class="header" href="#findall">FindAll</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) FindAll(ctx context.Context) (results []device, err error) {
	logger.WithContext(ctx).Info(&quot;Retrieving all Device records&quot;)
	err = r.CrudRepositoryApi.FindAll(ctx, &amp;results)
	return
}
</code></pre>
<ol>
<li>Log method intention</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.</li>
</ol>
<h3 id="findbykey"><a class="header" href="#findbykey">FindByKey</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) FindByKey(ctx context.Context, name string) (result *device, err error) {
	logger.WithContext(ctx).Infof(&quot;Retrieving Device by key %q&quot;, name)
	var res device
	err = r.CrudRepositoryApi.FindOneBy(ctx, map[string]interface{}{
		&quot;name&quot;: name,
	}, &amp;res)
	if err == sqldb.ErrNotFound {
		err = repository.ErrNotFound
	} else if err == nil {
		result = &amp;res
	}
	return
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.FindOneBy</code> method accepts a map of criteria to search by -- 
in this case, the primary key.</li>
</ul>
</li>
<li>Normalize the <code>sqldb</code> error code to use <code>repository</code> error codes.</li>
</ol>
<h3 id="save"><a class="header" href="#save">Save</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) Save(ctx context.Context, device device) (err error) {
	logger.WithContext(ctx).Infof(&quot;Storing Device with key %q&quot;, device.Name)
	return r.CrudRepositoryApi.Save(ctx, device)
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record storage and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.Save</code> method performs an <code>UPSERT</code> query in Cockroach so it behaves
in much the same way as the <code>Save</code> method from a KV repository.</li>
</ul>
</li>
</ol>
<h3 id="delete"><a class="header" href="#delete">Delete</a></h3>
<pre><code class="language-go">func (r *deviceSqlRepository) Delete(ctx context.Context, name string) (err error) {
	logger.WithContext(ctx).Infof(&quot;Deleting Device by key %q&quot;, name)
	return r.CrudRepositoryApi.DeleteBy(ctx, map[string]interface{}{
		columnDeviceName: name,
	})
}
</code></pre>
<ol>
<li>Log method intention, including the primary key</li>
<li>Delegate to our internal CrudRepository to perform the record retrieval and struct mapping.
<ul>
<li>The <code>CrudRepositoryApi.DeleteBy</code> method accepts a map of criteria to delete by -- 
in this case, the primary key.</li>
</ul>
</li>
</ol>
<h3 id="transaction-support"><a class="header" href="#transaction-support">Transaction Support</a></h3>
<pre><code class="language-go">    err := sqldb.NewTransactionManager().
        WithTransaction(ctx, func(ctx context.Context) error {
            // do all your db processes in here (preferably prepared)

            // then return nil to commit or an error to rollback
            // return errors.New(&quot;some error&quot;) // to rollback
            return nil // to commit
        })
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openapi-client"><a class="header" href="#openapi-client">OpenApi Client</a></h1>
<p>MSX enables generating OpenApi clients with ease.</p>
<h2 id="client-generation"><a class="header" href="#client-generation">Client Generation</a></h2>
<p>The following snippets show an example of how to generate an OpenApi client
for Manage Microservice V8 APIs:</p>
<ul>
<li>
<p><code>cmd/build/build.yml</code>:</p>
<pre><code class="language-yaml"># Integration Generation
generate:
  - path: internal/integration/manage
    openapi:
      spec: ../.openapi/manage-service-8.yaml
      config: ../.openapi/manage-service-8-config.json
</code></pre>
</li>
<li>
<p><code>internal/integration/.openapi/manage-service-8.yaml</code>:
Place the openapi contract in this file.</p>
</li>
<li>
<p><code>internal/integration/.openapi/manage-service-8-config.json</code>:</p>
<pre><code class="language-json">{
  &quot;generateInterfaces&quot;: true,
  &quot;structPrefix&quot;: false,
  &quot;packageName&quot;: &quot;manage&quot;,
  &quot;enablePostProcessFile&quot;: true
}
</code></pre>
</li>
<li>
<p><code>internal/integration/manage/.openapi-generator-ignore</code></p>
<pre><code>.gitignore
go.mod
go.sum
.openapi-generator-ignore
.travis.yml
api/**
docs/**
git_push.sh
</code></pre>
</li>
</ul>
<p>After the above pieces are in place, you can execute the generate build step:</p>
<pre><code class="language-bash">make generate
</code></pre>
<h2 id="contract-validation"><a class="header" href="#contract-validation">Contract Validation</a></h2>
<p>To ensure the upstream contract remains compatible with your local version:</p>
<ol>
<li>
<p>Add the following snippet to <code>build.yml</code>:</p>
<pre><code class="language-yaml"># Contract Management
openapi:
  # Remote (consumer) API contract pairs
  contracts:
    - consumer: internal/integration/.openapi/manage-service-8.yaml
      producer: https://cto-github.cisco.com/raw/NFV-BU/msx-platform-specs/develop/manage-service-8.yaml

  # Sources for well-known schemas
  alias:
    - from: https://api.swaggerhub.com/domains/Cisco-Systems46/msx-common-domain/8
      to: https://cto-github.cisco.com/raw/NFV-BU/msx-platform-specs/sdk1.0.10/common-domain-8.yaml
</code></pre>
<p>Any internal GitHub links will use the GitHub Personal Access Token from your environment
(<code>GITHUB_TOKEN</code>) when retrieving the file.  Ensure you have an up-to-date PAT configured.</p>
</li>
<li>
<p>Add a check to your <code>build/ci/checks.yml</code>:</p>
<pre><code class="language-yaml">checks:
  - name: OpenApi
    commands:
      - make: openapi-compare
    analyzers:
      - builtin: generate-openapi-report
</code></pre>
<p>This will ensure each commit to your repo checks for backwards-incompatible changes to 
the contract.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-stream-operations"><a class="header" href="#msx-stream-operations">MSX Stream Operations</a></h1>
<p>A Streaming Operation library compatible with <a href="https://asyncapi.com">AsyncApi</a> 2.x documentation.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>Message
: A discrete unit of communication between a publisher and
a set of subscribers. Must include data (payload) and may
include metadata (headers).</p>
<p>Channel
: A source or destination for message delivery between
publishers and subscribers.</p>
<p>Subscriber
: A receiver of a sequence of messages from a channel.</p>
<p>Publisher
: A sender of a sequence of messages to a channel.</p>
<p>AsyncApi
: Documentation standard for describing event-based and streaming
message transports such as Kafka, Redis Streams, Amazon SQS.
Describes messages, channels, publishers, subscribers, servers,
security, and other related concerns.  Comparable to OpenApi, which
describes REST message transports.</p>
<p>DTO
: Data Transfer Object.  Used for serialization and deserialization of
externally sourced or directed structured values.</p>
<p>Port
: Description of the interface between the Stream Operations subsystem and
your message publisher or subscriber. Can include headers, filters, and
must include a payload DTO.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The following table compares the pattern of components across AsyncApi,
Stream Operations, and HTTP components.</p>
<div class="table-wrapper"><table><thead><tr><th>AsyncApi</th><th>Stream Publisher</th><th>Stream Subscriber</th><th>HTTP</th><th>Purpose</th></tr></thead><tbody>
<tr><td>Channel</td><td>Channel</td><td>Channel</td><td>Controller</td><td>Domain ingress and egress</td></tr>
<tr><td>Operation</td><td>ChannelPublisher</td><td>ChannelSubscriber</td><td>Router</td><td>Dispatch to endpoints</td></tr>
<tr><td>Message</td><td>MessagePublisher</td><td>MessageSubscriber</td><td>Endpoint</td><td>Event processing</td></tr>
<tr><td>Header, Payload</td><td>Output Port</td><td>Input Port</td><td>Request/Response</td><td>Exchanged data</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ports"><a class="header" href="#ports">Ports</a></h1>
<p><em>Ports</em> describe the various components of an incoming or outgoing message.<br />
An early incarnation of Ports is currently used to describe REST Controller 
Endpoint inputs, so hopefully they seem familiar.</p>
<h2 id="input-ports"><a class="header" href="#input-ports">Input Ports</a></h2>
<p>Input Ports specify fields to be extracted from an incoming stream message.
For example:</p>
<pre><code class="language-go">type driftCheckResponseInput struct {
    EventType string                 `in:&quot;header&quot; const:&quot;DriftCheck&quot;`
    Payload   api.DriftCheckResponse `in:&quot;body&quot;`
}
</code></pre>
<p>In Java these would be implemented using a hypothetical function signature:</p>
<pre><code class="language-java">void OnReceiveDriftCheckResponse(
  @Header(name=&quot;eventType&quot;) @Schema(constant=&quot;DriftCheck&quot;) String eventType, 
  @Body DriftCheckResponse body
)
</code></pre>
<h3 id="struct-tags"><a class="header" href="#struct-tags">Struct Tags</a></h3>
<p>Each field with an <code>in</code> struct tag will be automatically populated before being
passed to your Message Subscriber.  The full syntax of the <code>in</code> struct tag is as
follows:</p>
<pre><code>in:&quot;&lt;fieldGroup&gt;[=&lt;peerName&gt;]&quot;
</code></pre>
<p>The <code>in</code> struct tag contains the following subcomponents:</p>
<p><code>&lt;fieldGroup&gt;</code>
: (Required) The name of the message part from which the value will be extracted.
Valid field groups for streaming operations are:</p>
<ul>
<li><code>header</code> - Message metadata/headers (string-keyed map of strings).</li>
<li><code>body</code> - Message payload (JSON request body).  Max one per port struct.</li>
<li><code>messageId</code> - Unique id of the message (typically a random uuid)</li>
</ul>
<p><code>[=&lt;peerName&gt;]</code>
: (Optional)
A <em>peer</em> is the index within the field group of the data for each port field in the original message.
Currently, only <code>header</code> fieldGroup has indexed content (individual header values).
When not specified, the default peer in the metadata is the lowerCamelCase inflection of the field name: 
eg the <code>EventType</code> struct field points to the header <code>eventType</code>. </p>
<h2 id="output-ports"><a class="header" href="#output-ports">Output Ports</a></h2>
<p>Output ports specify parts of the published message to be populated from the
port struct.  For example:</p>
<pre><code class="language-go">type driftCheckRequestOutput struct {
    EventType string                `out:&quot;header&quot; const:&quot;DriftCheck&quot;`
    Payload   api.DriftCheckRequest `out:&quot;body&quot;`
}
</code></pre>
<p>In Java this would be implemented using a hypothetical function signature:</p>
<pre><code class="language-java">void PublishDriftCheckRequest(
  @Header(name=&quot;eventType&quot;) @Schema(constant=&quot;DriftCheck&quot;) String eventType, 
  @Body DriftCheckRequest body
)
</code></pre>
<h3 id="struct-tags-1"><a class="header" href="#struct-tags-1">Struct Tags</a></h3>
<p>Each field with an <code>out</code> struct tag will be automatically applied to the message
before the message is published.  The full syntax of the <code>out</code> struct tag is as
follows:</p>
<pre><code>out:&quot;&lt;fieldGroup&gt;[=peerName]&quot;
</code></pre>
<p>The subcomponents of the <code>out</code> struct tag are the same as <code>in</code> struct tag, above.</p>
<h2 id="data-transfer-objects-dtos"><a class="header" href="#data-transfer-objects-dtos">Data Transfer Objects (DTOs)</a></h2>
<p>Fields in a port specifying the <code>body</code> component will typically have a DTO struct
as their underlying type (eg. <code>api.DriftCheckRequest</code> above).</p>
<p>By default, these are serialized using
the Content-Type of the stream (currently defaults to <code>application/json</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation-1"><a class="header" href="#validation-1">Validation</a></h1>
<p>Stream operations use struct tags to declare JSON Schema
constraints for fields within the port and data transfer objects.</p>
<pre><code class="language-go">type driftCheckResponseInput struct {
    EventType string                 `in:&quot;header&quot; const:&quot;DriftCheck&quot;`
    Payload   api.DriftCheckResponse `in:&quot;body&quot;`
}
</code></pre>
<p>For example, in the <code>driftCheckRequestInput</code> port, the <code>EventType</code> field
specifies it must contain the constant value <code>DriftCheck</code> through the <code>const</code> tag.</p>
<p>When generating AsyncApi documentation, validation constraints specified in the port
struct or the data transfer object will automatically be included in the documentation.</p>
<h2 id="json-schema-struct-tags"><a class="header" href="#json-schema-struct-tags">JSON Schema Struct Tags</a></h2>
<p><a href="https://json-schema.org/">JSON Schema</a> is a domain-specific language used to describe constraints on values
that may be expressed using the JSON type system (null, object, array, number, string).</p>
<p>The following struct tags may be used to specify JSON Schema constraints and validators
within a port struct or a data transfer object:</p>
<ul>
<li>
<p><code>optional</code>, <code>required</code></p>
<p>Boolean entries to override the base field type optionality.  By default, pointer/slice/map and <code>types.Optional</code>
types are optional, and other types are non-optional.  Must be &quot;true&quot; or &quot;false&quot;.</p>
<pre><code class="language-go">type inPort struct {
    Expiry     types.Duration  `in=&quot;header&quot; optional=&quot;true&quot;`
    BestBefore *types.Duration `in=&quot;header&quot; required=&quot;true&quot;`
}
</code></pre>
</li>
<li>
<p><code>deprecated</code></p>
<p>Boolean to indicate the field should not be used and will be removed. Must be &quot;true&quot; or &quot;false&quot;.</p>
<pre><code class="language-go">type inPort struct {
    VmsTenant types.UUID `in=&quot;header&quot; deprecated=&quot;true&quot;`  
}
</code></pre>
</li>
<li>
<p><code>title</code>, <code>description</code></p>
<p>Expository language to help users understand the purpose of the field.</p>
<pre><code class="language-go">type outPort struct {
    ContentType string `in=&quot;header&quot; title=&quot;Content Type&quot; description=&quot;MIME type for the message body&quot; example=&quot;application/xml&quot;`
}
</code></pre>
</li>
<li>
<p><code>const</code></p>
<p>Value that the field must contain to be valid.  Equivalent to a single-valued <code>enum</code>.
Must be a scalar convertible to a valid value of the field data type.
See &quot;Port Field Constraint Handling&quot;, below for more details.</p>
<pre><code class="language-go">type MyRequest struct {
    Answer int `in=&quot;header&quot; const=&quot;42&quot;`  
}
</code></pre>
</li>
<li>
<p><code>default</code></p>
<p>Default value that the field will <em>behave as having</em> if not explicitly specified.
Must be a scalar convertible to a valid value of the field data type.
See &quot;Port Field Constraint Handling&quot;, below for more details.</p>
<pre><code class="language-go">type MyRequest struct {
    Pi float64 `in=&quot;header&quot; default=&quot;3.14&quot;`  
}
</code></pre>
</li>
<li>
<p><code>example</code></p>
<p>Example value to be presented in the schema document.
Must be a scalar convertible to a valid value of the field data type.</p>
<pre><code class="language-go">type MyRequest struct {
    Hour int   `in=&quot;header&quot; example=&quot;12&quot;`
    Minute int `in=&quot;header&quot; example=&quot;30&quot;`  
}
</code></pre>
</li>
<li>
<p><code>enum</code></p>
<p>Comma-separated list of possible values for the field.
Only these values will be accepted by the field during validation.
Must be scalars convertible to the field data type.</p>
<pre><code class="language-go">type MyResponseOutput struct {
    Code int `out=&quot;code&quot; enum=&quot;200,400,401,403,404&quot;` 
}
</code></pre>
</li>
<li>
<p><code>minimum</code>, <code>maximum</code></p>
<p>Range constraints for possible values of the field.
Only values &gt;= minimum (if specified) are valid.
Only values &lt;= maximum (if specified) are valid.
Must be scalars convertible to the field data type.</p>
<pre><code class="language-go">type MyResponseOutput struct {
    Radians float64 `out=&quot;header&quot; minimum=&quot;0&quot; maximum=&quot;6.28&quot;` 
}
</code></pre>
</li>
<li>
<p><code>minLength</code>, <code>maxLength</code></p>
<p>Length constraints for value of the field.  Applies
to <code>string</code> fields.  Must be integers if specified.</p>
<pre><code class="language-go">type MyResponse struct {
     ServiceType string `in=&quot;header&quot; minLength=&quot;4&quot; maxLength=&quot;16&quot;`
}
</code></pre>
</li>
<li>
<p><code>maxProperties</code>, <code>minProperties</code></p>
<p>Length constraints for value of the field.  Applies
to <code>object</code> fields.  Must be integers if specified.</p>
<pre><code class="language-go">type MyResponse struct {
     ServiceType map[string]string `in=&quot;header&quot; minProperties=&quot;1&quot;`
}
</code></pre>
</li>
<li>
<p><code>pattern</code></p>
<p>Regular expression that values must match to be valid.  Applies
to <code>string</code> fields.</p>
<pre><code class="language-go">type MyResponse struct {
     DeviceId string `in=&quot;header&quot; pattern=&quot;^CPE-.*$&quot;`
}
</code></pre>
</li>
<li>
<p><code>format</code></p>
<p>String identifier of pre-defined formats.  Applies
to <code>string</code> fields.  Normally will be automatic based on
the underlying field type.</p>
<pre><code class="language-go">type MyResponse struct {
     When types.Time `in=&quot;header&quot; format=&quot;date&quot;`
}
</code></pre>
</li>
<li>
<p><code>minItems</code>, <code>maxItems</code></p>
<p>Length constraints for value of the field. Applies
to <code>array</code> fields (slices).  Must be integers if specified.</p>
<pre><code class="language-go">type MyRequest struct {
     DeviceIds []types.UUID `in=&quot;body&quot; minItems=&quot;1&quot;`
     TenantIds []types.UUID `in=&quot;body&quot; maxItems=&quot;1&quot;`
}
</code></pre>
</li>
</ul>
<p>The underlying jsonschema-go library provides a few more constraints,
which you can view at the package <a href="https://pkg.go.dev/github.com/swaggest/jsonschema-go#readme-field-tags">GoDoc</a></p>
<h3 id="constraints-on-named-types"><a class="header" href="#constraints-on-named-types">Constraints on Named Types</a></h3>
<p>Fields in Port structures and DTOs with simple and anonymous types may be augmented using the JSON schema
tags above.  However, named types are shared across many fields and therefore cannot be augmented in-place.
For example:</p>
<pre><code class="language-go">type DriftCheckRequest struct {
  Action                string          `json:&quot;action&quot; const:&quot;checkDrift&quot;`
  GroupId               types.UUID      `json:&quot;groupId,omitempty&quot;`
  Timestamp             types.Time      `json:&quot;timestamp&quot; minimum:&quot;2022-01-01T00:00:00Z&quot;`
  EntityLevelCompliance string          `json:&quot;entityLevelCompliance&quot; enum:&quot;full,partial&quot;`
  Standards             []ConfigPayload `json:&quot;standards,omitempty&quot; minItems:&quot;1&quot; required:&quot;true&quot;`
  ...
}
</code></pre>
<p>Fields with Named Types include:</p>
<ul>
<li><code>GroupId</code> : <code>types.UUID</code></li>
<li><code>Timestamp</code> : <code>types.Time</code></li>
</ul>
<p>These fields will ignore any schema constraints declared in the struct tag,
such as the <code>minimum</code> tag on <code>Timestamp</code>.</p>
<p>Fields with Simple or Anonymous Types include:</p>
<ul>
<li><code>Action</code> : <code>string</code></li>
<li><code>EntityLevelCompliance</code> : <code>string</code></li>
<li><code>Standards</code>: <code>[]ConfigPayload</code></li>
</ul>
<p>Each of these fields has schema constraints declared which will be honoured.
<code>Standards</code> is an array of DTOs <code>[]ConfigPayload</code> and therefore is of an anonymous
type.</p>
<h3 id="constraints-on-dto-structs"><a class="header" href="#constraints-on-dto-structs">Constraints on DTO structs</a></h3>
<p>To configure a parent DTO struct using struct tags, include an anonymous 
field <code>_</code> with the desired constraints.  For example:</p>
<pre><code class="language-go">type RemediateRequest struct {
	...
    _ struct{} `additionalProperties:&quot;false&quot; description:&quot;RemediateRequest contains a remediation request.&quot;`
}
</code></pre>
<p>This will add <code>description</code> and <code>additionalProperties</code> schema constraints
to the <code>RemediateRequest</code> struct in the schema.</p>
<h3 id="custom-schema-generation-for-named-types"><a class="header" href="#custom-schema-generation-for-named-types">Custom Schema Generation for Named Types</a></h3>
<p>The underlying jsonschema-go library provides a number of interfaces to customize
or replace the JSON schema generated for your Named Type:</p>
<ul>
<li><code>NamedEnum</code> - Provides a list of name/value pairs for your enumerable type.</li>
<li><code>Enum</code> - Provides a list of values for your enumerable type.</li>
<li><code>Preparer</code> - Intercepts the reflected JSON Schema and allows alteration.</li>
<li><code>Exposer</code> - Provides a complete parsed JSON Schema for your type.</li>
<li><code>RawExposer</code> - Provides a complete unparsed JSON Schema for your type.</li>
<li><code>OneOfExposer</code> - Provides a list of <code>oneOf</code> elements for your type.</li>
<li><code>AnyOfExposer</code> - Provides a list of <code>anyOf</code> elements for your type.</li>
<li><code>AllOfExposer</code> - Provides a list of <code>allOf</code> elements for your type.</li>
<li><code>NotExposer</code> - Provides a <code>not</code> element for your type.</li>
<li><code>IfExposer</code> - Provides an <code>if</code> element for your type.</li>
<li><code>ThenExposer</code> - Provides a <code>then</code> element for your type.</li>
<li><code>ElseExposer</code> - Provides an <code>else</code> element for your type.</li>
</ul>
<p>You can find more details about these interfaces on the package
<a href="https://pkg.go.dev/github.com/swaggest/jsonschema-go#readme-implementing-interfaces-on-a-type">GoDoc</a>.</p>
<h3 id="port-field-constraint-handling"><a class="header" href="#port-field-constraint-handling">Port Field Constraint Handling</a></h3>
<p>To ease development burden, when using <code>const</code> or <code>default</code> on a Port Field, the value will be applied
during input population (subscriber) or output population (publisher).  Note that this only applies to
scalars (e.g. headers), and only those directly contained in the Port structure.  In particular, it does
not apply to the request/response body or its sub-fields.</p>
<p>From the example at the beginning of the chapter:</p>
<pre><code class="language-go">type driftCheckRequestOutput struct {
    EventType string            `out:&quot;header&quot; const:&quot;DriftCheck&quot;`
    Payload   DriftCheckRequest `out:&quot;body&quot;`
}

type DriftCheckRequest struct {
    Action string `json:&quot;action&quot; const:&quot;checkDrift&quot;`
    ...
}
</code></pre>
<p>The <code>EventType</code> field of <code>driftCheckRequestOutput</code> will be filled with <code>DriftCheck</code> if not supplied
by the publisher, since it is a scalar, and directly contained within the Port structure.  If another
value is supplied, the schema validation will fail, so it is best to simply not supply the value.</p>
<p>The <code>Action</code> field of <code>DriftCheckRequest</code> will <em>not</em> be filled with <code>checkDrift</code> since it is not
directly contained within the Port structure.  It will be validated during schema validation to ensure
only that value is supplied.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishers"><a class="header" href="#publishers">Publishers</a></h1>
<p>Stream Operations Publishers are used to publish messages on streams. 
They consist of a number of components:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>AsyncApi Documentor</th><th>Documentation Model</th></tr></thead><tbody>
<tr><td>Your Message Publisher (service)</td><td>-</td><td>-</td></tr>
<tr><td>Your Output Port (struct)</td><td>asyncapi.MessagePublisherDocumentor</td><td>jsonschema.Schema</td></tr>
<tr><td>Your Payload DTO (struct)</td><td>asyncapi.MessagePublisherDocumentor</td><td>jsonschema.Schema</td></tr>
<tr><td>streamops.MessagePublisher</td><td>asyncapi.MessagePublisherDocumentor</td><td>asyncapi.Message</td></tr>
<tr><td>streamops.ChannelPublisher</td><td>asyncapi.ChannelPublisherDocumentor</td><td>asyncapi.Operation</td></tr>
<tr><td>streamops.Channel</td><td>asyncapi.ChannelDocumentor</td><td>asyncapi.Channel</td></tr>
</tbody></table>
</div>
<h2 id="components-1"><a class="header" href="#components-1">Components</a></h2>
<p><strong>Channel</strong></p>
<p>The channel component represents the stream itself (SQS or Kafka topic, Redis stream, Go channel, SQLDB table, etc).
It is implemented as a singleton that should be created after configuration but before start-up.</p>
<p><strong>Channel Publisher</strong></p>
<p>The channel publisher component represents the set of publishable messages for a given stream.
It is implemented as a service that should be created as a dependency of your message publisher.</p>
<p><strong>Message Publisher</strong></p>
<p>The message publisher component represents one of the publishable messages for a given stream.
It is implemented as a service created after configuration but before start-up.<br />
Notice that it has a defined API interface for mocking, and should be mocked by dependent services
during testing.</p>
<p><strong>Output Port</strong></p>
<p>The message port contains a mapping of fields to be set on the outgoing message.
Each field will be mapped to a header or body field based on the struct tags.</p>
<p><strong>Message Payload DTO</strong></p>
<p>The payload DTO will contain the body of message that is to be published.
Before dispatch to the underlying stream, the message will be validated using
the JSON-schema annotations on your DTO.</p>
<h2 id="generation"><a class="header" href="#generation">Generation</a></h2>
<p>It is strongly advised to auto-generate these components and customize them afterwards.
See <a href="ops/streamops/../../skel/asyncapi/channels.html">Channels</a> and <a href="ops/streamops/../../skel/asyncapi/spec.html">AsyncApi</a>
for details about generation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subscribers"><a class="header" href="#subscribers">Subscribers</a></h1>
<p>Stream Operations Subscribers are used to publish messages on streams.
They consist of a number of components:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>AsyncApi Documentor</th><th>Documentation Model</th></tr></thead><tbody>
<tr><td>Your Message Subscriber (service)</td><td>-</td><td>-</td></tr>
<tr><td>Your Input Port (struct)</td><td>asyncapi.MessageSubscriberDocumentor</td><td>jsonschema.Schema</td></tr>
<tr><td>Your Payload DTO (struct)</td><td>asyncapi.MessageSubscriberDocumentor</td><td>jsonschema.Schema</td></tr>
<tr><td>streamops.MessageSubscriber</td><td>asyncapi.MessageSubscriberDocumentor</td><td>asyncapi.Message</td></tr>
<tr><td>streamops.ChannelSubscriber</td><td>asyncapi.ChannelSubscriberDocumentor</td><td>asyncapi.Operation</td></tr>
<tr><td>streamops.Channel</td><td>asyncapi.ChannelDocumentor</td><td>asyncapi.Channel</td></tr>
</tbody></table>
</div>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<p><strong>Channel</strong></p>
<p>The channel component represents the stream itself (SQS or Kafka topic, Redis stream, Go channel, SQLDB table, etc).
It is implemented as a singleton that should be created after configuration but before start-up.</p>
<p><strong>Channel Subscriber</strong></p>
<p>The channel subscriber component represents the set of subscribable messages for a given stream.
It is implemented as a service, and should have one of your application services as a dependency.</p>
<p><strong>Message Subscriber</strong></p>
<p>The message subscriber component represents one of the publishable messages for a given stream.
It is implemented as a service created after configuration but before start-up.<br />
Notice that it has a defined API interface for mocking, and should be mocked by dependent services
during testing.</p>
<p><strong>Input Port</strong></p>
<p>The message port contains a mapping of fields to be set from the incoming message.
Each field will be mapped from a header or body field based on the struct tags.</p>
<p><strong>Payload DTO</strong></p>
<p>The payload DTO will contain the parsed message that is subscribed.
Before dispatch to your subscriber, the message will be validated using
the JSON-schema annotations and any <code>Validatable</code> interface implementation
on your DTO.</p>
<h2 id="generation-1"><a class="header" href="#generation-1">Generation</a></h2>
<p>It is strongly advised to auto-generate these components and customize them afterwards.
See <a href="ops/streamops/../../skel/asyncapi/channels.html">Channels</a> and <a href="ops/streamops/../../skel/asyncapi/spec.html">AsyncApi</a>
for details about generation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncapi-schema"><a class="header" href="#asyncapi-schema">AsyncApi Schema</a></h1>
<p><a href="https://asyncapi.com">AsyncApi</a> Schema contains support infrastructure for
generating and consuming AsyncApi specifications directly from go code.</p>
<p>Microservice developers will typically interact with a small subset of AsyncApi 
models.</p>
<h2 id="documentation-generators"><a class="header" href="#documentation-generators">Documentation Generators</a></h2>
<p>Documentation Generators convert an active object from the <code>streamops</code> package
to a documentation element from this package.</p>
<ul>
<li><code>ChannelDocumentor</code>
<ul>
<li>Generates <code>ChannelItem</code> documentation from a <code>streamops.Channel</code></li>
</ul>
</li>
<li><code>ChannelPublisherDocumentor</code>
<ul>
<li>Generates <code>Operation</code> documentation from a <code>streamops.ChannelPublisher</code></li>
</ul>
</li>
<li><code>ChannelSubscriberDocumentor</code>
<ul>
<li>Generates <code>Operation</code> documentation from a <code>streamops.ChannelSubscriber</code> </li>
</ul>
</li>
<li><code>MessagePublisherDocumentor</code>
<ul>
<li>Generates <code>Message</code> documentation from a <code>streamops.MessagePublisher</code></li>
</ul>
</li>
</ul>
<p>Documentation Generators have the following user-modifiable properties:</p>
<ul>
<li><code>Skip</code>:
Set to true if you which to skip generating documentation for this node.</li>
<li><code>ChannelItem</code>/<code>Operation</code>/<code>Message</code>:
Specify a documentation element instance to use as the basis for generating
documentation for this node.  This is typically where you provide explanatory
fields such as title, description, etc.</li>
<li><code>Mutator</code>:
Specify a function to enable customization of the generated documentation
after the Documentor has processed this node.</li>
</ul>
<h2 id="documentation-elements"><a class="header" href="#documentation-elements">Documentation Elements</a></h2>
<p>Documentation Elements are generated by documentors and are inserted into the
AsyncApi specification document being generated.</p>
<ul>
<li><a href="https://www.asyncapi.com/docs/reference/specification/v2.4.0#channelItemObject"><code>Channel</code></a>
<ul>
<li>Documents sequence of sent and received messages from a single location.</li>
</ul>
</li>
<li><a href="https://www.asyncapi.com/docs/reference/specification/v2.4.0#messageObject"><code>Message</code></a>
<ul>
<li>Documents a single unit of communication sent to or received from a channel.</li>
</ul>
</li>
<li><a href="https://www.asyncapi.com/docs/reference/specification/v2.4.0#operationObject"><code>Operation</code></a>
<ul>
<li>Documents a single channel operation (publish or subscriber) for a single channel.</li>
</ul>
</li>
<li><a href="https://www.asyncapi.com/docs/reference/specification/v2.4.0#schemaObject"><code>Schema</code></a>
<ul>
<li>Documents the format of a message payload or headers.</li>
<li>In go-msx, this schema must be in <a href="https://json-schema.org/draft/2020-12/json-schema-validation.html">JSON Schema</a> format.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-lru-cache"><a class="header" href="#msx-lru-cache">MSX LRU Cache</a></h1>
<p>An LRU cache implementation which expires key/value pairs based on a TTL duration.
Inspired by <a href="https://github.com/karlseguin/rcache">rcache</a>.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<h3 id="instantiation-2"><a class="header" href="#instantiation-2">Instantiation</a></h3>
<p>To create a new cache with 120 second retention, which expires up to 100 keys every 15 seconds:</p>
<pre><code class="language-go">myCache := lru.NewCache(120 * time.Second, 100, 15 * time.Second)
</code></pre>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>To store a key/value pair:</p>
<pre><code class="language-go">myCache.Set(&quot;somekey&quot;, &quot;myvalue&quot;)
</code></pre>
<h3 id="retrieval"><a class="header" href="#retrieval">Retrieval</a></h3>
<p>To retrieve a key/value pair:</p>
<pre><code class="language-go">value, exists := myCache.get(&quot;somekey&quot;)
if !exists { 
  // fill cache for &quot;somekey&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-certificate"><a class="header" href="#msx-certificate">MSX Certificate</a></h1>
<p>The certificate module provides access to static and dynamic TLS/x509
certificate sources, including the following providers:</p>
<ul>
<li>File - load certs and keys from the filesystem</li>
<li>Vault - generate and renew certs and keys from Vault</li>
<li>Cache - save upstream certs and keys to disk</li>
</ul>
<p>The certificate module also provides a common configuration parser for
TLS configuration.</p>
<h2 id="sources"><a class="header" href="#sources">Sources</a></h2>
<p>A source identifies the provider and provider parameters required to obtain identity and authority certificates.</p>
<p>Each source is defined in the configuration using a unique name (lowercase alphanumeric only).
Source properties are configured under <code>certificate.source.&lt;sourcename&gt;</code>, for example:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
      provider: ...
      property1: ...
      property2: ...
      property3: ...
</code></pre>
<h2 id="providers"><a class="header" href="#providers">Providers</a></h2>
<p>Each source specifies a provider and its parameters.
Individual providers are detailed in the following sections.</p>
<h3 id="file"><a class="header" href="#file">File</a></h3>
<p>To specify the local filesystem as the source for certificates, use the File provider:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
    provider: file
    ca-cert-file: /etc/pki/tls/certs/ca-identity.crt
    cert-file: /etc/pki/tls/certs/spokeservice.pem
    key-file: /etc/pki/tls/private/spokeservice-key.pem
</code></pre>
<p>When a subsystem requests certificates from the <code>identity</code> source, it will:</p>
<ul>
<li>Load certificates from the filesystem for each TLS connection</li>
</ul>
<p>While <em>active</em> renewal is not supported, the file provider does read in changes
to the file for each connection.  The cert/key files may be rotated as convenient.</p>
<h4 id="configuration-properties"><a class="header" href="#configuration-properties">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ca-cert-file</code></td><td>-</td><td>Required</td><td>CA Certificate File, PEM format</td></tr>
<tr><td><code>cert-file</code></td><td>-</td><td>Required</td><td>Identity Certificate File, PEM format</td></tr>
<tr><td><code>key-file</code></td><td>-</td><td>Required</td><td>Identity Private Key File, PEM format</td></tr>
</tbody></table>
</div>
<h3 id="vault"><a class="header" href="#vault">Vault</a></h3>
<p>To specify Vault as the source for certificates, use the Vault provider:</p>
<pre><code class="language-yaml">certificate.source:
  identity:
    provider: vault
    path: pki/vms
    role: &quot;${spring.application.name}&quot;
    cn: &quot;${spring.application.name}&quot;
    alt-names:
      - &quot;${network.hostname}&quot;
      - &quot;${spring.application.name}.svc.kubernetes.cluster.local&quot;
      - &quot;${spring.application.name}.service.consul&quot;
    ip-sans:
      - &quot;${network.outbound.address}&quot;
</code></pre>
<p>When a subsystem requests certificates from the <code>identity</code> source, it will:</p>
<ul>
<li>Generate an identity certificate and private key</li>
<li>Renew the identity certificate half-way through its lifetime.</li>
</ul>
<h4 id="configuration-properties-1"><a class="header" href="#configuration-properties-1">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>path</code></td><td>-</td><td>Required</td><td>Vault PKI mount point</td></tr>
<tr><td><code>role</code></td><td>-</td><td>Required</td><td>Vault PKI issuer role name</td></tr>
<tr><td><code>cn</code></td><td>-</td><td>Required</td><td>Desired identity certificate CN</td></tr>
<tr><td><code>alt-names</code></td><td>-</td><td>Optional</td><td>Desired identity certificate subject alternative names</td></tr>
<tr><td><code>ip-sans</code></td><td>-</td><td>Optional</td><td>Desired identity certificate IP subject alternative names</td></tr>
</tbody></table>
</div>
<p>Note: <code>alt-names</code> and <code>ip-sans</code> will be stripped of empty entries so may include
undefined variables with empty defaults:</p>
<pre><code>- ${some.undefined.variable:}
</code></pre>
<h3 id="cache"><a class="header" href="#cache">Cache</a></h3>
<p>To configure a cache for a remote certificate source, use the Cache provider:</p>
<pre><code class="language-yaml">certificate.source:

  identity:
    provider: vault
    path: pki/vms
    role: &quot;${spring.application.name}&quot;
    cn: &quot;${spring.application.name}&quot;
    alt-names:
      - &quot;${remote.service.hostname}&quot;
    ip-sans:
      - &quot;${kubernetes.pod.ip}&quot;
      - &quot;${remote.service.ip}&quot;
      
  identitycache:
    provider: cache
    upstream-source: identity
    key-file: &quot;/certs/${spring.application.name}-key.pem&quot;
    cert-file: &quot;/certs/${spring.application.name}.pem&quot;
    ca-cert-file: &quot;/etc/ssl/certs/ca-identity.crt&quot;
</code></pre>
<p>When a subsystem requests certificates from the <code>identitycache</code> source, it will:</p>
<ul>
<li>Generate and store an identity certificate and private key under <code>/certs</code></li>
<li>Retrieve and store the authority certificate under <code>/etc/ssl/certs</code>.</li>
<li>Renew the identity certificate half-way through its lifetime.</li>
</ul>
<h4 id="configuration-properties-2"><a class="header" href="#configuration-properties-2">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ca-cert-file</code></td><td>-</td><td>Required</td><td>CA Certificate File, PEM format</td></tr>
<tr><td><code>cert-file</code></td><td>-</td><td>Required</td><td>Identity Certificate File, PEM format</td></tr>
<tr><td><code>key-file</code></td><td>-</td><td>Required</td><td>Identity Private Key File, PEM format</td></tr>
</tbody></table>
</div>
<h2 id="tls-configuration"><a class="header" href="#tls-configuration">TLS Configuration</a></h2>
<p>TLS connection configuration is used in many places in go-msx, including:</p>
<ul>
<li>Kafka client</li>
<li>Web server</li>
</ul>
<p>For ease of use, these configurations have been unified into a single format.</p>
<h4 id="configuration-properties-3"><a class="header" href="#configuration-properties-3">Configuration Properties</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td><code>false</code></td><td>Optional</td><td>TLS should be enabled for this client/server</td></tr>
<tr><td><code>insecure-skip-verify</code></td><td><code>false</code></td><td>Optional</td><td>Verify the server's certificate chain and host name</td></tr>
<tr><td><code>min-version</code></td><td><code>tls12</code></td><td>Optional</td><td>Minimum TLS version to support.  One of: tls10, tls11, tls12, tls13</td></tr>
<tr><td><code>certificate-source</code></td><td>-</td><td>Optional</td><td>Server or Client certificate source.  Required for server.</td></tr>
<tr><td><code>cipher-suites</code></td><td><sup>1</sup></td><td>Optional</td><td>Cipher suites to enable.</td></tr>
<tr><td><code>server-name</code></td><td>-</td><td>Optional</td><td>Server name to check in certificate when connecting from client.</td></tr>
</tbody></table>
</div>
<p><sup>1</sup> Current default cipher suites are:</p>
<ul>
<li>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305</li>
<li>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</li>
<li>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</li>
<li>TLS_RSA_WITH_AES_256_GCM_SHA384</li>
<li>TLS_RSA_WITH_AES_256_CBC_SHA</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-resource-module"><a class="header" href="#msx-resource-module">MSX Resource Module</a></h1>
<p>MSX Resource manages locating and accessing files from the source, staging, and runtime filesystems in a consistent fashion.</p>
<h2 id="filesystem"><a class="header" href="#filesystem">Filesystem</a></h2>
<p>To correctly use resources, it is first important to understand the resource filesystem, and how it is used to locate files during development and inside containers.</p>
<p>The resource filesystem contains one or more of the following layers, if found:</p>
<ul>
<li><strong>production</strong> - rooted in the Docker image at <code>/var/lib/${app.name}</code></li>
<li><strong>staging</strong> - rooted at <code>dist/root/var/lib/${app.name}</code> underneath the <strong>source</strong> root</li>
<li><strong>source</strong> - rooted at the folder containing the repository's <code>go.mod</code></li>
</ul>
<p>The resource filesystem will attempt to locate each of these folders and if found, will search it for your resource references.</p>
<h2 id="resource-references"><a class="header" href="#resource-references">Resource References</a></h2>
<p>The primary data type of the MSX resource module is the resource reference.  It represents the resource file subpath.  All resource paths use the forward-slash (<code>/</code>) as the path component separator. </p>
<p>Two types of paths can be used:</p>
<ul>
<li><strong>relative</strong> - No leading forward-slash (<code>data/my-resource.json</code>): File path is relative to the code file consuming the reference.</li>
<li><strong>absolute</strong> - Leading forward-slash (<code>/internal/migrate/resource.json</code>): File path is relative to the resource filesystem root.</li>
</ul>
<h3 id="obtaining-a-single-resource-reference"><a class="header" href="#obtaining-a-single-resource-reference">Obtaining a Single Resource Reference</a></h3>
<p>To work with a resource you must first create a reference to it using the <code>resource.Reference</code> function:</p>
<pre><code class="language-go">func processMyResource(ctx context.Context) error {
  myResourceRef := resource.Reference(&quot;data/my-resource.json&quot;)
}
</code></pre>
<p>This returns a <code>resource.Ref</code> object pointing to the specified path.</p>
<h3 id="obtaining-multiple-resource-references"><a class="header" href="#obtaining-multiple-resource-references">Obtaining Multiple Resource References</a></h3>
<p>To retrieve multiple resource references using a glob pattern you can call the <code>resource.References</code> function:</p>
<pre><code>func processMyResources(ctx context.Context) error {
  myResourceRefs := resource.References(&quot;data/*.json&quot;)
}
</code></pre>
<p>This returns a <code>[]resource.Ref</code> slice with an entry for each matching resource.</p>
<h2 id="consuming-resources"><a class="header" href="#consuming-resources">Consuming Resources</a></h2>
<p>Once you have obtained one or more resource references, you can access their contents using one of its methods.</p>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<p>To read in the contents of the resource as JSON and unmarshal it to an object, use the <code>Unmarshal()</code> method:</p>
<pre><code class="language-go">var myResourceContents MyResourceStruct
err := resource.Reference(&quot;data/my-resource.json&quot;).Unmarshal(&amp;myResourceContents)
</code></pre>
<h3 id="bytes"><a class="header" href="#bytes">Bytes</a></h3>
<p>To read in the contents of the resource as a  <code>[]byte</code>, use the <code>ReadAll()</code> method:</p>
<pre><code class="language-go">data, err := resource.Reference(&quot;data/my-resource.json&quot;).ReadAll()
</code></pre>
<h3 id="httpfile"><a class="header" href="#httpfile">http.File</a></h3>
<p>To open the file and return an <code>http.File</code>, use the <code>Open()</code> method:</p>
<pre><code class="language-go">file, err := resource.Reference(&quot;data/my-resource.json&quot;).Open()
</code></pre>
<p>Note that <code>http.File</code> also meets the requirements of the <code>io.ReadCloser</code> interface, and can therefore be used with <code>io</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retry"><a class="header" href="#retry">Retry</a></h1>
<p>Retry enables attempting an operation multiple times, stopping
on success (no error returned) or permanent operation failure.</p>
<h2 id="retrying"><a class="header" href="#retrying">Retrying</a></h2>
<p>To retry an action, create a new instance of <code>Retry</code> via <code>NewRetry</code> and
call its <code>Retry</code> method:</p>
<pre><code class="language-go">
tooEarly := time.Parse(&quot;2020-01-01T00:00:00Z&quot;)
tooLate := time.Parse(&quot;2020-12-31T23:59:59.999999999Z&quot;)

// Retry once an hour
r := NewRetry(ctx, RetryConfig{Attempts:10, Delay: 60 * 60 * 1000})

err := r.Retry(func() error {
  now := time.Now()
  if now.Before(tooEarly) {
    return retry.TransientError{
      Cause: errors.New(&quot;Will succeed in the future&quot;)
    } 		
  } else if now.After(tooLate) {
    return retry.PermanentError{
      Cause: errors.New(&quot;Will never succeed again&quot;)			
    }
  }
  return nil
})
</code></pre>
<p>The above retries its action once per hour, with up to 10 attempts.
If the time is before <code>tooEarly</code>, it will continue retrying, since it
returns a <code>TransientError</code>.  If the time is after <code>tooLate</code>, it will
stop retrying, since it returns <code>PermanentError</code>.  If the time is after <code>tooEarly</code>
but before <code>tooLate</code>, it will succeed and cease further attempts.</p>
<p>Retry distinguishes between Transient and Permanent errors by inspecting
the returned <code>error</code> instance.  If it implements the failure interface,
it can be queried for transience/permanence:</p>
<pre><code class="language-go">type failure interface {
	IsPermanent() bool
}
</code></pre>
<p>Permanent errors should return <code>true</code> from <code>IsPermanent()</code>, transient
errors should return <code>false</code>.  As above, this can be handled by wrapping
the error in either <code>PermanentError</code> or <code>TransientError</code>.</p>
<h2 id="configuration-loading-1"><a class="header" href="#configuration-loading-1">Configuration Loading</a></h2>
<p><code>RetryConfig</code> is designed to be loaded from configuration, making it possible
to configure from static, environmental, or remote configuration
sources in a consistent fashion.</p>
<pre><code class="language-go">const configRootMerakiClientRetry = &quot;meraki.client.retry&quot;
var retryConfig retry.Config
if err := config.FromContext(ctx).Populate(&amp;retryConfig, configRootMerakiClientRetry); err != nil {
	return err
}
</code></pre>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<ul>
<li>
<p>Retries without delays</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 2,
    Delay:    0,
    BackOff:  0.0,
    Linear:   true,
})
</code></pre>
</li>
<li>
<p>Retries with fixed delays (1 second)</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 2,
    Delay:    1000,
    BackOff:  1.0,
    Linear:   true,
})
</code></pre>
</li>
<li>
<p>Retries with linear delays (1, 2, 3, 4)</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay:    1000,
    BackOff:  1.0,
    Linear:   true,
})
</code></pre>
</li>
<li>
<p>Retries with exponential delays (1, 2, 4, 8)</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay: 1000,
    BackOff: 2.0,
    Linear: false,
})
</code></pre>
</li>
<li>
<p>Retries with linear delay and Jitter (low random) (1, 2.452, 3.571, 4.357) <br /></p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay:    1000,
    BackOff:  1.0,
    Linear:   true,
    Jitter:   1000,
})
</code></pre>
</li>
<li>
<p>Retries with linear delay and Jitter (extreme random) (1, 7.8, 20.3, 8.45) <br />
With higher Jitter value you could expect greater randomness.</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay:    1000,
    BackOff:  1.0,
    Linear:   true,
    Jitter:   20000,
})
</code></pre>
</li>
<li>
<p>Retries with exponential delay and Jitter (1, 2, 4, 8) (note: jitter is negligible so this is just like exponential backoff with no jitter)</p>
<pre><code class="language-go">r := NewRetry(ctx, RetryConfig{
    Attempts: 5,
    Delay: 1000,
    BackOff: 2.0,
    Linear: false,
    Jitter: 1,
})
</code></pre>
</li>
<li>
<p>Using retry with decorator</p>
<pre><code class="language-go">    types.
        NewOperation(func(ctx context.Context) error {
            return errors.New(&quot;a transient error&quot;)
        }).
        WithDecorator(Decorator(RetryConfig{
            Attempts: 1,
            Delay:    10,
            BackOff:  2.0,
            Linear:   false,
            Jitter:   1,
        })).
        Run(ctx)
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sanitize"><a class="header" href="#sanitize">Sanitize</a></h1>
<p>MSX Sanitize allows request data to be pre-processed (before validation) to ensure potentially dangerous content is
removed. For example XSS and arbitrary HTML can be removed from plain-text strings.  MSX Sanitize also auto-sanitizes
log messages.</p>
<h2 id="sanitizing-input"><a class="header" href="#sanitizing-input">Sanitizing Input</a></h2>
<p>To explicitly sanitize a tree of data, including maps, slices, structs in-place:</p>
<pre><code class="language-go">if err := sanitize.Input(&amp;mydata, sanitize.NewOptions(&quot;xss&quot;)); err != nil {
	return err
}
</code></pre>
<p>After returning, mydata will be sanitized based on the supplied Options.</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>Options are available for each of the sanitizers from</p>
<pre><code>github.com/kennygrant/sanitize
</code></pre>
<p>including:</p>
<ul>
<li>Accents (<code>accents</code>) </li>
<li>BaseName (<code>basename</code>)</li>
<li>Xss (<code>xss</code>) </li>
<li>Name (<code>name</code>)</li>
<li>Path (<code>path</code>)</li>
</ul>
<p>Custom sanitizers provided by MSX Sanitize include:</p>
<ul>
<li>Secret (<code>secret</code>)</li>
</ul>
<h3 id="struct-tags-2"><a class="header" href="#struct-tags-2">Struct Tags</a></h3>
<p>To specify these options on a struct field, use the <code>san:&quot;...&quot;</code> tag, for example:</p>
<pre><code class="language-go">type MyRequest struct {
	Name 		string `json:&quot;name&quot; san:&quot;xss&quot;`
	Description string `json:&quot;description&quot; san:&quot;xss&quot;`
	Ignored 	string `json:&quot;ignored&quot; san:&quot;-&quot;`
}
</code></pre>
<p>In this struct, <code>Name</code> and <code>Description</code> fields indicate they must be sanitized for XSS/HTML content (<code>xss</code>),
and <code>Ignored</code> should not be sanitized at all (<code>-</code>).</p>
<p>NOTE: If a struct field does not have the <code>san</code> tag, it will inherit from its ancestors, up to the options passed
into the <code>sanitize.Input</code> call.</p>
<h2 id="sanitizing-logs"><a class="header" href="#sanitizing-logs">Sanitizing Logs</a></h2>
<p>Logs are auto-sanitized using some base rules.  These can be augmented by the microservice using the 
<code>sanitize.secrets</code> configuration:</p>
<pre><code class="language-yaml">sanitize.secrets:
  keys:
    - status
  custom:
    enabled: true
    patterns:
        - from: &quot;\\[userviceconfiguration/\\w+\\]&quot;
          to: &quot;[userviceconfiguration/...]&quot;
        - from: &quot;\\[secret/\\w+\\]&quot;
          to: &quot;[secret/...]&quot;
</code></pre>
<p>Within <code>sanitize.secrets</code> you can configure the following options:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>true</td><td>Optional</td><td>Enable secret replacement</td></tr>
<tr><td><code>keys</code></td><td>-</td><td>Optional</td><td>A set of XML/JSON/ToString attributes and objects to flag as sensitive</td></tr>
<tr><td><code>custom.*</code></td><td>-</td><td>Optional</td><td>Custom go regex replacement.  Does not use <code>keys</code>.</td></tr>
<tr><td><code>json.*</code></td><td>-</td><td>Optional</td><td>JSON replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
<tr><td><code>xml.*</code></td><td>-</td><td>Optional</td><td>XML replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
<tr><td><code>to-string.*</code></td><td>-</td><td>Optional</td><td>Stringer replacement.  Replaces once per entry in <code>keys</code>.</td></tr>
</tbody></table>
</div>
<p>For <code>custom</code>, specify a list of regexes and replacements in <code>custom.patterns</code>, as above.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>custom.patterns[*].from</code></td><td>-</td><td>Required</td><td>Regex to match</td></tr>
<tr><td><code>custom.patterns[*].to</code></td><td>-</td><td>Required</td><td>Replacement (including variables)</td></tr>
</tbody></table>
</div>
<p>For <code>json</code>, <code>xml</code>, <code>tostring</code>, specify a list of regexes to match, including the named capture groups
<code>prefix</code> and <code>postfix</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>.enabled</code></td><td>true</td><td>Optional</td><td>Enable this set of patterns (<code>json</code>, <code>xml</code>, <code>to-string</code>)</td></tr>
<tr><td><code>.patterns[*].from</code></td><td>-</td><td>Required</td><td>Regex to match</td></tr>
<tr><td><code>.patterns[*].to</code></td><td><code>${prefix}*****${postfix}</code></td><td>Optional</td><td>Replacement (including regex variables)</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="msx-scheduled-module"><a class="header" href="#msx-scheduled-module">MSX Scheduled Module</a></h1>
<p>MSX Scheduled manages the periodic execution of tasks within microservices.</p>
<h2 id="tasks"><a class="header" href="#tasks">Tasks</a></h2>
<p>The work to be performed on a periodic basis must be surrounded in an Action (a function signature matching<code>types.ActionFunc</code>):</p>
<pre><code class="language-go">func doWork(ctx context.Context) error {
  // TODO: perform the desired work.
} 
</code></pre>
<p>Actions can be anonymous functions, struct methods (as above), or static methods, and can also be derived from Operations (<code>types.Operation</code>).</p>
<h2 id="scheduling"><a class="header" href="#scheduling">Scheduling</a></h2>
<p>Scheduling a task requires two steps: Configuration and Registration.</p>
<h3 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h3>
<p>To configure the periodic execution, your task will need a simple name to identify its configuration.  For example, the <code>do-work</code> task can be configured as:</p>
<pre><code class="language-yaml">scheduled.tasks:
    do-work:
        fixed-interval: 10m
        # fixed-delay: 5m
        # initial-delay: 15m
        # cron-expression: &quot;0 0 0 * *&quot;
</code></pre>
<p>This example configuration will execute the <code>do-work</code> task (once registered) every 10 minutes.</p>
<p>To ensure a fixed period <em>between</em> executions, use the <code>fixed-delay</code> configuration instead.</p>
<p>To specify an initial delay before first execution that is different from <code>fixed-delay</code> or <code>fixed-interval</code>, specify the <code>initial-delay</code>.</p>
<p>To use a CRON expression to specify the execution schedule, use the <code>cron-expression</code> configuration.  For an overview of CRON expressions, see <a href="https://en.wikipedia.org/wiki/Cron">here</a>.</p>
<h3 id="registration"><a class="header" href="#registration">Registration</a></h3>
<p>To register your task at runtime, call the <code>scheduled.ScheduleTask</code> function during the application Start:</p>
<pre><code class="language-go">const taskNameDoWork = &quot;do-work&quot;

func init() {
  app.OnRootEvent(app.EventStart, app.PhaseAfter, func(ctx context.Context) error {
        return scheduled.ScheduleTask(ctx, taskNameDoWork, doWork)
  })
}
</code></pre>
<p>This will load the configuration using the supplied task name, and schedule the task according to the configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msx-transit-module"><a class="header" href="#msx-transit-module">MSX Transit Module</a></h1>
<p>MSX transit is an implementation of transit encryption.  It allows swappable encryption implementations via the <code>Provider</code> interface.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<p>The primary mode of consumption for MSX Transit is within business Models.  To add transit encryption support to your model, add an anonymous <code>transit.WithSecureData</code> member to your model structure:</p>
<pre><code class="language-go">type Organization struct {
	transit.WithSecureData
	OrganizationId string     `db:&quot;organization_id&quot;`
	TenantId       gocql.UUID `db:&quot;tenant_id&quot;`
}
</code></pre>
<p>This embedded struct will store its data in a field named <code>secure_data</code>, so a migration will need to add such a field if the table already exists:</p>
<pre><code class="language-sql">ALTER TABLE organization ADD COLUMN secure_data TEXT;
</code></pre>
<p>To store and retrieve individual encrypted fields from your model, add accessors:</p>
<pre><code class="language-go">const secureDataMerakiApiKey = &quot;merakiApiKey&quot;

func (o *Organization) MerakiApiKey(ctx context.Context) (string, error) {
	return o.SecureValue(ctx, organizationSecureFieldMerakiApiKey)
}

func (o *Organization) SetMerakiApiKey(ctx context.Context, value *string) error {
	return o.SetSecureValue(ctx, o.TenantId.Bytes(), secureDataMerakiApiKey, value)
}
</code></pre>
<p>You can then use these accessors in your converter and services to retrieve and store the values from your model.</p>
<h3 id="per-application-encryption"><a class="header" href="#per-application-encryption">Per-Application Encryption</a></h3>
<p>Sometimes you will want values to be encrypted, but non on a per-tenant basis.  In this case, define your key id within your domain package, and use it in place of the TenantId in your property setters:</p>
<pre><code class="language-go">var appKeyId := types.MustParseUUID(&quot;3e246fc7-12d8-4626-a739-1fd22bbf47f0&quot;)

func (o *Organization) SetMerakiApiKey(ctx context.Context, value *string) error {
	return o.SetSecureValue(ctx, appKeyId.Bytes(), secureDataMerakiApiKey, value)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Skel is a tool for generating MSX service skeletons and components. It is a part of
the go-msx library and tools, and the skeleton projects it generates are compatible 
with the go-msx framework.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>You may install Skel either by cloning the git repo and using golang's install command, or by copying the 'skel' binary
from the repo's 'bin' directory; the latter is recommended since you will need to update it from time to time.</p>
<p>In either case, you will need to ensure that Git is set up and can communicate with the cto-github.cisco.com server. See
the <a href="skel/docs/../../index.html#requirements">go-msx README</a> for details.</p>
<h2 id="install-from-artifactory"><a class="header" href="#install-from-artifactory">Install from Artifactory</a></h2>
<ol>
<li>
<p>Download the skel tarball:</p>
<p><strong>MacOS</strong>:</p>
<pre><code class="language-bash">curl -L -o - https://engci-maven-master.cisco.com/artifactory/symphony-group/com/cisco/vms/go-msx-skel/latest/go-msx-skel-darwin-latest.tar.gz | tar -xzf -
</code></pre>
<p><strong>Linux</strong>:</p>
<pre><code class="language-bash">curl -L -o - https://engci-maven-master.cisco.com/artifactory/symphony-group/com/cisco/vms/go-msx-skel/latest/go-msx-skel-linux-latest.tar.gz | tar -xzf -
</code></pre>
</li>
<li>
<p>Move the skel binary to a location in your path:</p>
<pre><code class="language-bash">mv skel ~/go/bin
</code></pre>
</li>
</ol>
<h2 id="install-via-go"><a class="header" href="#install-via-go">Install via Go</a></h2>
<p>Prerequisite: <strong>Go 1.18+</strong></p>
<ol>
<li>
<p>Ensure your GOBIN environment variable is correctly set and referenced in your PATH. For example:</p>
<pre><code class="language-bash">export GOPATH=~/go
export PATH=$PATH:$GOPATH/bin
</code></pre>
<p>Recall that GOBIN defaults to <code>$GOPATH/bin</code>, or <code>$HOME/go/bin</code> if the <code>GOPATH</code>
environment variable is not set.</p>
</li>
<li>
<p>Be sure to set your Go proxy settings correctly. For example:</p>
<pre><code class="language-bash">go env -w GOPRIVATE=cto-github.cisco.com/NFV-BU
</code></pre>
</li>
<li>
<p>Check-out go-msx into your local workspace:</p>
<pre><code class="language-bash">mkdir -p $HOME/msx &amp;&amp; cd $HOME/msx
git clone git@cto-github.cisco.com:NFV-BU/go-msx.git
cd go-msx
go mod download
</code></pre>
</li>
<li>
<p>Install <code>skel</code>:</p>
<pre><code class="language-bash">make install-skel
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-5"><a class="header" href="#usage-5">Usage</a></h1>
<p>Skel may be run using either command-line sub-commands or by using its minimal, but hopefully helpful, interactive mode.</p>
<ul>
<li>
<p>To start the interactive project generator, run the skel command with no arguments:</p>
<pre><code class="language-bash">skel
</code></pre>
</li>
<li>
<p>To list the targets and options for the skel command, add the <code>-h</code> flag:</p>
<pre><code class="language-bash">skel -h
</code></pre>
</li>
<li>
<p>To get help for a particular target:</p>
<pre><code class="language-bash">skel &lt;target&gt; -h
</code></pre>
</li>
</ul>
<p>In addition to the numerous generation targets, there are the following utility targets:</p>
<ul>
<li><code>help</code>: display the help text</li>
<li><code>version</code>: display the current, and most recent <code>skel</code> build versions</li>
<li><code>completion</code>: generate the BASH completion script for <code>skel</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-microservice"><a class="header" href="#generic-microservice">Generic Microservice</a></h1>
<ul>
<li><em>Contains:</em> {wazinnit}</li>
<li><em>Root dir:</em> ./{serviceName}/</li>
<li><em>Command:</em> <code>generate-app</code></li>
<li><em>Menu:</em> Generate Archetype | Generic Microservice</li>
</ul>
<p>A generic MSX app skeleton that contains various bony bits ...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="probes-beats"><a class="header" href="#probes-beats">Probes (Beats)</a></h1>
<p>Probes enable the collection of operational data from remote systems
on a per-device basis.</p>
<ul>
<li>
<p>To generate an operational data collector:</p>
<pre><code class="language-bash">skel
</code></pre>
<pre><code>? Generate archetype: Beat
? Project Parent Directory: /Users/mcrawfo2/msx/demos
? Version: 5.0.0
? Protocol: arp
? Build notifications slack channel: go-msx-build
? Primary branch name: main
</code></pre>
</li>
</ul>
<p>For more details about creating and implementing probes, please see the 
<a href="https://cto-github.cisco.com/NFV-BU/go-msx-beats/blob/master/docs/writing-a-new-beat.md">Writing a New Beat</a> 
tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channels"><a class="header" href="#channels">Channels</a></h1>
<ul>
<li>
<p>To interactively generate a channel publisher or subscriber, for one or
more messages:</p>
<pre><code class="language-bash">skel generate-channel
</code></pre>
</li>
<li>
<p>To generate a channel supporting a single message publisher:</p>
<pre><code class="language-bash">skel generate-channel-publisher &quot;COMPLIANCE_EVENT_TOPIC&quot;
</code></pre>
</li>
<li>
<p>To generate a channel supporting multiple message publishers,
or add another message publisher to an existing multi-message publisher
channel:</p>
<pre><code class="language-bash">skel generate-channel-publisher &quot;COMPLIANCE_EVENT_TOPIC&quot; --message &quot;DriftCheck&quot;
</code></pre>
</li>
<li>
<p>To generate a channel supporting a single message subscriber:</p>
<pre><code class="language-bash">skel generate-channel-subscriber &quot;COMPLIANCE_EVENT_TOPIC&quot;
</code></pre>
</li>
<li>
<p>To generate a channel supporting multiple message subscribers,
or add another message subscriber to an existing multi-message subscriber
channel:</p>
<pre><code class="language-bash">skel generate-channel-subscriber &quot;COMPLIANCE_EVENT_TOPIC&quot; --message &quot;DriftCheck&quot;
</code></pre>
</li>
</ul>
<h2 id="files"><a class="header" href="#files">Files</a></h2>
<p>From the above examples, the following files may be generated:</p>
<ul>
<li><code>pkg.go</code>
<ul>
<li>Package-wide logger</li>
<li>Context Key type definition</li>
<li>Channel for <code>COMPLIANCE_EVENT_TOPIC</code></li>
<li>Channel documentation (<code>asyncapi.Channel</code>)</li>
</ul>
</li>
<li><code>publisher_channel.go</code>
<ul>
<li>Channel publisher for the package channel</li>
<li>Channel publisher documentation (<code>asyncapi.Operation</code>)</li>
</ul>
</li>
<li><code>subscriber_channel.go</code>
<ul>
<li>Channel subscriber for the package channel</li>
<li>Channel subscriber documentation (<code>asyncapi.Operation</code>)</li>
</ul>
</li>
<li><code>publisher_*.go</code>
<ul>
<li>Message publisher for individual outgoing messages</li>
<li>Message publisher documentation (<code>asyncapi.Message</code>)</li>
</ul>
</li>
<li><code>subscriber_*.go</code>
<ul>
<li>Message subscriber for individual incoming messages</li>
<li>Message subscriber documentation (<code>asyncapi.Message</code>)</li>
</ul>
</li>
<li><code>api/*.go</code>
<ul>
<li>DTOs for published messages (eg <code>DriftCheckRequest</code>)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncapi"><a class="header" href="#asyncapi">AsyncAPI</a></h1>
<ul>
<li>
<p>To interactively generate a channel publisher or subscriber, for one or
more channels from an existing AsyncApi specification via url or local path:</p>
<pre><code class="language-bash">skel generate-channel-asyncapi
</code></pre>
</li>
<li>
<p>To generate a consumer for channels from an existing AsyncApi specification via url:</p>
<pre><code class="language-bash">export ASYNCAPI_SPEC_URL=&quot;https://cto-github.cisco.com/raw/NFV-BU/merakigoservice/develop/api/asyncapi.yaml?token=...&quot;
skel generate-channel-asyncapi &quot;$ASYNCAPI_SPEC_URL&quot; COMPLIANCE_EVENT_TOPIC 
</code></pre>
</li>
<li>
<p>To generate a consumer for channels from an existing AsyncApi specification from a local
specification:</p>
<pre><code class="language-bash">skel generate-channel-asyncapi &quot;api/asyncapi.yaml&quot; COMPLIANCE_EVENT_TOPIC 
</code></pre>
</li>
<li>
<p>To generate a consumer for channels from an existing AsyncApi specification via url:</p>
<pre><code class="language-bash">export ASYNCAPI_SPEC_URL=&quot;https://cto-github.cisco.com/raw/NFV-BU/merakigoservice/develop/api/asyncapi.yaml?token=...&quot;
skel generate-channel-asyncapi &quot;$ASYNCAPI_SPEC_URL&quot; COMPLIANCE_EVENT_TOPIC 
</code></pre>
</li>
<li>
<p>To generate a consumer for channels from an existing AsyncApi specification from a local
specification:</p>
<pre><code class="language-bash">skel generate-channel-asyncapi &quot;api/asyncapi.yaml&quot; COMPLIANCE_EVENT_TOPIC 
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="makefile-usage"><a class="header" href="#makefile-usage">Makefile Usage</a></h1>
<p>go-msx uses GNU Make to present abstract build targets for developers and Continuous Integration
systems.  This allows for consistent builds across a variety of environments, and development
of Continuous Integration without a hosted job runner.</p>
<p><code>make</code> may be run directly to execute targets.</p>
<ul>
<li>
<p>To list the targets in the Makefile, execute the <code>help</code> target:</p>
<pre><code class="language-bash">make help
</code></pre>
<p>Sample output is shown below.</p>
</li>
<li>
<p>To pass flags to the <code>go</code> command when executing <code>build</code>:</p>
<pre><code class="language-bash">export BUILDER_FLAGS='-exec xprog'
make vet
</code></pre>
</li>
<li>
<p>To pass flags to the <code>build</code> command when executing <code>build</code>:</p>
<pre><code class="language-bash">export BUILD_FLAGS='--artifactory.password=&quot;cisco123&quot;'
make publish
</code></pre>
</li>
</ul>
<p>In addition to the numerous build targets (below), there are the following utility targets:</p>
<ul>
<li><code>help</code>: display the help text</li>
</ul>
<h2 id="targets"><a class="header" href="#targets">Targets</a></h2>
<pre><code>assemblies               Generate supplemental artifacts
clean                    Remove any temporary build outputs
debug                    Build a debug executable
deploy-github-repo       Configure a standard github repository
deploy-jenkins-job       Upload a standard Jenkins build job to MSX Jenkins
deployment               Generate the installer deployment variables
deps                     Install dependencies
dist                     Build all outputs required for a container image
docker                   Generate a docker image for this service
docker-debug             Generate a debugging docker image for this service
docker-publish           Publish a docker image for this service
generate                 Execute code generation
help                     Show this help
manifest                 Generate the installer manifest
openapi-compare          Compare the openapi contracts for the microservice
openapi-generate         Store the openapi contract for the microservice
package                  Generate an SLM package
package-deploy           Deploy this service using SLM to an MSX instance
package-publish          Publish this service as an SLM package to S3
precommit                Ensure the code is ready for committing to version control
publish                  Publish all artifacts required for the installer
tag                      Tag the repository with a new PATCH version number
test                     Execute unit tests
update-go-msx            Update the go-msx library dependency to the latest version
update-go-msx-build      Update the go-msx-build library dependency to the latest version
update-go-msx-populator  Update the go-msx-populator library dependency to the latest version
verify-contract          Ensure the openapi contract matches the generated code
vet                      Use go vet to validate sources
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-usage"><a class="header" href="#build-usage">Build Usage</a></h1>
<p><code>build</code> may be run directly using command-line targets.</p>
<ul>
<li>
<p>To list the targets and options for the build command, add the <code>-h</code> flag:</p>
<pre><code class="language-bash">go run cmd/build/build.go --config cmd/build/build.yml -h
</code></pre>
</li>
<li>
<p>To get help for a particular target:</p>
<pre><code class="language-bash">go run cmd/build/build.go --config cmd/build/build.yml &lt;target&gt; -h
</code></pre>
</li>
<li>
<p>To pass a custom build configuration, use the <code>--config</code> option:</p>
<pre><code class="language-bash">go run cmd/build/build.go --config cmd/build/build-custom.yml &lt;target&gt;
</code></pre>
</li>
</ul>
<p>In addition to the numerous build targets (below), there are the following utility targets:</p>
<ul>
<li><code>help</code>: display the help text</li>
<li><code>version</code>: display the current, and most recent <code>skel</code> build versions</li>
<li><code>completion</code>: generate the BASH completion script for <code>skel</code></li>
</ul>
<h2 id="targets-1"><a class="header" href="#targets-1">Targets</a></h2>
<pre><code>Available Commands:
build-assemblies              Builds Assemblies
build-debug-executable        Build the binary debug executable
build-executable              Build the binary executable
build-installer-manifest      Generate the installer manifests
build-package                 Build the service deployment package
build-tool                    Build the binary tool
compare-openapi-spec          Compares the current openapi spec with the stored version
completion                    Generate the autocompletion script for the specified shell
deploy-github-repo            Deploy Github repository
deploy-jenkins-job            Deploy Jenkins job
deploy-package                Deploy the service to an MSX instance
docker-build                  Build the target release docker image
docker-build-debug            Build the target debug docker image
docker-push                   Push the target docker image to the upstream repository
docker-save                   Save the target docker image to the specified file
download-generate-deps        Download generate dependencies
download-seccomp-dependencies Download seccomp dependencies
download-test-deps            Download test dependencies
execute-unit-tests            Execute unit tests
generate                      Generate code
generate-build-info           Create a build metadata file
generate-deployment-variables Stage variables file with build version
generate-openapi-spec         Stores the current openapi spec into a file
generate-seccomp-profile      Create a seccomp profile
git-tag                       Tag the current commit
go-fmt                        Format all go source files
go-vet                        Vet all go source files
help                          Help about any command
install-asyncapi-ui           Installs AsyncAPI/Studio package
install-dependency-configs    Download dependency config files to distribution config directory
install-entrypoint            Copy custom entrypoint to distribution root directory
install-executable-configs    Copy configured files to distribution config directory
install-extra-configs         Copy custom files to distribution config directory
install-resources             Installs Resources
install-swagger-ui            Installs Swagger-UI package
license                       License all go source files
publish-binaries              Publishes Binaries
publish-installer-manifest    Deploy the installer manifests
publish-package               Publish the service deployment package
publish-tool                  Publish the binary tool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-configuration"><a class="header" href="#build-configuration">Build Configuration</a></h1>
<p>go-msx Build uses YAML build configuration files to define the build to be executed.
A build configuration describes the build metadata for one of:</p>
<ul>
<li>Microservice</li>
<li>Command Line tool</li>
<li>Service Pack</li>
<li>Library</li>
</ul>
<p>A build configuration file can include these artifacts:</p>
<ul>
<li>Binary artifacts</li>
<li>Assemblies (tarballs)</li>
<li>Resources</li>
<li>Runtime Configuration Files</li>
<li>Docker Images</li>
</ul>
<h2 id="configuration-sources"><a class="header" href="#configuration-sources">Configuration Sources</a></h2>
<p>Like all go-msx applications, go-msx-build can retrieve configuration from a variety of sources:</p>
<ul>
<li>Environment</li>
<li>Command-Line Options</li>
<li>Build Configuration Files</li>
<li>Application Configuration Files</li>
<li>Defaults</li>
</ul>
<p>To specify the primary build configuration file, pass the <code>--config</code> option to build:</p>
<pre><code class="language-bash">go run cmd/build/build.go --config cmd/build/build.yml
</code></pre>
<p>This will normally be handled by the Makefile.</p>
<p>Configuration passed in by either Environment Variables or Command-Line Options will override
values also specified in Files or Defaults.</p>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>Some settings are intended to be injected from environment variables.  These include:</p>
<ul>
<li><code>docker.username</code> (<code>DOCKER_USERNAME</code>)</li>
<li><code>docker.password</code> (<code>DOCKER_PASSWORD</code>)</li>
<li><code>artifactory.username</code> (<code>ARTIFACTORY_USERNAME</code>)</li>
<li><code>artifactory.password</code> (<code>ARTIFACTORY_PASSWORD</code>)</li>
<li><code>build.number</code> (<code>BUILD_NUMBER</code>)</li>
<li><code>manifest.folder</code> (<code>MANIFEST_FOLDER</code>)</li>
<li><code>jenkins.username</code> (<code>JENKINS_USERNAME</code>)</li>
<li><code>jenkins.password</code> (<code>JENKINS_PASSWORD</code>)</li>
<li><code>github.token</code> (<code>GITHUB_TOKEN</code>)</li>
</ul>
<p>It is considered unsafe or inflexible to store them directly in the configuration file.
The default generated Jenkinsfile will automatically inject these environment
variables as required by the relevant steps.</p>
<h3 id="application-configuration"><a class="header" href="#application-configuration">Application Configuration</a></h3>
<p>Some settings below are intended to be read from the application configuration files.<br />
These include:</p>
<ul>
<li><code>info.app.*</code> - <code>bootstrap.yml</code></li>
<li><code>server.*</code> - <code>bootstrap.yml</code></li>
</ul>
<p>To ensure these are being read from the correct source, ensure the <code>executable.config-files</code> list
contains the base application configuration files (eg <code>bootstrap.yml</code>).</p>
<p>Example:</p>
<pre><code class="language-yaml">executable:
  configFiles:
    - bootstrap.yml
</code></pre>
<h2 id="configuration-sections"><a class="header" href="#configuration-sections">Configuration Sections</a></h2>
<h3 id="executable"><a class="header" href="#executable"><code>executable</code></a></h3>
<p>The <code>executable</code> configuration specifies the entrypoint and primary configuration file(s) of this build.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>executable.cmd</code></td><td><code>app</code></td><td>Optional</td><td>The <code>cmd</code> sub-folder containing the application <code>main</code> module.</td></tr>
<tr><td><code>executable.config-files</code></td><td>-</td><td>Required</td><td>A list of configuration files within the main module to include in the build.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">executable:
  configFiles:
    - bootstrap.yml
    - dnaservice.production.yml
</code></pre>
<h3 id="msx"><a class="header" href="#msx"><code>msx</code></a></h3>
<p>The <code>msx</code> configuration specifies details of the MSX release to interface with.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>msx.release</code></td><td>-</td><td>Required</td><td>The MSX release of this microservice (output).</td></tr>
<tr><td><code>msx.deployment-group</code></td><td>-</td><td>Required</td><td>The deployment group of the build.</td></tr>
<tr><td><code>msx.platform.parent-artifacts</code></td><td>-</td><td>Required</td><td>Maven artifact roots to scan for default properties.</td></tr>
<tr><td><code>msx.platform.version</code></td><td>-</td><td>Required</td><td>The platform version to use for locating maven artifacts.  Accepts <code>EDGE</code> and <code>STABLE</code> builds.</td></tr>
<tr><td><code>msx.platform.include-groups</code></td><td>-</td><td>Required</td><td>Maven artifact groupIds to include in artifact scanning.</td></tr>
<tr><td><code>msx.platform.swagger-artifact</code></td><td><code>com.cisco.nfv:nfv-swagger</code></td><td>Optional</td><td>MSX artifact groupId and artifactId for nfv-swagger.</td></tr>
<tr><td><code>msx.platform.swagger-webjar</code></td><td><code>org.webjars:swagger-ui:3.23.11</code></td><td>Optional</td><td>Maven artifact triple for swagger web jar.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">msx:
  release: 3.10.0
  deploymentGroup: dna
  platform:
    parentArtifacts:
      - com.cisco.vms:vms-service-starter
      - com.cisco.vms:vms-service-starter-core
      - com.cisco.vms:vms-service-starter-kafka
      - com.cisco.nfv:nfv-integration-consul-leader
    version: 3.10.0-EDGE
    includeGroups: &quot;com.cisco.**&quot;
</code></pre>
<h3 id="docker"><a class="header" href="#docker"><code>docker</code></a></h3>
<p>The <code>docker</code> configuration controls interactions with the docker daemon, global repository,
images, and <code>Dockerfile</code> scripts.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>docker.dockerfile</code></td><td><code>docker/Dockerfile</code></td><td>Optional</td><td>The <code>Dockerfile</code> used for this build.</td></tr>
<tr><td><code>docker.baseimage</code></td><td><code>msx-base-buster:3.9.0-70</code></td><td>Optional</td><td>The base image within the repository.</td></tr>
<tr><td><code>docker.repository</code></td><td><code>dockerhub.cisco.com/vms-platform-dev-docker</code></td><td>Optional</td><td>The repository source and destination.</td></tr>
<tr><td><code>docker.username</code></td><td>-</td><td>Optional</td><td>User name to authenticate to repository.</td></tr>
<tr><td><code>docker.password</code></td><td>-</td><td>Optional</td><td>Password to authenticate to repository.</td></tr>
<tr><td><code>docker.buildkit</code></td><td>-</td><td>Optional</td><td><code>true</code> to use docker buildkit when building the docker image.</td></tr>
<tr><td><code>docker.base.dynamic.enabled</code></td><td><code>true</code></td><td>Optional</td><td><code>true</code> to use manifests to dynamically locate the base docker image.</td></tr>
<tr><td><code>docker.base.dynamic.stream</code></td><td><code>EI-Stable</code></td><td>Optional</td><td>Manifest stream to search within for manifests</td></tr>
<tr><td><code>docker.base.dynamic.version</code></td><td><code>${msx.release}</code></td><td>Optional</td><td>MSX release to search within for manifests</td></tr>
<tr><td><code>docker.base.dynamic.manifest</code></td><td><code>msxbase-bullseye-manifest</code></td><td>Optional</td><td>MSX manifest to search within for builds</td></tr>
<tr><td><code>docker.base.dynamic.image</code></td><td><code>msx-base-image</code></td><td>Optional</td><td>Manifest key identifying the image to use</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">docker:
    dockerfile: build/package/Dockerfile
</code></pre>
<h3 id="kubernetes"><a class="header" href="#kubernetes"><code>kubernetes</code></a></h3>
<p>The <code>kubernetes</code> configuration provides defaults for generating kubernetes manifests.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kubernetes.group</code></td><td><code>platformms</code></td><td>Optional</td><td>The kubernetes group used for pods in production.</td></tr>
</tbody></table>
</div>
<h3 id="manifest"><a class="header" href="#manifest"><code>manifest</code></a></h3>
<p>The <code>manifest</code> configuration specifies how to build and publish installer manifests.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>manifest.folder</code></td><td><code>Build-Stable</code></td><td>Optional</td><td>The maven output folder to publish the manifest to.</td></tr>
</tbody></table>
</div>
<h3 id="resources"><a class="header" href="#resources"><code>resources</code></a></h3>
<p>The <code>resources</code> section identifies the files to be included as part of the docker image.</p>
<p>Each entry has the following properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>resources.includes</code></td><td>-</td><td>Optional</td><td>List of globs of files to include. Processed first.</td></tr>
<tr><td><code>resources.excludes</code></td><td>-</td><td>Optional</td><td>List of globs of files to exclude. Processed second.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">resources:
  includes:
    - &quot;/internal/migrate/**/*.sql&quot;
    - &quot;/internal/populate/**/*&quot;
  excludes:
    - &quot;/internal/populate/**/*.go&quot;
</code></pre>
<h3 id="assemblies"><a class="header" href="#assemblies"><code>assemblies</code></a></h3>
<p>The <code>assemblies</code> configuration specifies <code>.tar</code> file generation.  The <code>.tar</code> files will be included in generated
manifests and published (unless disabled).</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>assemblies.root</code></td><td><code>platform-common</code></td><td>Optional</td><td>The folder from which assemblies are created by default. All sub-folders with a 'templates' folder or 'manifest.json' are included.</td></tr>
<tr><td><code>assemblies.custom</code></td><td>-</td><td>Optional</td><td>List of custom assemblies to include.  See <a href="build/docs/config.html#assembliescustom">below</a></td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">assemblies:
  root: platform-common
</code></pre>
<h4 id="assembliescustom"><a class="header" href="#assembliescustom"><code>assemblies.custom</code></a></h4>
<p>The <code>assemblies.custom</code> setting contains a list of custom assemblies to generate.  These
will be uploaded to artifactory and recorded as binaries in the manifest, unless disabled
with <code>artifactory.assemblies</code>.</p>
<p>Each entry in this list has the following properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>path</code></td><td>-</td><td>Required</td><td>The root path of the assembly files.</td></tr>
<tr><td><code>path-prefix</code></td><td>-</td><td>Optional</td><td>A folder inside the assembly to prefix the files during the build.</td></tr>
<tr><td><code>manifest-prefix</code></td><td>-</td><td>Required</td><td>The prefix of the file name in the manifest.</td></tr>
<tr><td><code>manifest-key</code></td><td>-</td><td>Required</td><td>The location of the entry in the JSON manifest.</td></tr>
<tr><td><code>includes</code></td><td><code>/**/*</code></td><td>Optional</td><td>Glob of files to include.  Processed first.</td></tr>
<tr><td><code>excludes</code></td><td>-</td><td>Optional</td><td>Glob of files to exclude.  Processed second.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<p>To create an assembly file called &quot;skyfallui-files-${release}-${build}.tar&quot;:</p>
<pre><code class="language-yaml">assemblies:
  custom:
    - path: ui/build
      pathPrefix: services
      manifestPrefix: skyfallui-files
      manifestKey: ${msx.deploymentGroup}-ui
</code></pre>
<ul>
<li>Each file from the <code>ui/build</code> subtree will be prefixed with the <code>services</code> folder in the output tar.
e.g. 'ui/build/dna/index.js' will be relocated to <code>services/dna/index.js</code>.</li>
<li>The assembly will be added to the generated artifact manifests at e.g. <code>dna-ui</code>.</li>
</ul>
<h3 id="artifactory"><a class="header" href="#artifactory"><code>artifactory</code></a></h3>
<p>The <code>artifactory</code> configuration specifies artifactory connectivity, folders, binaries, and images.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>artifactory.assemblies</code></td><td><code>true</code></td><td>Optional</td><td>Include <a href="build/docs/config.html#assemblies">assemblies</a> in publishing and manifests</td></tr>
<tr><td><code>artifactory.installer</code></td><td><code>deployments/kubernetes</code></td><td>Optional</td><td>The folder in which installer binaries can be found.  eg pod, rc, meta templates.</td></tr>
<tr><td><code>artifactory.repository</code></td><td><code>https://.../vms-3.0-binaries</code></td><td>Optional</td><td>The base url for storing published artifacts</td></tr>
<tr><td><code>artifactory.installer-folder</code></td><td><code>binaries/vms-3.0-binaries</code></td><td>Optional</td><td>The folder prefix of binaries to record in the manifest</td></tr>
<tr><td><code>artifactory.username</code></td><td>-</td><td>Optional</td><td>The user name with which to authenticate to Artifactory.</td></tr>
<tr><td><code>artifactory.password</code></td><td>-</td><td>Optional</td><td>The password with which to authenticate to Artifactory.</td></tr>
<tr><td><code>artifactory.custom</code></td><td>-</td><td>Optional</td><td>List of custom binaries to include.  See <a href="build/docs/config.html#artifactorycustom">below</a></td></tr>
<tr><td><code>artifactory.images</code></td><td>-</td><td>Optional</td><td>List of docker images to include.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">artifactory:
  installer: deployments/production
  images:
    - nacservice
</code></pre>
<h4 id="artifactorycustom"><a class="header" href="#artifactorycustom"><code>artifactory.custom</code></a></h4>
<p>The <code>artifactory.custom</code> setting contains a list of custom binaries to include.  These
will be uploaded to artifactory and recorded in the manifest.</p>
<p>Each entry in this list has the following properties:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>path</code></td><td>Required</td><td>The source path of the file to include.</td></tr>
<tr><td><code>output-name</code></td><td>Required</td><td>The destination name of the file.</td></tr>
<tr><td><code>manifest-prefix</code></td><td>Required</td><td>The prefix of the file name in the manifest.</td></tr>
<tr><td><code>manifest-key</code></td><td>Required</td><td>The location of the entry in the JSON manifest.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">artifactory:
  custom:
    - path: deploymentvariables/nac_deployment_variables.yml
      outputName: nac_deployment_variables.yml
      manifestPrefix: deployment-variables
      manifestKey: deployment_variables
    - path: deploymentvariables/nac_variables.yml
      outputName: nac_variables.yml
      manifestPrefix: variables
      manifestKey: variables    
</code></pre>
<h3 id="generate"><a class="header" href="#generate"><code>generate</code></a></h3>
<p>The <code>generate</code> configuration specifies paths to be generated by the <code>generate</code> target.
Mostly these will refer to folders on which to run <code>go generate</code> to produce mocks.<br />
Specialized generators such as <code>openapi</code> are described in following sections.</p>
<p><strong>NOTE:</strong> Embedding using vfs has been deprecated in favor of <code>go:embed</code> which executes
during the go build process.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>generate[*].path</code></td><td>-</td><td>Required</td><td>Folder to generate outputs</td></tr>
<tr><td><code>generate[*].command</code></td><td><code>go generate</code></td><td>Optional</td><td>Command to execute</td></tr>
</tbody></table>
</div>
<h3 id="generateopenapi"><a class="header" href="#generateopenapi"><code>generate[*].openapi</code></a></h3>
<p>The <code>openapi</code> generator can be used to auto-generate OpenApi clients from contract specifications.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>generate[*].openapi.spec</code></td><td>-</td><td>Required</td><td>Consumer contract location</td></tr>
<tr><td><code>generate[*].openapi.config</code></td><td>-</td><td>Required</td><td>OpenApi client generator config file</td></tr>
</tbody></table>
</div>
<h3 id="go"><a class="header" href="#go"><code>go</code></a></h3>
<p>The <code>go</code> configuration specifies environment variables and options to be passed to Go tools during the build.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td><code>go.env.all.*</code></td><td>Environment variables for all platforms</td></tr>
<tr><td><code>go.env.linux.*</code></td><td>Environment variables for linux platform</td></tr>
<tr><td><code>go.env.darwin.*</code></td><td>Environment variables for darwin (MacOS) platform</td></tr>
<tr><td><code>go.vet.options[*]</code></td><td>List of command line options to pass to <code>go vet</code></td></tr>
</tbody></table>
</div>
<h3 id="build"><a class="header" href="#build"><code>build</code></a></h3>
<p>The <code>build</code> configuration specifies information about the build used to generate <code>buildinfo.yml</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>build.number</code></td><td><code>SNAPSHOT</code></td><td>Required</td><td>The build number of this build.</td></tr>
<tr><td><code>build.group</code></td><td><code>com.cisco.msx</code></td><td>Optional</td><td>The build group.</td></tr>
</tbody></table>
</div>
<h3 id="infoapp"><a class="header" href="#infoapp"><code>info.app</code></a></h3>
<p>The <code>info.app</code> configuration specifies details about the application used across all parts of the build.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>info.app.name</code></td><td>-</td><td>Required</td><td>The name of the application being built.</td></tr>
<tr><td><code>info.app.attributes.display-name</code></td><td>-</td><td>Required</td><td>The display name of the application being built.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">info.app:
    name: dnaservice
    attributes:
      displayName: DNA Microservice
</code></pre>
<h3 id="server"><a class="header" href="#server"><code>server</code></a></h3>
<p>The <code>server</code> configuration specifies details about the web server used across all parts of the build.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>server.port</code></td><td>-</td><td>Required</td><td>The web server port of the application being built.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">server:
    port: 9393
</code></pre>
<h3 id="jenkins"><a class="header" href="#jenkins"><code>jenkins</code></a></h3>
<p>The <code>jenkins</code> configuration specifies details about the Jenkins CI server used by the project.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>jenkins.job</code></td><td>-</td><td>Optional</td><td>The simplified job path to the Jenkins Job on the server.</td></tr>
<tr><td><code>jenkins.server</code></td><td><code>https://jenkins.infra.ciscomsx.com</code></td><td>Optional</td><td>The base url of the Jenkins CI server.</td></tr>
<tr><td><code>jenkins.username</code></td><td>-</td><td>Optional</td><td>User name to authenticate to Jenkins.</td></tr>
<tr><td><code>jenkins.password</code></td><td>-</td><td>Optional</td><td>API Token to authenticate to Jenkins. Can be created on the User Configure page in Jenkins UI.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">jenkins.job: eng-sp-umbrella/builds/umbrellaservice
</code></pre>
<h3 id="github"><a class="header" href="#github"><code>github</code></a></h3>
<p>The <code>github</code> configuration specifies details about the GitHub Source Control server used by the project.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>github.repository</code></td><td>'${spring.application.name}'</td><td>Optional</td><td>The name of the repository on the server.</td></tr>
<tr><td><code>github.organization</code></td><td>'NFV-BU'</td><td>Optional</td><td>The owner of the repository on the server.</td></tr>
<tr><td><code>github.server</code></td><td><code>https://cto-github.cisco.com</code></td><td>Optional</td><td>The base url of the GitHub server.</td></tr>
<tr><td><code>github.token</code></td><td>-</td><td>Optional</td><td>API Token to authenticate to GitHub. Can be created on the <code>User Settings &gt; Developer Settings &gt; Personal Access Tokens</code> page in the GitHub UI.</td></tr>
<tr><td><code>github.hook.push</code></td><td><code>${jenkins.server}/github-webhook/</code></td><td>Optional</td><td>Github Push Webhook to configure on the repository.</td></tr>
<tr><td><code>github.hook.pull-request</code></td><td><code>${jenkins.server}/ghprbhook/</code></td><td>Optional</td><td>Github PR Webhook to configure on the repository.</td></tr>
<tr><td><code>github.teams.jenkins</code></td><td><code>Jenkins-generic-users</code></td><td>Optional</td><td>GitHub CI Team to assign write access to the repository.</td></tr>
<tr><td><code>github.teams.eng</code></td><td>-</td><td>Optional</td><td>GitHub Engineering Team to assign write access to the repository.</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml">github.organization: xiaoydu
</code></pre>
<h3 id="aws"><a class="header" href="#aws"><code>aws</code></a></h3>
<p>The <code>aws</code> configuration specifies credentials and target details for AWS.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>aws.access-key-id</code></td><td><code>${aws.access.key.id}</code></td><td>Optional</td><td>Access Key Id to authenticate to AWS.</td></tr>
<tr><td><code>aws.secret-access-key</code></td><td><code>${aws.secret.access.key}</code></td><td>Optional</td><td>Secret Access Key to authenticate to AWS.</td></tr>
</tbody></table>
</div>
<p>These values default to the standard environment variables (<code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>) so
no extra configuration should be required if using them.</p>
<h3 id="deploy"><a class="header" href="#deploy"><code>deploy</code></a></h3>
<p>The <code>deploy</code> configuration specifies the target for package deployment.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td><code>deploy.host</code></td><td>-</td><td>Required</td><td>SSH config host name to target for deployment.  Must point to an installer container.</td></tr>
</tbody></table>
</div>
<h3 id="openapi"><a class="header" href="#openapi"><code>openapi</code></a></h3>
<p>The <code>openapi</code> configuration specifies producer and consumer contract locations (local and upstream),
along with schema resolution aliases.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Default</th><th>Required</th><th>Description</th></tr></thead><tbody>
<tr><td>openapi.spec</td><td><code>api/openapi.yaml</code></td><td>Optional</td><td>The project-root relative location of the producer contract specification.</td></tr>
<tr><td>openapi.contracts[*].consumer</td><td>-</td><td>Required</td><td>Local copy of the consumer contract for client generation.</td></tr>
<tr><td>openapi.contracts[*].producer</td><td>-</td><td>Required</td><td>Upstream copy of the producer contract for client generation.</td></tr>
<tr><td>openapi.alias[*].from</td><td>-</td><td>Required</td><td>Canonical schema url to be loaded from an alternative source</td></tr>
<tr><td>openapi.alias[*].to</td><td>-</td><td>Required</td><td>Alternative source location for schema</td></tr>
</tbody></table>
</div>
<p>Example:</p>
<pre><code class="language-yaml"># Contract Management
openapi:
  # Local (producer) API contract
  spec: api/openapi.yaml

  # Remote (consumer) API contract pairs
  contracts:
    - consumer: internal/stream/.openapi/manage-service-8.yaml
      producer: https://cto-github.cisco.com/raw/NFV-BU/msx-platform-specs/develop/manage-service-8.yaml

  # Alternative sources for well-known schema
  alias:
    - from: https://api.swaggerhub.com/domains/Cisco-Systems46/msx-common-domain/8
      to: https://cto-github.cisco.com/raw/NFV-BU/msx-platform-specs/sdk1.0.10/common-domain-8.yaml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-targets"><a class="header" href="#build-targets">Build Targets</a></h1>
<p>go-msx Build has a collection of default build targets encompassing standard build steps that can be reused
in a project's Makefile.  The following chapters describe each of the standard build targets.</p>
<p>Users can also define custom build targets for project-specific needs.</p>
<h2 id="custom-build-targets"><a class="header" href="#custom-build-targets">Custom Build Targets</a></h2>
<p>Build targets can be added using the <code>build.AddTarget</code> function.  This will register a
CLI handler function for a new build target.  Build configuration can be accessed
vi the pkg.BuildConfiguration global variable from the handler function.  Ensure your
module containing the custom build target is initialized at startup by either:</p>
<ul>
<li>Defining your build target in the build <code>main</code> package of your project; or</li>
<li>Importing the module containing your custom build target from the build <code>main</code> package
of your project.</li>
</ul>
<p>Example:</p>
<pre><code class="language-go">package main

import build &quot;cto-github.cisco.com/NFV-BU/go-msx-build/pkg&quot;

var myCustomTargetFlag bool

func init() {
	cmd := build.AddTarget(&quot;custom-target&quot;, &quot;A custom build target&quot;, customTarget)
	cmd.Flags().BoolVarP(&amp;myCustomTargetFlag, &quot;enabled&quot;, &quot;e&quot;, false, &quot;Custom target option&quot;)
}

func customTarget(args []string) error {
	// custom target steps go here
	if myCustomTargetFlag {
		// ...
    }
	return nil
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-maintenance-build-targets"><a class="header" href="#project-maintenance-build-targets">Project Maintenance Build Targets</a></h1>
<h3 id="deploy-github-repo"><a class="header" href="#deploy-github-repo"><code>deploy-github-repo</code></a></h3>
<p>The <code>deploy-github-repo</code> target will create and/or reconfigure a GitHub repository with the appropriate users
and webhooks.</p>
<p>Target server and repository is configured via the <code>github.*</code> build <a href="build/docs/config.html#github">settings</a>.</p>
<h3 id="deploy-jenkins-job"><a class="header" href="#deploy-jenkins-job"><code>deploy-jenkins-job</code></a></h3>
<p>The <code>deploy-jenkins-job</code> target will upload your jenkins job as defined in the build/ci folder from <code>config.xml</code>.
This file will normally be auto-generated.</p>
<p>Target server and job is configured via the <code>jenkins.*</code> build <a href="build/docs/config.html#jenkins">settings</a>.</p>
<h3 id="update-go-msx"><a class="header" href="#update-go-msx"><code>update-go-msx</code></a></h3>
<p>The <code>update-go-msx</code> target will attempt to update your <code>go-msx</code> library to the latest version.</p>
<h3 id="update-go-msx-build"><a class="header" href="#update-go-msx-build"><code>update-go-msx-build</code></a></h3>
<p>The <code>update-go-msx-build</code> target will attempt to update your <code>go-msx-build</code> library to the latest version.</p>
<h3 id="update-go-msx-populator"><a class="header" href="#update-go-msx-populator"><code>update-go-msx-populator</code></a></h3>
<p>The <code>update-go-msx-populator</code> target will attempt to update your <code>go-msx-populator</code> library to the latest version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-targets"><a class="header" href="#development-targets">Development Targets</a></h1>
<h3 id="download-generate-deps"><a class="header" href="#download-generate-deps"><code>download-generate-deps</code></a></h3>
<p>The <code>download-generate-deps</code> target installs cross-project generation dependencies, including:</p>
<ul>
<li>github.com/rust-lang/mdBook</li>
<li>github.com/badboy/mdbook-mermaid</li>
<li>github.com/vektra/mockery/v2</li>
</ul>
<h3 id="generate-1"><a class="header" href="#generate-1"><code>generate</code></a></h3>
<p>The <code>generate</code> target will execute any custom (or default) generate commands defined in
the <code>generate.*</code> <a href="build/docs/config.html#generate">entries</a>.</p>
<p>If no command is specified for an entry, it will default to running <code>go generate</code> on that folder.</p>
<p>Generate commands can also be specified using <code>go:generate</code> <a href="https://blog.golang.org/generate">comments</a>.
Generation will be executed when <code>generate</code> executes on the directory containing files with these comments.</p>
<h3 id="go-fmt"><a class="header" href="#go-fmt"><code>go-fmt</code></a></h3>
<p>The <code>go-fmt</code> target executes <code>go fmt</code> on directories which contain <code>*.go</code> files (excluding the <code>vendor</code> directory).</p>
<h3 id="license-1"><a class="header" href="#license-1"><code>license</code></a></h3>
<p>The <code>license</code> target verifies that all go source code files contain the appropriate Cisco license header. </p>
<h3 id="update-openapi-producer-spec"><a class="header" href="#update-openapi-producer-spec"><code>update-openapi-producer-spec</code></a></h3>
<p>The <code>update-openapi-producer-spec</code> target will obtain the latest version of the
microservice <em>producer</em> OpenApi contract specification and overwrite the stored version.</p>
<p>Producer specification file is configured via the <code>openapi.spec</code> build <a href="build/docs/config.html#openapi">setting</a>.</p>
<h3 id="update-openapi-consumer-spec"><a class="header" href="#update-openapi-consumer-spec"><code>update-openapi-consumer-spec</code></a></h3>
<p>The <code>update-openapi-consumer-spec</code> target will obtain the latest version of the
<em>consumer</em> OpenApi contract specification and overwrite the stored version.</p>
<p>Consumer local and remote specification are configured via the <code>openapi.contracts[*]</code> build <a href="build/docs/config.html#openapi">setting</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artifacts-build-targets"><a class="header" href="#artifacts-build-targets">Artifacts Build Targets</a></h1>
<h3 id="build-assemblies"><a class="header" href="#build-assemblies"><code>build-assemblies</code></a></h3>
<p>The <code>build-assemblies</code> target collects folders into tarballs and places their output into the staging
assembly folder (<code>dist/assembly</code>).</p>
<p>For each entry in <code>assembly.custom.*</code>, the target will create a tar file named <code>${prefix}-${release}-${build}.tar</code>.</p>
<h3 id="build-debug-executable"><a class="header" href="#build-debug-executable"><code>build-debug-executable</code></a></h3>
<p>The <code>build-debug-executable</code> target compiles the <code>main</code> module of the current application and outputs it
to the staging executable folder (<code>dist/root/usr/bin</code>).  Unlike <code>build-executable</code>, however it outputs a
binary suitable for debugging.  This can be included in a container to remotely debug the application.</p>
<h3 id="build-executable"><a class="header" href="#build-executable"><code>build-executable</code></a></h3>
<p>The <code>build-executable</code> target compiles the <code>main</code> module of the current application and outputs it to
the staging executable folder (<code>dist/root/usr/bin</code>).</p>
<p>Flags passed to <code>go build</code> can be customized using the <code>go.env.*.GOFLAGS</code> configuration.</p>
<h3 id="build-installer-manifest"><a class="header" href="#build-installer-manifest"><code>build-installer-manifest</code></a></h3>
<p>The <code>build-installer-manifest</code> target will create install manifests for integration servers and production
installation.  The contents of the manifests will be dynamically generated from the <code>artifactory</code> and <code>assemblies</code>
configuration, along with the docker image generated from the current build configuration.</p>
<p>To deploy the manifest artifact use the <code>publish-installer-manifest</code> target.</p>
<h3 id="build-package"><a class="header" href="#build-package"><code>build-package</code></a></h3>
<p>The <code>build-package</code> target will generate a Service package to be uploaded and deployed by the service pack deployer.
It will include the standard service contents, including assemblies, manifests, images, deployment variables, and
other binaries.</p>
<p>To deploy the package artifact use the <code>publish-package</code> target.</p>
<h3 id="build-tool"><a class="header" href="#build-tool"><code>build-tool</code></a></h3>
<p>The <code>build-tool</code> target will compile and generate a Tool binary distribution (.tar.gz) to be uploaded and deployed
to Artifactory (or elsewhere).  It will include the binary and any resources defined in the <code>tool</code> configuration
section.</p>
<p>NOTE: These binaries are statically compiled and therefore must not be distributed.</p>
<h3 id="docker-build"><a class="header" href="#docker-build"><code>docker-build</code></a></h3>
<p>The <code>docker-build</code> target will create a docker image for the current build configuration.  The contents of the
image are stages using <code>make dist</code> inside a build container, and then deployed onto an MSX base image to create
the runtime container image.</p>
<p>The base image can be specified using the <code>docker.repository</code> and <code>docker.base-image</code> configuration <a href="build/docs/config.html#docker">settings</a>.</p>
<p>The docker image will be named in the format <code>${docker.repository}/${info.app.name}:${release}-${build}</code>.</p>
<h3 id="docker-build-debug"><a class="header" href="#docker-build-debug"><code>docker-build-debug</code></a></h3>
<p>The <code>docker-build-debug</code> target will create a debugging docker image for the current build configuration.<br />
The contents of the image are stages using <code>make dist</code> inside a build container, and then deployed onto an 
MSX base image to create the runtime container image.</p>
<p>The base image can be specified using the <code>docker.repository</code> and <code>docker.base-image</code> configuration <a href="build/docs/config.html#docker">settings</a>.</p>
<p>The docker image will be named in the format <code>${docker.repository}/${info.app.name}:${release}-${build}</code>.</p>
<h3 id="download-generate-deps-1"><a class="header" href="#download-generate-deps-1"><code>download-generate-deps</code></a></h3>
<p>The <code>download-generate-deps</code> target installs cross-project generation dependencies, including:</p>
<ul>
<li>github.com/vektra/mockery</li>
<li>bou.ke/staticfiles</li>
</ul>
<h3 id="download-seccomp-dependencies"><a class="header" href="#download-seccomp-dependencies"><code>download-seccomp-dependencies</code></a></h3>
<p>The <code>download-seccomp-dependencies</code> target installs the seccomp-profiler for generating seccomp profiles.
See <code>generate-seccomp-profile</code>, below.</p>
<h3 id="generate-build-info"><a class="header" href="#generate-build-info"><code>generate-build-info</code></a></h3>
<p>The <code>generate-build-info</code> target creates the build-specific metadata file <code>buildinfo.yml</code>, including version information,
and build timestamps.</p>
<p>The metadata file is generated directly into the staging configuration folder (<code>dist/root/etc/${app.name}</code>).<br />
This file will be parsed on MSX Application startup during the configuration phase, and used to register the
service metadata with Consul.</p>
<p>Default values for the <code>info.build</code> fields should be specified in the application <code>bootstrap.yml</code> file to enable
local development before generating the metadata file.</p>
<h3 id="generate-deployment-variables"><a class="header" href="#generate-deployment-variables"><code>generate-deployment-variables</code></a></h3>
<p>The <code>generate-deployment-variables</code> target creates a YAML ansible variables file compatible with the MSX installer.
This file will be published during <code>publish</code>.</p>
<h3 id="generate-seccomp-profile"><a class="header" href="#generate-seccomp-profile"><code>generate-seccomp-profile</code></a></h3>
<p>The <code>generate-seccomp-profile</code> target creates the configuration file <code>seccomp.yml</code>, listing the expected set of linux
syscalls to be allowed during execution.  This prevents a compromised executable from making unauthorized syscalls.</p>
<h3 id="install-asyncapi-ui"><a class="header" href="#install-asyncapi-ui"><code>install-asyncapi-ui</code></a></h3>
<p>The <code>install-asyncapi-ui</code> target downloads the AsyncApi Studio package and extracts the
relevant files to the staging web folder (<code>dist/root/var/lib/${app.name}/www</code>)</p>
<h3 id="install-dependency-configs"><a class="header" href="#install-dependency-configs"><code>install-dependency-configs</code></a></h3>
<p>The <code>install-dependency-configs</code> target scans maven artifacts for <code>default-*.properties</code> files and copies them
into the staging configuration folder (<code>dist/root/etc/${app.name}</code>).  At runtime, a go-msx microservice will read these
files ensuring MSX microservices across frameworks have the same default configuration.</p>
<h3 id="install-executable-configs"><a class="header" href="#install-executable-configs"><code>install-executable-configs</code></a></h3>
<p>The <code>install-executable-configs</code> target copies configuration files from the <code>main</code> module of the application being
built to the staging configuration folder (<code>dist/root/etc/${app.name}</code>).</p>
<p>The list of configuration files to be copied is specified in the build configuration at <code>executable.config-files</code>:</p>
<pre><code class="language-yaml">executable:
  configFiles:
    - bootstrap.yml
    - dnaservice.production.yml
</code></pre>
<h3 id="install-extra-configs"><a class="header" href="#install-extra-configs"><code>install-extra-configs</code></a></h3>
<h3 id="install-resources"><a class="header" href="#install-resources"><code>install-resources</code></a></h3>
<p>The <code>install-resources</code> target copies static files from the project tree to the staging resources folder
(<code>dist/var/lib/${app.name}</code>).</p>
<p>The list of resources to be copied is specified in the build configuration at <code>resources.*</code>.</p>
<h3 id="install-swagger-ui"><a class="header" href="#install-swagger-ui"><code>install-swagger-ui</code></a></h3>
<p>The <code>install-swagger-ui</code> target downloads the Swagger UI webjar and MSX Swagger artifacts and extracts the
relevant files to the staging web folder (<code>dist/root/var/lib/${app.name}/www</code>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification-build-targets"><a class="header" href="#verification-build-targets">Verification Build Targets</a></h1>
<h3 id="compare-openapi-consumer-spec"><a class="header" href="#compare-openapi-consumer-spec"><code>compare-openapi-consumer-spec</code></a></h3>
<p>The <code>compare-openapi-producer-spec</code> target will obtain the latest version of a
<em>consumer</em> OpenApi contract specification, as identified in the build configuration.
After obtaining the latest contract, it will compare it with the stored version,
and generate a report of the differences.</p>
<p>Consumer local and remote specification are configured via the <code>openapi.contracts[*]</code> build <a href="build/docs/config.html#openapi">setting</a>.</p>
<h3 id="compare-openapi-producer-spec"><a class="header" href="#compare-openapi-producer-spec"><code>compare-openapi-producer-spec</code></a></h3>
<p>The <code>compare-openapi-producer-spec</code> target will obtain the latest version of the
microservice <em>producer</em> OpenApi contract specification and compare it with the stored
version. After comparison, it will generate a report of the differences.</p>
<p>Producer specification file is configured via the <code>openapi.spec</code> build <a href="build/docs/config.html#openapi">setting</a>.</p>
<h3 id="compare-openapi-specs"><a class="header" href="#compare-openapi-specs"><code>compare-openapi-specs</code></a></h3>
<p>The <code>compare-openapi-specs</code> target will execute the <code>compare-openapi-producer-spec</code>
target, and then <code>compare-openapi-consumer-spec</code> target for each registered contract.
A summary report will be generated.</p>
<h3 id="download-test-deps"><a class="header" href="#download-test-deps"><code>download-test-deps</code></a></h3>
<p>The <code>download-test-deps</code> target installs cross-project test dependencies, including:</p>
<ul>
<li>github.com/axw/gocov/gocov</li>
<li>github.com/AlekSi/gocov-xml</li>
<li>github.com/stretchr/testify/assert</li>
<li>github.com/stretchr/testify/mock</li>
<li>github.com/stretchr/testify/http</li>
<li>github.com/pmezard/go-difflib/difflib</li>
<li>github.com/jstemmer/go-junit-report</li>
</ul>
<h3 id="execute-unit-tests"><a class="header" href="#execute-unit-tests"><code>execute-unit-tests</code></a></h3>
<p>The <code>execute-unit-tests</code> target searches for testable directories (those containing <code>*_test.go</code> files),
and invokes their unit tests while collecting line coverage data.  It then generates coverage reports
from the coverage data.</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Output File</th></tr></thead><tbody>
<tr><td>HTML</td><td><code>test/gocover.html</code></td></tr>
<tr><td>JUnit</td><td><code>test/junit-report.xml</code></td></tr>
<tr><td>Cobertura</td><td><code>test/cobertura-coverage.xml</code></td></tr>
</tbody></table>
</div>
<h3 id="go-vet"><a class="header" href="#go-vet"><code>go-vet</code></a></h3>
<p>The <code>go-vet</code> target executes <code>go vet</code> on directories which contain <code>*.go</code> files (excluding the <code>vendor</code> directory).
Options to pass to <code>go vet</code> can be specified in the build configuration under <code>go.vet.options</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-build-targets"><a class="header" href="#publishing-build-targets">Publishing Build Targets</a></h1>
<h3 id="deploy-package"><a class="header" href="#deploy-package"><code>deploy-package</code></a></h3>
<p>The <code>deploy-package</code> target will upload your already-built package tar-ball to a specified installer container.
The installer container ssh &quot;host&quot; must be properly configured in your <code>~/.ssh/config</code> file, for example:</p>
<pre><code class="language-ssh-config">Host installer-tme-dmz-01
    HostName rtp-dmz-bbhost.lab.ciscomsx.com
    User root
    Port 23556
    IdentityFile ~/.ssh/installer-tme-dmz.key
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
</code></pre>
<p>In this example, the installer container is named &quot;installer-tme-dmz-01&quot;.  This name should be passed to
using the <code>deploy.host</code> configuration, for example:</p>
<pre><code class="language-bash">go run build/cmd/build.go --config build/cmd/build.yml --deploy.host installer-tme-dmz-01 deploy-package
</code></pre>
<p>or</p>
<pre><code class="language-bash">DEPLOY_HOST=&quot;installer-tme-dmz-01&quot; make package-deploy
</code></pre>
<h3 id="docker-push"><a class="header" href="#docker-push"><code>docker-push</code></a></h3>
<p>The <code>docker-push</code> target will publish the local docker image generated using <code>docker-build</code> to the docker
repository specified in the current build configuration.</p>
<p>The repository can be specified using the <code>docker.repository</code> configuration setting.</p>
<h3 id="docker-save"><a class="header" href="#docker-save"><code>docker-save</code></a></h3>
<p>The <code>docker-save</code> target will output the local docker image generated using <code>docker-build</code> to a tar file
named <code>${info.app.name}.tar</code> in the current directory.  The tarred image will include the original repository and
image tag.</p>
<h3 id="git-tag"><a class="header" href="#git-tag"><code>git-tag</code></a></h3>
<p>The <code>git-tag</code> target re-creates and overwrites any local and remote tags for the current version <code>${release}-${build}</code>.</p>
<p>This is commonly used after publish to tag the source repo with the build.</p>
<h3 id="publish-binaries"><a class="header" href="#publish-binaries"><code>publish-binaries</code></a></h3>
<p>The <code>publish-binaries</code> target will deploy any assemblies and other installer binaries to artifactory.</p>
<p>The remote repository folder is specified through <code>artifactory.repository</code>.  Within the repository folder,
artifacts will be placed underneath <code>${msx.deploymentGroup}/${release}-${build}/</code> to isolate files from
each build and deployment group.</p>
<p>Binaries are specified in the <code>artifactory</code> configuration.  Assembly publishing can be disabled
setting the <code>artifactory.assemblies</code> to <code>false</code>.</p>
<h3 id="publish-installer-manifest"><a class="header" href="#publish-installer-manifest"><code>publish-installer-manifest</code></a></h3>
<p>The <code>publish-installer-manifest</code> target executes Maven to deploy the manifest for the current build configuration.</p>
<h3 id="publish-package"><a class="header" href="#publish-package"><code>publish-package</code></a></h3>
<p>The <code>publish-package</code> target will use your local S3 client to upload the service package to S3.  The correct S3 folder
will automatically be calculated.  Your S3 client (<code>aws s3 ...</code>) should be properly configured with credentials either
using environment variables or configuration files.</p>
<h3 id="publish-tool"><a class="header" href="#publish-tool"><code>publish-tool</code></a></h3>
<p>The <code>publish-tool</code> target will upload the tool distribution packages (built with <code>build-tool</code>) to Artifactory.
Versioned and Latest will be published for easy URL distribution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checks"><a class="header" href="#checks">Checks</a></h1>
<p>See the internal <a href="https://cto-github.cisco.com/NFV-BU/buildservice/blob/master/docs/README.md">Checks</a> documentation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="book/mermaid.min.js"></script>
        <script type="text/javascript" src="book/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
