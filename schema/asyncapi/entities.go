// Code generated by github.com/swaggest/json-cli v1.9.0, DO NOT EDIT.

// Package asyncapi contains JSON mapping structures.
package asyncapi

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/swaggest/jsonschema-go"
	"regexp"
)

// Spec structure is generated from "#".
//
// AsyncAPI 2.3.0 schema.
type Spec struct {
	// A unique id representing the application.
	// Format: uri.
	ID                 *string                `json:"id,omitempty"`
	// General information about the API.
	// Required.
	Info               Info                   `json:"info"`
	Servers            map[string]Server      `json:"servers,omitempty"`
	DefaultContentType *string                `json:"defaultContentType,omitempty"`
	Channels           map[string]ChannelItem `json:"channels"`                     // Required.
	Components         *Components            `json:"components,omitempty"`         // An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.
	Tags               []Tag                  `json:"tags,omitempty"`
	ExternalDocs       *ExternalDocs          `json:"externalDocs,omitempty"`       // Information about external documentation.
	MapOfAnything      map[string]interface{} `json:"-"`                            // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithID sets ID value.
func (s *Spec) WithID(val string) *Spec {
	s.ID = &val
	return s
}

// WithInfo sets Info value.
func (s *Spec) WithInfo(val Info) *Spec {
	s.Info = val
	return s
}

// WithServers sets Servers value.
func (s *Spec) WithServers(val map[string]Server) *Spec {
	s.Servers = val
	return s
}

// WithServersItem sets Servers item value.
func (s *Spec) WithServersItem(key string, val Server) *Spec {
	if s.Servers == nil {
		s.Servers = make(map[string]Server, 1)
	}

	s.Servers[key] = val

	return s
}

// WithDefaultContentType sets DefaultContentType value.
func (s *Spec) WithDefaultContentType(val string) *Spec {
	s.DefaultContentType = &val
	return s
}

// WithChannels sets Channels value.
func (s *Spec) WithChannels(val map[string]ChannelItem) *Spec {
	s.Channels = val
	return s
}

// WithChannelsItem sets Channels item value.
func (s *Spec) WithChannelsItem(key string, val ChannelItem) *Spec {
	if s.Channels == nil {
		s.Channels = make(map[string]ChannelItem, 1)
	}

	s.Channels[key] = val

	return s
}

// WithComponents sets Components value.
func (s *Spec) WithComponents(val Components) *Spec {
	s.Components = &val
	return s
}

// ComponentsEns ensures returned Components is not nil.
func (s *Spec) ComponentsEns() *Components {
	if s.Components == nil {
		s.Components = new(Components)
	}

	return s.Components
}

// WithTags sets Tags value.
func (s *Spec) WithTags(val ...Tag) *Spec {
	s.Tags = val
	return s
}

// WithExternalDocs sets ExternalDocs value.
func (s *Spec) WithExternalDocs(val ExternalDocs) *Spec {
	s.ExternalDocs = &val
	return s
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (s *Spec) ExternalDocsEns() *ExternalDocs {
	if s.ExternalDocs == nil {
		s.ExternalDocs = new(ExternalDocs)
	}

	return s.ExternalDocs
}

// WithMapOfAnything sets MapOfAnything value.
func (s *Spec) WithMapOfAnything(val map[string]interface{}) *Spec {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *Spec) WithMapOfAnythingItem(key string, val interface{}) *Spec {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalSpec Spec

var knownKeysSpec = []string{
	"id",
	"info",
	"servers",
	"defaultContentType",
	"channels",
	"components",
	"tags",
	"externalDocs",
	"asyncapi",
}

// UnmarshalJSON decodes JSON.
func (s *Spec) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSpec(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["asyncapi"]; exists && string(v) != `"2.3.0"` {
		return fmt.Errorf(`bad const value for "asyncapi" ("2.3.0" expected, %s received)`, v)
	}

	delete(rawMap, "asyncapi")

	for _, key := range knownKeysSpec {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Spec: %v", offendingKeys)
	}

	*s = Spec(ms)

	return nil
}

var (
	// constSpec is unconditionally added to JSON.
	constSpec = json.RawMessage(`{"asyncapi":"2.3.0"}`)
)

// MarshalJSON encodes JSON.
func (s Spec) MarshalJSON() ([]byte, error) {
	return marshalUnion(constSpec, marshalSpec(s), s.MapOfAnything)
}

// Info structure is generated from "#/definitions/info".
//
// General information about the API.
type Info struct {
	// A unique and precise title of the API.
	// Required.
	Title          string                 `json:"title"`
	// A semantic version number of the API.
	// Required.
	Version        string                 `json:"version"`
	Description    *string                `json:"description,omitempty"`    // A longer description of the API. Should be different from the title. CommonMark is allowed.
	// A URL to the Terms of Service for the API. MUST be in the format of a URL.
	// Format: uri.
	TermsOfService *string                `json:"termsOfService,omitempty"`
	Contact        *Contact               `json:"contact,omitempty"`        // Contact information for the owners of the API.
	License        *License               `json:"license,omitempty"`
	MapOfAnything  map[string]interface{} `json:"-"`                        // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithTitle sets Title value.
func (i *Info) WithTitle(val string) *Info {
	i.Title = val
	return i
}

// WithVersion sets Version value.
func (i *Info) WithVersion(val string) *Info {
	i.Version = val
	return i
}

// WithDescription sets Description value.
func (i *Info) WithDescription(val string) *Info {
	i.Description = &val
	return i
}

// WithTermsOfService sets TermsOfService value.
func (i *Info) WithTermsOfService(val string) *Info {
	i.TermsOfService = &val
	return i
}

// WithContact sets Contact value.
func (i *Info) WithContact(val Contact) *Info {
	i.Contact = &val
	return i
}

// ContactEns ensures returned Contact is not nil.
func (i *Info) ContactEns() *Contact {
	if i.Contact == nil {
		i.Contact = new(Contact)
	}

	return i.Contact
}

// WithLicense sets License value.
func (i *Info) WithLicense(val License) *Info {
	i.License = &val
	return i
}

// LicenseEns ensures returned License is not nil.
func (i *Info) LicenseEns() *License {
	if i.License == nil {
		i.License = new(License)
	}

	return i.License
}

// WithMapOfAnything sets MapOfAnything value.
func (i *Info) WithMapOfAnything(val map[string]interface{}) *Info {
	i.MapOfAnything = val
	return i
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (i *Info) WithMapOfAnythingItem(key string, val interface{}) *Info {
	if i.MapOfAnything == nil {
		i.MapOfAnything = make(map[string]interface{}, 1)
	}

	i.MapOfAnything[key] = val

	return i
}

type marshalInfo Info

var knownKeysInfo = []string{
	"title",
	"version",
	"description",
	"termsOfService",
	"contact",
	"license",
}

// UnmarshalJSON decodes JSON.
func (i *Info) UnmarshalJSON(data []byte) error {
	var err error

	mi := marshalInfo(*i)

	err = json.Unmarshal(data, &mi)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysInfo {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mi.MapOfAnything == nil {
				mi.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mi.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Info: %v", offendingKeys)
	}

	*i = Info(mi)

	return nil
}

// MarshalJSON encodes JSON.
func (i Info) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalInfo(i), i.MapOfAnything)
}

// Contact structure is generated from "#/definitions/contact".
//
// Contact information for the owners of the API.
type Contact struct {
	Name          *string                `json:"name,omitempty"`  // The identifying name of the contact person/organization.
	// The URL pointing to the contact information.
	// Format: uri.
	URL           *string                `json:"url,omitempty"`
	// The email address of the contact person/organization.
	// Format: email.
	Email         *string                `json:"email,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`               // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithName sets Name value.
func (c *Contact) WithName(val string) *Contact {
	c.Name = &val
	return c
}

// WithURL sets URL value.
func (c *Contact) WithURL(val string) *Contact {
	c.URL = &val
	return c
}

// WithEmail sets Email value.
func (c *Contact) WithEmail(val string) *Contact {
	c.Email = &val
	return c
}

// WithMapOfAnything sets MapOfAnything value.
func (c *Contact) WithMapOfAnything(val map[string]interface{}) *Contact {
	c.MapOfAnything = val
	return c
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (c *Contact) WithMapOfAnythingItem(key string, val interface{}) *Contact {
	if c.MapOfAnything == nil {
		c.MapOfAnything = make(map[string]interface{}, 1)
	}

	c.MapOfAnything[key] = val

	return c
}

type marshalContact Contact

var knownKeysContact = []string{
	"name",
	"url",
	"email",
}

// UnmarshalJSON decodes JSON.
func (c *Contact) UnmarshalJSON(data []byte) error {
	var err error

	mc := marshalContact(*c)

	err = json.Unmarshal(data, &mc)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysContact {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mc.MapOfAnything == nil {
				mc.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mc.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Contact: %v", offendingKeys)
	}

	*c = Contact(mc)

	return nil
}

// MarshalJSON encodes JSON.
func (c Contact) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalContact(c), c.MapOfAnything)
}

// License structure is generated from "#/definitions/license".
type License struct {
	// The name of the license type. It's encouraged to use an OSI compatible license.
	// Required.
	Name          string                 `json:"name"`
	// The URL pointing to the license.
	// Format: uri.
	URL           *string                `json:"url,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`             // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithName sets Name value.
func (l *License) WithName(val string) *License {
	l.Name = val
	return l
}

// WithURL sets URL value.
func (l *License) WithURL(val string) *License {
	l.URL = &val
	return l
}

// WithMapOfAnything sets MapOfAnything value.
func (l *License) WithMapOfAnything(val map[string]interface{}) *License {
	l.MapOfAnything = val
	return l
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (l *License) WithMapOfAnythingItem(key string, val interface{}) *License {
	if l.MapOfAnything == nil {
		l.MapOfAnything = make(map[string]interface{}, 1)
	}

	l.MapOfAnything[key] = val

	return l
}

type marshalLicense License

var knownKeysLicense = []string{
	"name",
	"url",
}

// UnmarshalJSON decodes JSON.
func (l *License) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLicense(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLicense {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ml.MapOfAnything == nil {
				ml.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ml.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in License: %v", offendingKeys)
	}

	*l = License(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l License) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalLicense(l), l.MapOfAnything)
}

// Server structure is generated from "#/definitions/server".
//
// An object representing a Server.
type Server struct {
	Ref             *string                   `json:"$ref,omitempty"`            // Format: uri-reference.
	URL             *string                   `json:"url,omitempty"`
	Description     *string                   `json:"description,omitempty"`
	Protocol        *string                   `json:"protocol,omitempty"`        // The transfer protocol.
	ProtocolVersion *string                   `json:"protocolVersion,omitempty"`
	Variables       map[string]ServerVariable `json:"variables,omitempty"`
	Security        []map[string][]string     `json:"security,omitempty"`
	Bindings        *BindingsObject           `json:"bindings,omitempty"`
	MapOfAnything   map[string]interface{}    `json:"-"`                         // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithRef sets Ref value.
func (s *Server) WithRef(val string) *Server {
	s.Ref = &val
	return s
}

// WithURL sets URL value.
func (s *Server) WithURL(val string) *Server {
	s.URL = &val
	return s
}

// WithDescription sets Description value.
func (s *Server) WithDescription(val string) *Server {
	s.Description = &val
	return s
}

// WithProtocol sets Protocol value.
func (s *Server) WithProtocol(val string) *Server {
	s.Protocol = &val
	return s
}

// WithProtocolVersion sets ProtocolVersion value.
func (s *Server) WithProtocolVersion(val string) *Server {
	s.ProtocolVersion = &val
	return s
}

// WithVariables sets Variables value.
func (s *Server) WithVariables(val map[string]ServerVariable) *Server {
	s.Variables = val
	return s
}

// WithVariablesItem sets Variables item value.
func (s *Server) WithVariablesItem(key string, val ServerVariable) *Server {
	if s.Variables == nil {
		s.Variables = make(map[string]ServerVariable, 1)
	}

	s.Variables[key] = val

	return s
}

// WithSecurity sets Security value.
func (s *Server) WithSecurity(val ...map[string][]string) *Server {
	s.Security = val
	return s
}

// WithBindings sets Bindings value.
func (s *Server) WithBindings(val BindingsObject) *Server {
	s.Bindings = &val
	return s
}

// BindingsEns ensures returned Bindings is not nil.
func (s *Server) BindingsEns() *BindingsObject {
	if s.Bindings == nil {
		s.Bindings = new(BindingsObject)
	}

	return s.Bindings
}

// WithMapOfAnything sets MapOfAnything value.
func (s *Server) WithMapOfAnything(val map[string]interface{}) *Server {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *Server) WithMapOfAnythingItem(key string, val interface{}) *Server {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalServer Server

var knownKeysServer = []string{
	"$ref",
	"url",
	"description",
	"protocol",
	"protocolVersion",
	"variables",
	"security",
	"bindings",
}

// UnmarshalJSON decodes JSON.
func (s *Server) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalServer(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysServer {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Server: %v", offendingKeys)
	}

	*s = Server(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s Server) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalServer(s), s.MapOfAnything)
}

// ServerVariable structure is generated from "#/definitions/serverVariable".
//
// An object representing a Server Variable for server URL template substitution.
type ServerVariable struct {
	Enum          []string               `json:"enum,omitempty"`
	Default       *string                `json:"default,omitempty"`
	Description   *string                `json:"description,omitempty"`
	Examples      []string               `json:"examples,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithEnum sets Enum value.
func (s *ServerVariable) WithEnum(val ...string) *ServerVariable {
	s.Enum = val
	return s
}

// WithDefault sets Default value.
func (s *ServerVariable) WithDefault(val string) *ServerVariable {
	s.Default = &val
	return s
}

// WithDescription sets Description value.
func (s *ServerVariable) WithDescription(val string) *ServerVariable {
	s.Description = &val
	return s
}

// WithExamples sets Examples value.
func (s *ServerVariable) WithExamples(val ...string) *ServerVariable {
	s.Examples = val
	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *ServerVariable) WithMapOfAnything(val map[string]interface{}) *ServerVariable {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *ServerVariable) WithMapOfAnythingItem(key string, val interface{}) *ServerVariable {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalServerVariable ServerVariable

var knownKeysServerVariable = []string{
	"enum",
	"default",
	"description",
	"examples",
}

// UnmarshalJSON decodes JSON.
func (s *ServerVariable) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalServerVariable(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysServerVariable {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in ServerVariable: %v", offendingKeys)
	}

	*s = ServerVariable(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s ServerVariable) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalServerVariable(s), s.MapOfAnything)
}

// BindingsObject structure is generated from "#/definitions/bindingsObject".
type BindingsObject struct {
	HTTP                 *interface{}           `json:"http,omitempty"`
	Ws                   *interface{}           `json:"ws,omitempty"`
	Amqp                 *interface{}           `json:"amqp,omitempty"`
	Amqp1                *interface{}           `json:"amqp1,omitempty"`
	Mqtt                 *interface{}           `json:"mqtt,omitempty"`
	Mqtt5                *interface{}           `json:"mqtt5,omitempty"`
	Kafka                *interface{}           `json:"kafka,omitempty"`
	Anypointmq           *interface{}           `json:"anypointmq,omitempty"`
	Nats                 *interface{}           `json:"nats,omitempty"`
	Jms                  *interface{}           `json:"jms,omitempty"`
	Sns                  *interface{}           `json:"sns,omitempty"`
	Sqs                  *interface{}           `json:"sqs,omitempty"`
	Stomp                *interface{}           `json:"stomp,omitempty"`
	Redis                *interface{}           `json:"redis,omitempty"`
	Ibmmq                *interface{}           `json:"ibmmq,omitempty"`
	Solace               *interface{}           `json:"solace,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                    // All unmatched properties.
}

// WithHTTP sets HTTP value.
func (b *BindingsObject) WithHTTP(val interface{}) *BindingsObject {
	b.HTTP = &val
	return b
}

// WithWs sets Ws value.
func (b *BindingsObject) WithWs(val interface{}) *BindingsObject {
	b.Ws = &val
	return b
}

// WithAmqp sets Amqp value.
func (b *BindingsObject) WithAmqp(val interface{}) *BindingsObject {
	b.Amqp = &val
	return b
}

// WithAmqp1 sets Amqp1 value.
func (b *BindingsObject) WithAmqp1(val interface{}) *BindingsObject {
	b.Amqp1 = &val
	return b
}

// WithMqtt sets Mqtt value.
func (b *BindingsObject) WithMqtt(val interface{}) *BindingsObject {
	b.Mqtt = &val
	return b
}

// WithMqtt5 sets Mqtt5 value.
func (b *BindingsObject) WithMqtt5(val interface{}) *BindingsObject {
	b.Mqtt5 = &val
	return b
}

// WithKafka sets Kafka value.
func (b *BindingsObject) WithKafka(val interface{}) *BindingsObject {
	b.Kafka = &val
	return b
}

// WithAnypointmq sets Anypointmq value.
func (b *BindingsObject) WithAnypointmq(val interface{}) *BindingsObject {
	b.Anypointmq = &val
	return b
}

// WithNats sets Nats value.
func (b *BindingsObject) WithNats(val interface{}) *BindingsObject {
	b.Nats = &val
	return b
}

// WithJms sets Jms value.
func (b *BindingsObject) WithJms(val interface{}) *BindingsObject {
	b.Jms = &val
	return b
}

// WithSns sets Sns value.
func (b *BindingsObject) WithSns(val interface{}) *BindingsObject {
	b.Sns = &val
	return b
}

// WithSqs sets Sqs value.
func (b *BindingsObject) WithSqs(val interface{}) *BindingsObject {
	b.Sqs = &val
	return b
}

// WithStomp sets Stomp value.
func (b *BindingsObject) WithStomp(val interface{}) *BindingsObject {
	b.Stomp = &val
	return b
}

// WithRedis sets Redis value.
func (b *BindingsObject) WithRedis(val interface{}) *BindingsObject {
	b.Redis = &val
	return b
}

// WithIbmmq sets Ibmmq value.
func (b *BindingsObject) WithIbmmq(val interface{}) *BindingsObject {
	b.Ibmmq = &val
	return b
}

// WithSolace sets Solace value.
func (b *BindingsObject) WithSolace(val interface{}) *BindingsObject {
	b.Solace = &val
	return b
}

// WithAdditionalProperties sets AdditionalProperties value.
func (b *BindingsObject) WithAdditionalProperties(val map[string]interface{}) *BindingsObject {
	b.AdditionalProperties = val
	return b
}

// WithAdditionalPropertiesItem sets AdditionalProperties item value.
func (b *BindingsObject) WithAdditionalPropertiesItem(key string, val interface{}) *BindingsObject {
	if b.AdditionalProperties == nil {
		b.AdditionalProperties = make(map[string]interface{}, 1)
	}

	b.AdditionalProperties[key] = val

	return b
}

type marshalBindingsObject BindingsObject

var knownKeysBindingsObject = []string{
	"http",
	"ws",
	"amqp",
	"amqp1",
	"mqtt",
	"mqtt5",
	"kafka",
	"anypointmq",
	"nats",
	"jms",
	"sns",
	"sqs",
	"stomp",
	"redis",
	"ibmmq",
	"solace",
}

// UnmarshalJSON decodes JSON.
func (b *BindingsObject) UnmarshalJSON(data []byte) error {
	var err error

	mb := marshalBindingsObject(*b)

	err = json.Unmarshal(data, &mb)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if mb.HTTP == nil {
		if _, ok := rawMap["http"]; ok {
			var v interface{}
			mb.HTTP = &v
		}
	}

	if mb.Ws == nil {
		if _, ok := rawMap["ws"]; ok {
			var v interface{}
			mb.Ws = &v
		}
	}

	if mb.Amqp == nil {
		if _, ok := rawMap["amqp"]; ok {
			var v interface{}
			mb.Amqp = &v
		}
	}

	if mb.Amqp1 == nil {
		if _, ok := rawMap["amqp1"]; ok {
			var v interface{}
			mb.Amqp1 = &v
		}
	}

	if mb.Mqtt == nil {
		if _, ok := rawMap["mqtt"]; ok {
			var v interface{}
			mb.Mqtt = &v
		}
	}

	if mb.Mqtt5 == nil {
		if _, ok := rawMap["mqtt5"]; ok {
			var v interface{}
			mb.Mqtt5 = &v
		}
	}

	if mb.Kafka == nil {
		if _, ok := rawMap["kafka"]; ok {
			var v interface{}
			mb.Kafka = &v
		}
	}

	if mb.Anypointmq == nil {
		if _, ok := rawMap["anypointmq"]; ok {
			var v interface{}
			mb.Anypointmq = &v
		}
	}

	if mb.Nats == nil {
		if _, ok := rawMap["nats"]; ok {
			var v interface{}
			mb.Nats = &v
		}
	}

	if mb.Jms == nil {
		if _, ok := rawMap["jms"]; ok {
			var v interface{}
			mb.Jms = &v
		}
	}

	if mb.Sns == nil {
		if _, ok := rawMap["sns"]; ok {
			var v interface{}
			mb.Sns = &v
		}
	}

	if mb.Sqs == nil {
		if _, ok := rawMap["sqs"]; ok {
			var v interface{}
			mb.Sqs = &v
		}
	}

	if mb.Stomp == nil {
		if _, ok := rawMap["stomp"]; ok {
			var v interface{}
			mb.Stomp = &v
		}
	}

	if mb.Redis == nil {
		if _, ok := rawMap["redis"]; ok {
			var v interface{}
			mb.Redis = &v
		}
	}

	if mb.Ibmmq == nil {
		if _, ok := rawMap["ibmmq"]; ok {
			var v interface{}
			mb.Ibmmq = &v
		}
	}

	if mb.Solace == nil {
		if _, ok := rawMap["solace"]; ok {
			var v interface{}
			mb.Solace = &v
		}
	}

	for _, key := range knownKeysBindingsObject {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mb.AdditionalProperties == nil {
			mb.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mb.AdditionalProperties[key] = val
	}

	*b = BindingsObject(mb)

	return nil
}

// MarshalJSON encodes JSON.
func (b BindingsObject) MarshalJSON() ([]byte, error) {
	if len(b.AdditionalProperties) == 0 {
		return json.Marshal(marshalBindingsObject(b))
	}

	return marshalUnion(marshalBindingsObject(b), b.AdditionalProperties)
}

// ChannelItem structure is generated from "#/definitions/channelItem".
type ChannelItem struct {
	Ref           *string                `json:"$ref,omitempty"`        // Format: uri-reference.
	Parameters    map[string]Parameter   `json:"parameters,omitempty"`
	Description   *string                `json:"description,omitempty"` // A description of the channel.
	Servers       []string               `json:"servers,omitempty"`     // The names of the servers on which this channel is available. If absent or empty then this channel must be available on all servers.
	Publish       *Operation             `json:"publish,omitempty"`
	Subscribe     *Operation             `json:"subscribe,omitempty"`
	Bindings      *BindingsObject        `json:"bindings,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithRef sets Ref value.
func (c *ChannelItem) WithRef(val string) *ChannelItem {
	c.Ref = &val
	return c
}

// WithParameters sets Parameters value.
func (c *ChannelItem) WithParameters(val map[string]Parameter) *ChannelItem {
	c.Parameters = val
	return c
}

// WithParametersItem sets Parameters item value.
func (c *ChannelItem) WithParametersItem(key string, val Parameter) *ChannelItem {
	if c.Parameters == nil {
		c.Parameters = make(map[string]Parameter, 1)
	}

	c.Parameters[key] = val

	return c
}

// WithDescription sets Description value.
func (c *ChannelItem) WithDescription(val string) *ChannelItem {
	c.Description = &val
	return c
}

// WithServers sets Servers value.
func (c *ChannelItem) WithServers(val ...string) *ChannelItem {
	c.Servers = val
	return c
}

// WithPublish sets Publish value.
func (c *ChannelItem) WithPublish(val Operation) *ChannelItem {
	c.Publish = &val
	return c
}

// PublishEns ensures returned Publish is not nil.
func (c *ChannelItem) PublishEns() *Operation {
	if c.Publish == nil {
		c.Publish = new(Operation)
	}

	return c.Publish
}

// WithSubscribe sets Subscribe value.
func (c *ChannelItem) WithSubscribe(val Operation) *ChannelItem {
	c.Subscribe = &val
	return c
}

// SubscribeEns ensures returned Subscribe is not nil.
func (c *ChannelItem) SubscribeEns() *Operation {
	if c.Subscribe == nil {
		c.Subscribe = new(Operation)
	}

	return c.Subscribe
}

// WithBindings sets Bindings value.
func (c *ChannelItem) WithBindings(val BindingsObject) *ChannelItem {
	c.Bindings = &val
	return c
}

// BindingsEns ensures returned Bindings is not nil.
func (c *ChannelItem) BindingsEns() *BindingsObject {
	if c.Bindings == nil {
		c.Bindings = new(BindingsObject)
	}

	return c.Bindings
}

// WithMapOfAnything sets MapOfAnything value.
func (c *ChannelItem) WithMapOfAnything(val map[string]interface{}) *ChannelItem {
	c.MapOfAnything = val
	return c
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (c *ChannelItem) WithMapOfAnythingItem(key string, val interface{}) *ChannelItem {
	if c.MapOfAnything == nil {
		c.MapOfAnything = make(map[string]interface{}, 1)
	}

	c.MapOfAnything[key] = val

	return c
}

type marshalChannelItem ChannelItem

var knownKeysChannelItem = []string{
	"$ref",
	"parameters",
	"description",
	"servers",
	"publish",
	"subscribe",
	"deprecated",
	"bindings",
}

// UnmarshalJSON decodes JSON.
func (c *ChannelItem) UnmarshalJSON(data []byte) error {
	var err error

	mc := marshalChannelItem(*c)

	err = json.Unmarshal(data, &mc)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysChannelItem {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mc.MapOfAnything == nil {
				mc.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mc.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in ChannelItem: %v", offendingKeys)
	}

	*c = ChannelItem(mc)

	return nil
}

// MarshalJSON encodes JSON.
func (c ChannelItem) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalChannelItem(c), c.MapOfAnything)
}

// Parameter structure is generated from "#/definitions/parameter".
type Parameter struct {
	Description   *string                `json:"description,omitempty"` // A brief description of the parameter. This could contain examples of use. GitHub Flavored Markdown is allowed.
	Schema        jsonschema.Schema      `json:"schema,omitempty"`
	// A runtime expression that specifies the location of the parameter value.
	// Value must match pattern: `^\$message\.(header|payload)#(\/(([^\/~])|(~[01]))*)*`.
	Location      *string                `json:"location,omitempty"`
	Ref           *string                `json:"$ref,omitempty"`        // Format: uri-reference.
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (p *Parameter) WithDescription(val string) *Parameter {
	p.Description = &val
	return p
}

// WithSchema sets Schema value.
func (p *Parameter) WithSchema(val jsonschema.Schema) *Parameter {
	p.Schema = val
	return p
}

// WithLocation sets Location value.
func (p *Parameter) WithLocation(val string) *Parameter {
	p.Location = &val
	return p
}

// WithRef sets Ref value.
func (p *Parameter) WithRef(val string) *Parameter {
	p.Ref = &val
	return p
}

// WithMapOfAnything sets MapOfAnything value.
func (p *Parameter) WithMapOfAnything(val map[string]interface{}) *Parameter {
	p.MapOfAnything = val
	return p
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (p *Parameter) WithMapOfAnythingItem(key string, val interface{}) *Parameter {
	if p.MapOfAnything == nil {
		p.MapOfAnything = make(map[string]interface{}, 1)
	}

	p.MapOfAnything[key] = val

	return p
}

type marshalParameter Parameter

var knownKeysParameter = []string{
	"description",
	"schema",
	"location",
	"$ref",
}

// UnmarshalJSON decodes JSON.
func (p *Parameter) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalParameter(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysParameter {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mp.MapOfAnything == nil {
				mp.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mp.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Parameter: %v", offendingKeys)
	}

	*p = Parameter(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p Parameter) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalParameter(p), p.MapOfAnything)
}

// Operation structure is generated from "#/definitions/operation".
type Operation struct {
	Traits        []OperationTraitsItems `json:"traits,omitempty"`
	Summary       *string                `json:"summary,omitempty"`
	Description   *string                `json:"description,omitempty"`
	Tags          []Tag                  `json:"tags,omitempty"`
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	ID            *string                `json:"operationId,omitempty"`
	Bindings      *BindingsObject        `json:"bindings,omitempty"`
	Message       *MessageChoices        `json:"message,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithTraits sets Traits value.
func (o *Operation) WithTraits(val ...OperationTraitsItems) *Operation {
	o.Traits = val
	return o
}

// WithSummary sets Summary value.
func (o *Operation) WithSummary(val string) *Operation {
	o.Summary = &val
	return o
}

// WithDescription sets Description value.
func (o *Operation) WithDescription(val string) *Operation {
	o.Description = &val
	return o
}

// WithTags sets Tags value.
func (o *Operation) WithTags(val ...Tag) *Operation {
	o.Tags = val
	return o
}

// WithExternalDocs sets ExternalDocs value.
func (o *Operation) WithExternalDocs(val ExternalDocs) *Operation {
	o.ExternalDocs = &val
	return o
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (o *Operation) ExternalDocsEns() *ExternalDocs {
	if o.ExternalDocs == nil {
		o.ExternalDocs = new(ExternalDocs)
	}

	return o.ExternalDocs
}

// WithID sets ID value.
func (o *Operation) WithID(val string) *Operation {
	o.ID = &val
	return o
}

// WithBindings sets Bindings value.
func (o *Operation) WithBindings(val BindingsObject) *Operation {
	o.Bindings = &val
	return o
}

// BindingsEns ensures returned Bindings is not nil.
func (o *Operation) BindingsEns() *BindingsObject {
	if o.Bindings == nil {
		o.Bindings = new(BindingsObject)
	}

	return o.Bindings
}

// WithMessage sets Message value.
func (o *Operation) WithMessage(val MessageChoices) *Operation {
	o.Message = &val
	return o
}

// MessageEns ensures returned Message is not nil.
func (o *Operation) MessageEns() *MessageChoices {
	if o.Message == nil {
		o.Message = new(MessageChoices)
	}

	return o.Message
}

// WithMapOfAnything sets MapOfAnything value.
func (o *Operation) WithMapOfAnything(val map[string]interface{}) *Operation {
	o.MapOfAnything = val
	return o
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (o *Operation) WithMapOfAnythingItem(key string, val interface{}) *Operation {
	if o.MapOfAnything == nil {
		o.MapOfAnything = make(map[string]interface{}, 1)
	}

	o.MapOfAnything[key] = val

	return o
}

type marshalOperation Operation

var knownKeysOperation = []string{
	"traits",
	"summary",
	"description",
	"tags",
	"externalDocs",
	"operationId",
	"bindings",
	"message",
}

// UnmarshalJSON decodes JSON.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOperation(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysOperation {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Operation: %v", offendingKeys)
	}

	*o = Operation(mo)

	return nil
}

// MarshalJSON encodes JSON.
func (o Operation) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalOperation(o), o.MapOfAnything)
}

// Reference structure is generated from "#/definitions/Reference".
type Reference struct {
	// Format: uri-reference.
	// Required.
	Ref string `json:"$ref"`
}

// WithRef sets Ref value.
func (r *Reference) WithRef(val string) *Reference {
	r.Ref = val
	return r
}

// OperationTrait structure is generated from "#/definitions/operationTrait".
type OperationTrait struct {
	Summary       *string                `json:"summary,omitempty"`
	Description   *string                `json:"description,omitempty"`
	Tags          []Tag                  `json:"tags,omitempty"`
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	OperationID   *string                `json:"operationId,omitempty"`
	Bindings      *BindingsObject        `json:"bindings,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithSummary sets Summary value.
func (o *OperationTrait) WithSummary(val string) *OperationTrait {
	o.Summary = &val
	return o
}

// WithDescription sets Description value.
func (o *OperationTrait) WithDescription(val string) *OperationTrait {
	o.Description = &val
	return o
}

// WithTags sets Tags value.
func (o *OperationTrait) WithTags(val ...Tag) *OperationTrait {
	o.Tags = val
	return o
}

// WithExternalDocs sets ExternalDocs value.
func (o *OperationTrait) WithExternalDocs(val ExternalDocs) *OperationTrait {
	o.ExternalDocs = &val
	return o
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (o *OperationTrait) ExternalDocsEns() *ExternalDocs {
	if o.ExternalDocs == nil {
		o.ExternalDocs = new(ExternalDocs)
	}

	return o.ExternalDocs
}

// WithOperationID sets OperationID value.
func (o *OperationTrait) WithOperationID(val string) *OperationTrait {
	o.OperationID = &val
	return o
}

// WithBindings sets Bindings value.
func (o *OperationTrait) WithBindings(val BindingsObject) *OperationTrait {
	o.Bindings = &val
	return o
}

// BindingsEns ensures returned Bindings is not nil.
func (o *OperationTrait) BindingsEns() *BindingsObject {
	if o.Bindings == nil {
		o.Bindings = new(BindingsObject)
	}

	return o.Bindings
}

// WithMapOfAnything sets MapOfAnything value.
func (o *OperationTrait) WithMapOfAnything(val map[string]interface{}) *OperationTrait {
	o.MapOfAnything = val
	return o
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (o *OperationTrait) WithMapOfAnythingItem(key string, val interface{}) *OperationTrait {
	if o.MapOfAnything == nil {
		o.MapOfAnything = make(map[string]interface{}, 1)
	}

	o.MapOfAnything[key] = val

	return o
}

type marshalOperationTrait OperationTrait

var knownKeysOperationTrait = []string{
	"summary",
	"description",
	"tags",
	"externalDocs",
	"operationId",
	"bindings",
}

// UnmarshalJSON decodes JSON.
func (o *OperationTrait) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOperationTrait(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysOperationTrait {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in OperationTrait: %v", offendingKeys)
	}

	*o = OperationTrait(mo)

	return nil
}

// MarshalJSON encodes JSON.
func (o OperationTrait) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalOperationTrait(o), o.MapOfAnything)
}

// Tag structure is generated from "#/definitions/tag".
type Tag struct {
	Name          string                 `json:"name"`                   // Required.
	Description   *string                `json:"description,omitempty"`
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"` // Information about external documentation.
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithName sets Name value.
func (t *Tag) WithName(val string) *Tag {
	t.Name = val
	return t
}

// WithDescription sets Description value.
func (t *Tag) WithDescription(val string) *Tag {
	t.Description = &val
	return t
}

// WithExternalDocs sets ExternalDocs value.
func (t *Tag) WithExternalDocs(val ExternalDocs) *Tag {
	t.ExternalDocs = &val
	return t
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (t *Tag) ExternalDocsEns() *ExternalDocs {
	if t.ExternalDocs == nil {
		t.ExternalDocs = new(ExternalDocs)
	}

	return t.ExternalDocs
}

// WithMapOfAnything sets MapOfAnything value.
func (t *Tag) WithMapOfAnything(val map[string]interface{}) *Tag {
	t.MapOfAnything = val
	return t
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (t *Tag) WithMapOfAnythingItem(key string, val interface{}) *Tag {
	if t.MapOfAnything == nil {
		t.MapOfAnything = make(map[string]interface{}, 1)
	}

	t.MapOfAnything[key] = val

	return t
}

type marshalTag Tag

var knownKeysTag = []string{
	"name",
	"description",
	"externalDocs",
}

// UnmarshalJSON decodes JSON.
func (t *Tag) UnmarshalJSON(data []byte) error {
	var err error

	mt := marshalTag(*t)

	err = json.Unmarshal(data, &mt)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysTag {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mt.MapOfAnything == nil {
				mt.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mt.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Tag: %v", offendingKeys)
	}

	*t = Tag(mt)

	return nil
}

// MarshalJSON encodes JSON.
func (t Tag) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalTag(t), t.MapOfAnything)
}

// ExternalDocs structure is generated from "#/definitions/externalDocs".
//
// information about external documentation.
type ExternalDocs struct {
	Description   *string                `json:"description,omitempty"`
	// Format: uri.
	// Required.
	URL           string                 `json:"url"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (e *ExternalDocs) WithDescription(val string) *ExternalDocs {
	e.Description = &val
	return e
}

// WithURL sets URL value.
func (e *ExternalDocs) WithURL(val string) *ExternalDocs {
	e.URL = val
	return e
}

// WithMapOfAnything sets MapOfAnything value.
func (e *ExternalDocs) WithMapOfAnything(val map[string]interface{}) *ExternalDocs {
	e.MapOfAnything = val
	return e
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (e *ExternalDocs) WithMapOfAnythingItem(key string, val interface{}) *ExternalDocs {
	if e.MapOfAnything == nil {
		e.MapOfAnything = make(map[string]interface{}, 1)
	}

	e.MapOfAnything[key] = val

	return e
}

type marshalExternalDocs ExternalDocs

var knownKeysExternalDocs = []string{
	"description",
	"url",
}

// UnmarshalJSON decodes JSON.
func (e *ExternalDocs) UnmarshalJSON(data []byte) error {
	var err error

	me := marshalExternalDocs(*e)

	err = json.Unmarshal(data, &me)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysExternalDocs {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if me.MapOfAnything == nil {
				me.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			me.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in ExternalDocs: %v", offendingKeys)
	}

	*e = ExternalDocs(me)

	return nil
}

// MarshalJSON encodes JSON.
func (e ExternalDocs) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalExternalDocs(e), e.MapOfAnything)
}

// OperationTraitsItems structure is generated from "#/definitions/operation->traits->items".
type OperationTraitsItems struct {
	Reference       *Reference      `json:"-"`
	OperationTrait  *OperationTrait `json:"-"`
	SliceOfAnything []interface{}   `json:"-"`
}

// WithReference sets Reference value.
func (o *OperationTraitsItems) WithReference(val Reference) *OperationTraitsItems {
	o.Reference = &val
	return o
}

// ReferenceEns ensures returned Reference is not nil.
func (o *OperationTraitsItems) ReferenceEns() *Reference {
	if o.Reference == nil {
		o.Reference = new(Reference)
	}

	return o.Reference
}

// WithOperationTrait sets OperationTrait value.
func (o *OperationTraitsItems) WithOperationTrait(val OperationTrait) *OperationTraitsItems {
	o.OperationTrait = &val
	return o
}

// OperationTraitEns ensures returned OperationTrait is not nil.
func (o *OperationTraitsItems) OperationTraitEns() *OperationTrait {
	if o.OperationTrait == nil {
		o.OperationTrait = new(OperationTrait)
	}

	return o.OperationTrait
}

// WithSliceOfAnything sets SliceOfAnything value.
func (o *OperationTraitsItems) WithSliceOfAnything(val ...interface{}) *OperationTraitsItems {
	o.SliceOfAnything = val
	return o
}

// UnmarshalJSON decodes JSON.
func (o *OperationTraitsItems) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 3)
	oneOfValid := 0

	err = json.Unmarshal(data, &o.Reference)
	if err != nil {
		oneOfErrors["Reference"] = err
		o.Reference = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &o.OperationTrait)
	if err != nil {
		oneOfErrors["OperationTrait"] = err
		o.OperationTrait = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &o.SliceOfAnything)
	if err != nil {
		oneOfErrors["SliceOfAnything"] = err
		o.SliceOfAnything = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for OperationTraitsItems with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (o OperationTraitsItems) MarshalJSON() ([]byte, error) {
	return marshalUnion(o.Reference, o.OperationTrait, o.SliceOfAnything)
}

// MessageOptions structure is generated from "#/definitions/MessageOptions".
type MessageOptions struct {
	OneOf []MessageChoices `json:"oneOf"` // Required.
}

// WithOneOf sets OneOf value.
func (m *MessageOptions) WithOneOf(val ...MessageChoices) *MessageOptions {
	m.OneOf = val
	return m
}

type marshalMessageOptions MessageOptions

var knownKeysMessageOptions = []string{
	"oneOf",
}

// UnmarshalJSON decodes JSON.
func (m *MessageOptions) UnmarshalJSON(data []byte) error {
	var err error

	mm := marshalMessageOptions(*m)

	err = json.Unmarshal(data, &mm)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysMessageOptions {
		delete(rawMap, key)
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in MessageOptions: %v", offendingKeys)
	}

	*m = MessageOptions(mm)

	return nil
}


// Message structure is generated from "#/definitions/Message".
type Message struct {
	SchemaFormat  *string                `json:"schemaFormat,omitempty"`
	ContentType   *string                `json:"contentType,omitempty"`
	Headers       *MessageHeaders        `json:"headers,omitempty"`
	Payload       *interface{}           `json:"payload,omitempty"`
	CorrelationID *MessageCorrelationID  `json:"correlationId,omitempty"`
	Tags          []Tag                  `json:"tags,omitempty"`
	Summary       *string                `json:"summary,omitempty"`       // A brief summary of the message.
	Name          *string                `json:"name,omitempty"`          // Name of the message.
	Title         *string                `json:"title,omitempty"`         // A human-friendly title for the message.
	Description   *string                `json:"description,omitempty"`   // A longer description of the message. CommonMark is allowed.
	ExternalDocs  *ExternalDocs          `json:"externalDocs,omitempty"`  // Information about external documentation.
	Examples      []MessageExamplesItems `json:"examples,omitempty"`
	Bindings      *BindingsObject        `json:"bindings,omitempty"`
	Traits        []MessageTraitsItems   `json:"traits,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                       // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithSchemaFormat sets SchemaFormat value.
func (m *Message) WithSchemaFormat(val string) *Message {
	m.SchemaFormat = &val
	return m
}

// WithContentType sets ContentType value.
func (m *Message) WithContentType(val string) *Message {
	m.ContentType = &val
	return m
}

// WithHeaders sets Headers value.
func (m *Message) WithHeaders(val MessageHeaders) *Message {
	m.Headers = &val
	return m
}

// HeadersEns ensures returned Headers is not nil.
func (m *Message) HeadersEns() *MessageHeaders {
	if m.Headers == nil {
		m.Headers = new(MessageHeaders)
	}

	return m.Headers
}

// WithPayload sets Payload value.
func (m *Message) WithPayload(val interface{}) *Message {
	m.Payload = &val
	return m
}

// WithCorrelationID sets CorrelationID value.
func (m *Message) WithCorrelationID(val MessageCorrelationID) *Message {
	m.CorrelationID = &val
	return m
}

// CorrelationIDEns ensures returned CorrelationID is not nil.
func (m *Message) CorrelationIDEns() *MessageCorrelationID {
	if m.CorrelationID == nil {
		m.CorrelationID = new(MessageCorrelationID)
	}

	return m.CorrelationID
}

// WithTags sets Tags value.
func (m *Message) WithTags(val ...Tag) *Message {
	m.Tags = val
	return m
}

// WithSummary sets Summary value.
func (m *Message) WithSummary(val string) *Message {
	m.Summary = &val
	return m
}

// WithName sets Name value.
func (m *Message) WithName(val string) *Message {
	m.Name = &val
	return m
}

// WithTitle sets Title value.
func (m *Message) WithTitle(val string) *Message {
	m.Title = &val
	return m
}

// WithDescription sets Description value.
func (m *Message) WithDescription(val string) *Message {
	m.Description = &val
	return m
}

// WithExternalDocs sets ExternalDocs value.
func (m *Message) WithExternalDocs(val ExternalDocs) *Message {
	m.ExternalDocs = &val
	return m
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (m *Message) ExternalDocsEns() *ExternalDocs {
	if m.ExternalDocs == nil {
		m.ExternalDocs = new(ExternalDocs)
	}

	return m.ExternalDocs
}

// WithExamples sets Examples value.
func (m *Message) WithExamples(val ...MessageExamplesItems) *Message {
	m.Examples = val
	return m
}

// WithBindings sets Bindings value.
func (m *Message) WithBindings(val BindingsObject) *Message {
	m.Bindings = &val
	return m
}

// BindingsEns ensures returned Bindings is not nil.
func (m *Message) BindingsEns() *BindingsObject {
	if m.Bindings == nil {
		m.Bindings = new(BindingsObject)
	}

	return m.Bindings
}

// WithTraits sets Traits value.
func (m *Message) WithTraits(val ...MessageTraitsItems) *Message {
	m.Traits = val
	return m
}

// WithMapOfAnything sets MapOfAnything value.
func (m *Message) WithMapOfAnything(val map[string]interface{}) *Message {
	m.MapOfAnything = val
	return m
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (m *Message) WithMapOfAnythingItem(key string, val interface{}) *Message {
	if m.MapOfAnything == nil {
		m.MapOfAnything = make(map[string]interface{}, 1)
	}

	m.MapOfAnything[key] = val

	return m
}

type marshalMessage Message

var knownKeysMessage = []string{
	"schemaFormat",
	"contentType",
	"headers",
	"payload",
	"correlationId",
	"tags",
	"summary",
	"name",
	"title",
	"description",
	"externalDocs",
	"deprecated",
	"examples",
	"bindings",
	"traits",
}

// UnmarshalJSON decodes JSON.
func (m *Message) UnmarshalJSON(data []byte) error {
	var err error

	mm := marshalMessage(*m)

	err = json.Unmarshal(data, &mm)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if mm.Payload == nil {
		if _, ok := rawMap["payload"]; ok {
			var v interface{}
			mm.Payload = &v
		}
	}

	for _, key := range knownKeysMessage {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mm.MapOfAnything == nil {
				mm.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mm.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Message: %v", offendingKeys)
	}

	*m = Message(mm)

	return nil
}

// MarshalJSON encodes JSON.
func (m Message) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalMessage(m), m.MapOfAnything)
}

// MessageHeadersAllOf1 structure is generated from "#/definitions/Message->headers/allOf/1".
type MessageHeadersAllOf1 struct {

}

// UnmarshalJSON decodes JSON.
func (m *MessageHeadersAllOf1) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"object"` {
		return fmt.Errorf(`bad const value for "type" ("object" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	return nil
}

var (
	// constMessageHeadersAllOf1 is unconditionally added to JSON.
	constMessageHeadersAllOf1 = json.RawMessage(`{"type":"object"}`)
)

// MarshalJSON encodes JSON.
func (m MessageHeadersAllOf1) MarshalJSON() ([]byte, error) {
	return marshalUnion(constMessageHeadersAllOf1)
}

// MessageHeaders structure is generated from "#/definitions/Message->headers".
type MessageHeaders struct {
	Schema *jsonschema.Schema    `json:"-"`
	AllOf1 *MessageHeadersAllOf1 `json:"-"`
}

// WithSchema sets Schema value.
func (m *MessageHeaders) WithSchema(val jsonschema.Schema) *MessageHeaders {
	m.Schema = &val
	return m
}

// WithAllOf1 sets AllOf1 value.
func (m *MessageHeaders) WithAllOf1(val MessageHeadersAllOf1) *MessageHeaders {
	m.AllOf1 = &val
	return m
}

// AllOf1Ens ensures returned AllOf1 is not nil.
func (m *MessageHeaders) AllOf1Ens() *MessageHeadersAllOf1 {
	if m.AllOf1 == nil {
		m.AllOf1 = new(MessageHeadersAllOf1)
	}

	return m.AllOf1
}

// UnmarshalJSON decodes JSON.
func (m *MessageHeaders) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &m.Schema)
	if err != nil {
		return err
	}

	err = json.Unmarshal(data, &m.AllOf1)
	if err != nil {
		return err
	}

	return nil
}

// MarshalJSON encodes JSON.
func (m MessageHeaders) MarshalJSON() ([]byte, error) {
	return marshalUnion(m.Schema, m.AllOf1)
}

// CorrelationID structure is generated from "#/definitions/correlationId".
type CorrelationID struct {
	Description   *string                `json:"description,omitempty"` // A optional description of the correlation ID. GitHub Flavored Markdown is allowed.
	// A runtime expression that specifies the location of the correlation ID.
	// Value must match pattern: `^\$message\.(header|payload)#(\/(([^\/~])|(~[01]))*)*`.
	// Required.
	Location      string                 `json:"location"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (c *CorrelationID) WithDescription(val string) *CorrelationID {
	c.Description = &val
	return c
}

// WithLocation sets Location value.
func (c *CorrelationID) WithLocation(val string) *CorrelationID {
	c.Location = val
	return c
}

// WithMapOfAnything sets MapOfAnything value.
func (c *CorrelationID) WithMapOfAnything(val map[string]interface{}) *CorrelationID {
	c.MapOfAnything = val
	return c
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (c *CorrelationID) WithMapOfAnythingItem(key string, val interface{}) *CorrelationID {
	if c.MapOfAnything == nil {
		c.MapOfAnything = make(map[string]interface{}, 1)
	}

	c.MapOfAnything[key] = val

	return c
}

type marshalCorrelationID CorrelationID

var knownKeysCorrelationID = []string{
	"description",
	"location",
}

// UnmarshalJSON decodes JSON.
func (c *CorrelationID) UnmarshalJSON(data []byte) error {
	var err error

	mc := marshalCorrelationID(*c)

	err = json.Unmarshal(data, &mc)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysCorrelationID {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mc.MapOfAnything == nil {
				mc.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mc.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in CorrelationID: %v", offendingKeys)
	}

	*c = CorrelationID(mc)

	return nil
}

// MarshalJSON encodes JSON.
func (c CorrelationID) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalCorrelationID(c), c.MapOfAnything)
}

// MessageCorrelationID structure is generated from "#/definitions/Message->correlationId".
type MessageCorrelationID struct {
	Reference     *Reference     `json:"-"`
	CorrelationID *CorrelationID `json:"-"`
}

// WithReference sets Reference value.
func (m *MessageCorrelationID) WithReference(val Reference) *MessageCorrelationID {
	m.Reference = &val
	return m
}

// ReferenceEns ensures returned Reference is not nil.
func (m *MessageCorrelationID) ReferenceEns() *Reference {
	if m.Reference == nil {
		m.Reference = new(Reference)
	}

	return m.Reference
}

// WithCorrelationID sets CorrelationID value.
func (m *MessageCorrelationID) WithCorrelationID(val CorrelationID) *MessageCorrelationID {
	m.CorrelationID = &val
	return m
}

// CorrelationIDEns ensures returned CorrelationID is not nil.
func (m *MessageCorrelationID) CorrelationIDEns() *CorrelationID {
	if m.CorrelationID == nil {
		m.CorrelationID = new(CorrelationID)
	}

	return m.CorrelationID
}

// UnmarshalJSON decodes JSON.
func (m *MessageCorrelationID) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 2)
	oneOfValid := 0

	err = json.Unmarshal(data, &m.Reference)
	if err != nil {
		oneOfErrors["Reference"] = err
		m.Reference = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &m.CorrelationID)
	if err != nil {
		oneOfErrors["CorrelationID"] = err
		m.CorrelationID = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for MessageCorrelationID with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (m MessageCorrelationID) MarshalJSON() ([]byte, error) {
	return marshalUnion(m.Reference, m.CorrelationID)
}

// MessageExamplesItems structure is generated from "#/definitions/Message->examples->items".
type MessageExamplesItems struct {
	Name    *string                `json:"name,omitempty"`    // Machine readable name of the message example.
	Summary *string                `json:"summary,omitempty"` // A brief summary of the message example.
	Headers map[string]interface{} `json:"headers,omitempty"`
	Payload *interface{}           `json:"payload,omitempty"`
}

// WithName sets Name value.
func (m *MessageExamplesItems) WithName(val string) *MessageExamplesItems {
	m.Name = &val
	return m
}

// WithSummary sets Summary value.
func (m *MessageExamplesItems) WithSummary(val string) *MessageExamplesItems {
	m.Summary = &val
	return m
}

// WithHeaders sets Headers value.
func (m *MessageExamplesItems) WithHeaders(val map[string]interface{}) *MessageExamplesItems {
	m.Headers = val
	return m
}

// WithHeadersItem sets Headers item value.
func (m *MessageExamplesItems) WithHeadersItem(key string, val interface{}) *MessageExamplesItems {
	if m.Headers == nil {
		m.Headers = make(map[string]interface{}, 1)
	}

	m.Headers[key] = val

	return m
}

// WithPayload sets Payload value.
func (m *MessageExamplesItems) WithPayload(val interface{}) *MessageExamplesItems {
	m.Payload = &val
	return m
}

type marshalMessageExamplesItems MessageExamplesItems

var knownKeysMessageExamplesItems = []string{
	"name",
	"summary",
	"headers",
	"payload",
}

// UnmarshalJSON decodes JSON.
func (m *MessageExamplesItems) UnmarshalJSON(data []byte) error {
	var err error

	mm := marshalMessageExamplesItems(*m)

	err = json.Unmarshal(data, &mm)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if mm.Payload == nil {
		if _, ok := rawMap["payload"]; ok {
			var v interface{}
			mm.Payload = &v
		}
	}

	for _, key := range knownKeysMessageExamplesItems {
		delete(rawMap, key)
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in MessageExamplesItems: %v", offendingKeys)
	}

	*m = MessageExamplesItems(mm)

	return nil
}


// MessageTrait structure is generated from "#/definitions/messageTrait".
type MessageTrait struct {
	SchemaFormat  *string                    `json:"schemaFormat,omitempty"`
	ContentType   *string                    `json:"contentType,omitempty"`
	Headers       *MessageTraitHeaders       `json:"headers,omitempty"`
	CorrelationID *MessageTraitCorrelationID `json:"correlationId,omitempty"`
	Tags          []Tag                      `json:"tags,omitempty"`
	Summary       *string                    `json:"summary,omitempty"`       // A brief summary of the message.
	Name          *string                    `json:"name,omitempty"`          // Name of the message.
	Title         *string                    `json:"title,omitempty"`         // A human-friendly title for the message.
	Description   *string                    `json:"description,omitempty"`   // A longer description of the message. CommonMark is allowed.
	ExternalDocs  *ExternalDocs              `json:"externalDocs,omitempty"`  // Information about external documentation.
	Examples      []map[string]interface{}   `json:"examples,omitempty"`
	Bindings      *BindingsObject            `json:"bindings,omitempty"`
	MapOfAnything map[string]interface{}     `json:"-"`                       // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithSchemaFormat sets SchemaFormat value.
func (m *MessageTrait) WithSchemaFormat(val string) *MessageTrait {
	m.SchemaFormat = &val
	return m
}

// WithContentType sets ContentType value.
func (m *MessageTrait) WithContentType(val string) *MessageTrait {
	m.ContentType = &val
	return m
}

// WithHeaders sets Headers value.
func (m *MessageTrait) WithHeaders(val MessageTraitHeaders) *MessageTrait {
	m.Headers = &val
	return m
}

// HeadersEns ensures returned Headers is not nil.
func (m *MessageTrait) HeadersEns() *MessageTraitHeaders {
	if m.Headers == nil {
		m.Headers = new(MessageTraitHeaders)
	}

	return m.Headers
}

// WithCorrelationID sets CorrelationID value.
func (m *MessageTrait) WithCorrelationID(val MessageTraitCorrelationID) *MessageTrait {
	m.CorrelationID = &val
	return m
}

// CorrelationIDEns ensures returned CorrelationID is not nil.
func (m *MessageTrait) CorrelationIDEns() *MessageTraitCorrelationID {
	if m.CorrelationID == nil {
		m.CorrelationID = new(MessageTraitCorrelationID)
	}

	return m.CorrelationID
}

// WithTags sets Tags value.
func (m *MessageTrait) WithTags(val ...Tag) *MessageTrait {
	m.Tags = val
	return m
}

// WithSummary sets Summary value.
func (m *MessageTrait) WithSummary(val string) *MessageTrait {
	m.Summary = &val
	return m
}

// WithName sets Name value.
func (m *MessageTrait) WithName(val string) *MessageTrait {
	m.Name = &val
	return m
}

// WithTitle sets Title value.
func (m *MessageTrait) WithTitle(val string) *MessageTrait {
	m.Title = &val
	return m
}

// WithDescription sets Description value.
func (m *MessageTrait) WithDescription(val string) *MessageTrait {
	m.Description = &val
	return m
}

// WithExternalDocs sets ExternalDocs value.
func (m *MessageTrait) WithExternalDocs(val ExternalDocs) *MessageTrait {
	m.ExternalDocs = &val
	return m
}

// ExternalDocsEns ensures returned ExternalDocs is not nil.
func (m *MessageTrait) ExternalDocsEns() *ExternalDocs {
	if m.ExternalDocs == nil {
		m.ExternalDocs = new(ExternalDocs)
	}

	return m.ExternalDocs
}

// WithExamples sets Examples value.
func (m *MessageTrait) WithExamples(val ...map[string]interface{}) *MessageTrait {
	m.Examples = val
	return m
}

// WithBindings sets Bindings value.
func (m *MessageTrait) WithBindings(val BindingsObject) *MessageTrait {
	m.Bindings = &val
	return m
}

// BindingsEns ensures returned Bindings is not nil.
func (m *MessageTrait) BindingsEns() *BindingsObject {
	if m.Bindings == nil {
		m.Bindings = new(BindingsObject)
	}

	return m.Bindings
}

// WithMapOfAnything sets MapOfAnything value.
func (m *MessageTrait) WithMapOfAnything(val map[string]interface{}) *MessageTrait {
	m.MapOfAnything = val
	return m
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (m *MessageTrait) WithMapOfAnythingItem(key string, val interface{}) *MessageTrait {
	if m.MapOfAnything == nil {
		m.MapOfAnything = make(map[string]interface{}, 1)
	}

	m.MapOfAnything[key] = val

	return m
}

type marshalMessageTrait MessageTrait

var knownKeysMessageTrait = []string{
	"schemaFormat",
	"contentType",
	"headers",
	"correlationId",
	"tags",
	"summary",
	"name",
	"title",
	"description",
	"externalDocs",
	"deprecated",
	"examples",
	"bindings",
}

// UnmarshalJSON decodes JSON.
func (m *MessageTrait) UnmarshalJSON(data []byte) error {
	var err error

	mm := marshalMessageTrait(*m)

	err = json.Unmarshal(data, &mm)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysMessageTrait {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mm.MapOfAnything == nil {
				mm.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mm.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in MessageTrait: %v", offendingKeys)
	}

	*m = MessageTrait(mm)

	return nil
}

// MarshalJSON encodes JSON.
func (m MessageTrait) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalMessageTrait(m), m.MapOfAnything)
}

// MessageTraitHeadersAllOf1 structure is generated from "#/definitions/messageTrait->headers/allOf/1".
type MessageTraitHeadersAllOf1 struct {

}

// UnmarshalJSON decodes JSON.
func (m *MessageTraitHeadersAllOf1) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"object"` {
		return fmt.Errorf(`bad const value for "type" ("object" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	return nil
}

var (
	// constMessageTraitHeadersAllOf1 is unconditionally added to JSON.
	constMessageTraitHeadersAllOf1 = json.RawMessage(`{"type":"object"}`)
)

// MarshalJSON encodes JSON.
func (m MessageTraitHeadersAllOf1) MarshalJSON() ([]byte, error) {
	return marshalUnion(constMessageTraitHeadersAllOf1)
}

// MessageTraitHeaders structure is generated from "#/definitions/messageTrait->headers".
type MessageTraitHeaders struct {
	Schema *jsonschema.Schema         `json:"-"`
	AllOf1 *MessageTraitHeadersAllOf1 `json:"-"`
}

// WithSchema sets Schema value.
func (m *MessageTraitHeaders) WithSchema(val jsonschema.Schema) *MessageTraitHeaders {
	m.Schema = &val
	return m
}

// WithAllOf1 sets AllOf1 value.
func (m *MessageTraitHeaders) WithAllOf1(val MessageTraitHeadersAllOf1) *MessageTraitHeaders {
	m.AllOf1 = &val
	return m
}

// AllOf1Ens ensures returned AllOf1 is not nil.
func (m *MessageTraitHeaders) AllOf1Ens() *MessageTraitHeadersAllOf1 {
	if m.AllOf1 == nil {
		m.AllOf1 = new(MessageTraitHeadersAllOf1)
	}

	return m.AllOf1
}

// UnmarshalJSON decodes JSON.
func (m *MessageTraitHeaders) UnmarshalJSON(data []byte) error {
	var err error

	err = json.Unmarshal(data, &m.Schema)
	if err != nil {
		return err
	}

	err = json.Unmarshal(data, &m.AllOf1)
	if err != nil {
		return err
	}

	return nil
}

// MarshalJSON encodes JSON.
func (m MessageTraitHeaders) MarshalJSON() ([]byte, error) {
	return marshalUnion(m.Schema, m.AllOf1)
}

// MessageTraitCorrelationID structure is generated from "#/definitions/messageTrait->correlationId".
type MessageTraitCorrelationID struct {
	Reference     *Reference     `json:"-"`
	CorrelationID *CorrelationID `json:"-"`
}

// WithReference sets Reference value.
func (m *MessageTraitCorrelationID) WithReference(val Reference) *MessageTraitCorrelationID {
	m.Reference = &val
	return m
}

// ReferenceEns ensures returned Reference is not nil.
func (m *MessageTraitCorrelationID) ReferenceEns() *Reference {
	if m.Reference == nil {
		m.Reference = new(Reference)
	}

	return m.Reference
}

// WithCorrelationID sets CorrelationID value.
func (m *MessageTraitCorrelationID) WithCorrelationID(val CorrelationID) *MessageTraitCorrelationID {
	m.CorrelationID = &val
	return m
}

// CorrelationIDEns ensures returned CorrelationID is not nil.
func (m *MessageTraitCorrelationID) CorrelationIDEns() *CorrelationID {
	if m.CorrelationID == nil {
		m.CorrelationID = new(CorrelationID)
	}

	return m.CorrelationID
}

// UnmarshalJSON decodes JSON.
func (m *MessageTraitCorrelationID) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 2)
	oneOfValid := 0

	err = json.Unmarshal(data, &m.Reference)
	if err != nil {
		oneOfErrors["Reference"] = err
		m.Reference = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &m.CorrelationID)
	if err != nil {
		oneOfErrors["CorrelationID"] = err
		m.CorrelationID = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for MessageTraitCorrelationID with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (m MessageTraitCorrelationID) MarshalJSON() ([]byte, error) {
	return marshalUnion(m.Reference, m.CorrelationID)
}

// MessageTraitsItems structure is generated from "#/definitions/Message->traits->items".
type MessageTraitsItems struct {
	Reference       *Reference    `json:"-"`
	MessageTrait    *MessageTrait `json:"-"`
	SliceOfAnything []interface{} `json:"-"`
}

// WithReference sets Reference value.
func (m *MessageTraitsItems) WithReference(val Reference) *MessageTraitsItems {
	m.Reference = &val
	return m
}

// ReferenceEns ensures returned Reference is not nil.
func (m *MessageTraitsItems) ReferenceEns() *Reference {
	if m.Reference == nil {
		m.Reference = new(Reference)
	}

	return m.Reference
}

// WithMessageTrait sets MessageTrait value.
func (m *MessageTraitsItems) WithMessageTrait(val MessageTrait) *MessageTraitsItems {
	m.MessageTrait = &val
	return m
}

// MessageTraitEns ensures returned MessageTrait is not nil.
func (m *MessageTraitsItems) MessageTraitEns() *MessageTrait {
	if m.MessageTrait == nil {
		m.MessageTrait = new(MessageTrait)
	}

	return m.MessageTrait
}

// WithSliceOfAnything sets SliceOfAnything value.
func (m *MessageTraitsItems) WithSliceOfAnything(val ...interface{}) *MessageTraitsItems {
	m.SliceOfAnything = val
	return m
}

// UnmarshalJSON decodes JSON.
func (m *MessageTraitsItems) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 3)
	oneOfValid := 0

	err = json.Unmarshal(data, &m.Reference)
	if err != nil {
		oneOfErrors["Reference"] = err
		m.Reference = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &m.MessageTrait)
	if err != nil {
		oneOfErrors["MessageTrait"] = err
		m.MessageTrait = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &m.SliceOfAnything)
	if err != nil {
		oneOfErrors["SliceOfAnything"] = err
		m.SliceOfAnything = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for MessageTraitsItems with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (m MessageTraitsItems) MarshalJSON() ([]byte, error) {
	return marshalUnion(m.Reference, m.MessageTrait, m.SliceOfAnything)
}

// MessageChoices structure is generated from "#/definitions/MessageChoices".
type MessageChoices struct {
	Reference      *Reference      `json:"-"`
	MessageOptions *MessageOptions `json:"-"`
	Message        *Message        `json:"-"`
}

// WithReference sets Reference value.
func (m *MessageChoices) WithReference(val Reference) *MessageChoices {
	m.Reference = &val
	return m
}

// ReferenceEns ensures returned Reference is not nil.
func (m *MessageChoices) ReferenceEns() *Reference {
	if m.Reference == nil {
		m.Reference = new(Reference)
	}

	return m.Reference
}

// WithMessageOptions sets MessageOptions value.
func (m *MessageChoices) WithMessageOptions(val MessageOptions) *MessageChoices {
	m.MessageOptions = &val
	return m
}

// MessageOptionsEns ensures returned MessageOptions is not nil.
func (m *MessageChoices) MessageOptionsEns() *MessageOptions {
	if m.MessageOptions == nil {
		m.MessageOptions = new(MessageOptions)
	}

	return m.MessageOptions
}

// WithMessage sets Message value.
func (m *MessageChoices) WithMessage(val Message) *MessageChoices {
	m.Message = &val
	return m
}

// MessageEns ensures returned Message is not nil.
func (m *MessageChoices) MessageEns() *Message {
	if m.Message == nil {
		m.Message = new(Message)
	}

	return m.Message
}

// UnmarshalJSON decodes JSON.
func (m *MessageChoices) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 3)
	oneOfValid := 0

	err = json.Unmarshal(data, &m.Reference)
	if err != nil {
		oneOfErrors["Reference"] = err
		m.Reference = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &m.MessageOptions)
	if err != nil {
		oneOfErrors["MessageOptions"] = err
		m.MessageOptions = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &m.Message)
	if err != nil {
		oneOfErrors["Message"] = err
		m.Message = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for MessageChoices with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (m MessageChoices) MarshalJSON() ([]byte, error) {
	return marshalUnion(m.Reference, m.MessageOptions, m.Message)
}

// Components structure is generated from "#/definitions/components".
//
// An object to hold a set of reusable objects for different aspects of the AsyncAPI Specification.
type Components struct {
	Schemas           map[string]jsonschema.Schema `json:"schemas,omitempty"`           // JSON objects describing schemas the API uses.
	Servers           map[string]Server            `json:"servers,omitempty"`
	Channels          map[string]ChannelItem       `json:"channels,omitempty"`
	Messages          map[string]MessageChoices    `json:"messages,omitempty"`          // JSON objects describing the messages being consumed and produced by the API.
	SecuritySchemes   *ComponentsSecuritySchemes   `json:"securitySchemes,omitempty"`
	Parameters        map[string]Parameter         `json:"parameters,omitempty"`        // JSON objects describing re-usable channel parameters.
	CorrelationIds    *ComponentsCorrelationIds    `json:"correlationIds,omitempty"`
	OperationTraits   map[string]OperationTrait    `json:"operationTraits,omitempty"`
	MessageTraits     map[string]MessageTrait      `json:"messageTraits,omitempty"`
	ServerBindings    map[string]BindingsObject    `json:"serverBindings,omitempty"`
	ChannelBindings   map[string]BindingsObject    `json:"channelBindings,omitempty"`
	OperationBindings map[string]BindingsObject    `json:"operationBindings,omitempty"`
	MessageBindings   map[string]BindingsObject    `json:"messageBindings,omitempty"`
	MapOfAnything     map[string]interface{}       `json:"-"`                           // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithSchemas sets Schemas value.
func (c *Components) WithSchemas(val map[string]jsonschema.Schema) *Components {
	c.Schemas = val
	return c
}

// WithSchemasItem sets Schemas item value.
func (c *Components) WithSchemasItem(key string, val jsonschema.Schema) *Components {
	if c.Schemas == nil {
		c.Schemas = make(map[string]jsonschema.Schema, 1)
	}

	c.Schemas[key] = val

	return c
}

// WithServers sets Servers value.
func (c *Components) WithServers(val map[string]Server) *Components {
	c.Servers = val
	return c
}

// WithServersItem sets Servers item value.
func (c *Components) WithServersItem(key string, val Server) *Components {
	if c.Servers == nil {
		c.Servers = make(map[string]Server, 1)
	}

	c.Servers[key] = val

	return c
}

// WithChannels sets Channels value.
func (c *Components) WithChannels(val map[string]ChannelItem) *Components {
	c.Channels = val
	return c
}

// WithChannelsItem sets Channels item value.
func (c *Components) WithChannelsItem(key string, val ChannelItem) *Components {
	if c.Channels == nil {
		c.Channels = make(map[string]ChannelItem, 1)
	}

	c.Channels[key] = val

	return c
}

// WithMessages sets Messages value.
func (c *Components) WithMessages(val map[string]MessageChoices) *Components {
	c.Messages = val
	return c
}

// WithMessagesItem sets Messages item value.
func (c *Components) WithMessagesItem(key string, val MessageChoices) *Components {
	if c.Messages == nil {
		c.Messages = make(map[string]MessageChoices, 1)
	}

	c.Messages[key] = val

	return c
}

// WithSecuritySchemes sets SecuritySchemes value.
func (c *Components) WithSecuritySchemes(val ComponentsSecuritySchemes) *Components {
	c.SecuritySchemes = &val
	return c
}

// SecuritySchemesEns ensures returned SecuritySchemes is not nil.
func (c *Components) SecuritySchemesEns() *ComponentsSecuritySchemes {
	if c.SecuritySchemes == nil {
		c.SecuritySchemes = new(ComponentsSecuritySchemes)
	}

	return c.SecuritySchemes
}

// WithParameters sets Parameters value.
func (c *Components) WithParameters(val map[string]Parameter) *Components {
	c.Parameters = val
	return c
}

// WithParametersItem sets Parameters item value.
func (c *Components) WithParametersItem(key string, val Parameter) *Components {
	if c.Parameters == nil {
		c.Parameters = make(map[string]Parameter, 1)
	}

	c.Parameters[key] = val

	return c
}

// WithCorrelationIds sets CorrelationIds value.
func (c *Components) WithCorrelationIds(val ComponentsCorrelationIds) *Components {
	c.CorrelationIds = &val
	return c
}

// CorrelationIdsEns ensures returned CorrelationIds is not nil.
func (c *Components) CorrelationIdsEns() *ComponentsCorrelationIds {
	if c.CorrelationIds == nil {
		c.CorrelationIds = new(ComponentsCorrelationIds)
	}

	return c.CorrelationIds
}

// WithOperationTraits sets OperationTraits value.
func (c *Components) WithOperationTraits(val map[string]OperationTrait) *Components {
	c.OperationTraits = val
	return c
}

// WithOperationTraitsItem sets OperationTraits item value.
func (c *Components) WithOperationTraitsItem(key string, val OperationTrait) *Components {
	if c.OperationTraits == nil {
		c.OperationTraits = make(map[string]OperationTrait, 1)
	}

	c.OperationTraits[key] = val

	return c
}

// WithMessageTraits sets MessageTraits value.
func (c *Components) WithMessageTraits(val map[string]MessageTrait) *Components {
	c.MessageTraits = val
	return c
}

// WithMessageTraitsItem sets MessageTraits item value.
func (c *Components) WithMessageTraitsItem(key string, val MessageTrait) *Components {
	if c.MessageTraits == nil {
		c.MessageTraits = make(map[string]MessageTrait, 1)
	}

	c.MessageTraits[key] = val

	return c
}

// WithServerBindings sets ServerBindings value.
func (c *Components) WithServerBindings(val map[string]BindingsObject) *Components {
	c.ServerBindings = val
	return c
}

// WithServerBindingsItem sets ServerBindings item value.
func (c *Components) WithServerBindingsItem(key string, val BindingsObject) *Components {
	if c.ServerBindings == nil {
		c.ServerBindings = make(map[string]BindingsObject, 1)
	}

	c.ServerBindings[key] = val

	return c
}

// WithChannelBindings sets ChannelBindings value.
func (c *Components) WithChannelBindings(val map[string]BindingsObject) *Components {
	c.ChannelBindings = val
	return c
}

// WithChannelBindingsItem sets ChannelBindings item value.
func (c *Components) WithChannelBindingsItem(key string, val BindingsObject) *Components {
	if c.ChannelBindings == nil {
		c.ChannelBindings = make(map[string]BindingsObject, 1)
	}

	c.ChannelBindings[key] = val

	return c
}

// WithOperationBindings sets OperationBindings value.
func (c *Components) WithOperationBindings(val map[string]BindingsObject) *Components {
	c.OperationBindings = val
	return c
}

// WithOperationBindingsItem sets OperationBindings item value.
func (c *Components) WithOperationBindingsItem(key string, val BindingsObject) *Components {
	if c.OperationBindings == nil {
		c.OperationBindings = make(map[string]BindingsObject, 1)
	}

	c.OperationBindings[key] = val

	return c
}

// WithMessageBindings sets MessageBindings value.
func (c *Components) WithMessageBindings(val map[string]BindingsObject) *Components {
	c.MessageBindings = val
	return c
}

// WithMessageBindingsItem sets MessageBindings item value.
func (c *Components) WithMessageBindingsItem(key string, val BindingsObject) *Components {
	if c.MessageBindings == nil {
		c.MessageBindings = make(map[string]BindingsObject, 1)
	}

	c.MessageBindings[key] = val

	return c
}

// WithMapOfAnything sets MapOfAnything value.
func (c *Components) WithMapOfAnything(val map[string]interface{}) *Components {
	c.MapOfAnything = val
	return c
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (c *Components) WithMapOfAnythingItem(key string, val interface{}) *Components {
	if c.MapOfAnything == nil {
		c.MapOfAnything = make(map[string]interface{}, 1)
	}

	c.MapOfAnything[key] = val

	return c
}

type marshalComponents Components

var knownKeysComponents = []string{
	"schemas",
	"servers",
	"channels",
	"messages",
	"securitySchemes",
	"parameters",
	"correlationIds",
	"operationTraits",
	"messageTraits",
	"serverBindings",
	"channelBindings",
	"operationBindings",
	"messageBindings",
}

// UnmarshalJSON decodes JSON.
func (c *Components) UnmarshalJSON(data []byte) error {
	var err error

	mc := marshalComponents(*c)

	err = json.Unmarshal(data, &mc)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysComponents {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mc.MapOfAnything == nil {
				mc.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mc.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Components: %v", offendingKeys)
	}

	*c = Components(mc)

	return nil
}

// MarshalJSON encodes JSON.
func (c Components) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalComponents(c), c.MapOfAnything)
}

// UserPassword structure is generated from "#/definitions/userPassword".
type UserPassword struct {
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (u *UserPassword) WithDescription(val string) *UserPassword {
	u.Description = &val
	return u
}

// WithMapOfAnything sets MapOfAnything value.
func (u *UserPassword) WithMapOfAnything(val map[string]interface{}) *UserPassword {
	u.MapOfAnything = val
	return u
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (u *UserPassword) WithMapOfAnythingItem(key string, val interface{}) *UserPassword {
	if u.MapOfAnything == nil {
		u.MapOfAnything = make(map[string]interface{}, 1)
	}

	u.MapOfAnything[key] = val

	return u
}

type marshalUserPassword UserPassword

var knownKeysUserPassword = []string{
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (u *UserPassword) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUserPassword(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"userPassword"` {
		return fmt.Errorf(`bad const value for "type" ("userPassword" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysUserPassword {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mu.MapOfAnything == nil {
				mu.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mu.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in UserPassword: %v", offendingKeys)
	}

	*u = UserPassword(mu)

	return nil
}

var (
	// constUserPassword is unconditionally added to JSON.
	constUserPassword = json.RawMessage(`{"type":"userPassword"}`)
)

// MarshalJSON encodes JSON.
func (u UserPassword) MarshalJSON() ([]byte, error) {
	return marshalUnion(constUserPassword, marshalUserPassword(u), u.MapOfAnything)
}

// APIKey structure is generated from "#/definitions/apiKey".
type APIKey struct {
	In            APIKeyIn               `json:"in"`                    // Required.
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithIn sets In value.
func (a *APIKey) WithIn(val APIKeyIn) *APIKey {
	a.In = val
	return a
}

// WithDescription sets Description value.
func (a *APIKey) WithDescription(val string) *APIKey {
	a.Description = &val
	return a
}

// WithMapOfAnything sets MapOfAnything value.
func (a *APIKey) WithMapOfAnything(val map[string]interface{}) *APIKey {
	a.MapOfAnything = val
	return a
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (a *APIKey) WithMapOfAnythingItem(key string, val interface{}) *APIKey {
	if a.MapOfAnything == nil {
		a.MapOfAnything = make(map[string]interface{}, 1)
	}

	a.MapOfAnything[key] = val

	return a
}

type marshalAPIKey APIKey

var knownKeysAPIKey = []string{
	"in",
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (a *APIKey) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAPIKey(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"apiKey"` {
		return fmt.Errorf(`bad const value for "type" ("apiKey" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysAPIKey {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ma.MapOfAnything == nil {
				ma.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ma.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in APIKey: %v", offendingKeys)
	}

	*a = APIKey(ma)

	return nil
}

var (
	// constAPIKey is unconditionally added to JSON.
	constAPIKey = json.RawMessage(`{"type":"apiKey"}`)
)

// MarshalJSON encodes JSON.
func (a APIKey) MarshalJSON() ([]byte, error) {
	return marshalUnion(constAPIKey, marshalAPIKey(a), a.MapOfAnything)
}

// X509 structure is generated from "#/definitions/X509".
type X509 struct {
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (x *X509) WithDescription(val string) *X509 {
	x.Description = &val
	return x
}

// WithMapOfAnything sets MapOfAnything value.
func (x *X509) WithMapOfAnything(val map[string]interface{}) *X509 {
	x.MapOfAnything = val
	return x
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (x *X509) WithMapOfAnythingItem(key string, val interface{}) *X509 {
	if x.MapOfAnything == nil {
		x.MapOfAnything = make(map[string]interface{}, 1)
	}

	x.MapOfAnything[key] = val

	return x
}

type marshalX509 X509

var knownKeysX509 = []string{
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (x *X509) UnmarshalJSON(data []byte) error {
	var err error

	mx := marshalX509(*x)

	err = json.Unmarshal(data, &mx)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"X509"` {
		return fmt.Errorf(`bad const value for "type" ("X509" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysX509 {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mx.MapOfAnything == nil {
				mx.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mx.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in X509: %v", offendingKeys)
	}

	*x = X509(mx)

	return nil
}

var (
	// constX509 is unconditionally added to JSON.
	constX509 = json.RawMessage(`{"type":"X509"}`)
)

// MarshalJSON encodes JSON.
func (x X509) MarshalJSON() ([]byte, error) {
	return marshalUnion(constX509, marshalX509(x), x.MapOfAnything)
}

// SymmetricEncryption structure is generated from "#/definitions/symmetricEncryption".
type SymmetricEncryption struct {
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (s *SymmetricEncryption) WithDescription(val string) *SymmetricEncryption {
	s.Description = &val
	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *SymmetricEncryption) WithMapOfAnything(val map[string]interface{}) *SymmetricEncryption {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *SymmetricEncryption) WithMapOfAnythingItem(key string, val interface{}) *SymmetricEncryption {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalSymmetricEncryption SymmetricEncryption

var knownKeysSymmetricEncryption = []string{
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (s *SymmetricEncryption) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSymmetricEncryption(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"symmetricEncryption"` {
		return fmt.Errorf(`bad const value for "type" ("symmetricEncryption" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysSymmetricEncryption {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in SymmetricEncryption: %v", offendingKeys)
	}

	*s = SymmetricEncryption(ms)

	return nil
}

var (
	// constSymmetricEncryption is unconditionally added to JSON.
	constSymmetricEncryption = json.RawMessage(`{"type":"symmetricEncryption"}`)
)

// MarshalJSON encodes JSON.
func (s SymmetricEncryption) MarshalJSON() ([]byte, error) {
	return marshalUnion(constSymmetricEncryption, marshalSymmetricEncryption(s), s.MapOfAnything)
}

// AsymmetricEncryption structure is generated from "#/definitions/asymmetricEncryption".
type AsymmetricEncryption struct {
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (a *AsymmetricEncryption) WithDescription(val string) *AsymmetricEncryption {
	a.Description = &val
	return a
}

// WithMapOfAnything sets MapOfAnything value.
func (a *AsymmetricEncryption) WithMapOfAnything(val map[string]interface{}) *AsymmetricEncryption {
	a.MapOfAnything = val
	return a
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (a *AsymmetricEncryption) WithMapOfAnythingItem(key string, val interface{}) *AsymmetricEncryption {
	if a.MapOfAnything == nil {
		a.MapOfAnything = make(map[string]interface{}, 1)
	}

	a.MapOfAnything[key] = val

	return a
}

type marshalAsymmetricEncryption AsymmetricEncryption

var knownKeysAsymmetricEncryption = []string{
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (a *AsymmetricEncryption) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAsymmetricEncryption(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"asymmetricEncryption"` {
		return fmt.Errorf(`bad const value for "type" ("asymmetricEncryption" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysAsymmetricEncryption {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ma.MapOfAnything == nil {
				ma.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ma.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in AsymmetricEncryption: %v", offendingKeys)
	}

	*a = AsymmetricEncryption(ma)

	return nil
}

var (
	// constAsymmetricEncryption is unconditionally added to JSON.
	constAsymmetricEncryption = json.RawMessage(`{"type":"asymmetricEncryption"}`)
)

// MarshalJSON encodes JSON.
func (a AsymmetricEncryption) MarshalJSON() ([]byte, error) {
	return marshalUnion(constAsymmetricEncryption, marshalAsymmetricEncryption(a), a.MapOfAnything)
}

// NonBearerHTTPSecurityScheme structure is generated from "#/definitions/NonBearerHTTPSecurityScheme".
type NonBearerHTTPSecurityScheme struct {
	Scheme        string                 `json:"scheme"`                // Required.
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithScheme sets Scheme value.
func (n *NonBearerHTTPSecurityScheme) WithScheme(val string) *NonBearerHTTPSecurityScheme {
	n.Scheme = val
	return n
}

// WithDescription sets Description value.
func (n *NonBearerHTTPSecurityScheme) WithDescription(val string) *NonBearerHTTPSecurityScheme {
	n.Description = &val
	return n
}

// WithMapOfAnything sets MapOfAnything value.
func (n *NonBearerHTTPSecurityScheme) WithMapOfAnything(val map[string]interface{}) *NonBearerHTTPSecurityScheme {
	n.MapOfAnything = val
	return n
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (n *NonBearerHTTPSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *NonBearerHTTPSecurityScheme {
	if n.MapOfAnything == nil {
		n.MapOfAnything = make(map[string]interface{}, 1)
	}

	n.MapOfAnything[key] = val

	return n
}

type marshalNonBearerHTTPSecurityScheme NonBearerHTTPSecurityScheme

var knownKeysNonBearerHTTPSecurityScheme = []string{
	"scheme",
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (n *NonBearerHTTPSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	var not NonBearerHTTPSecuritySchemeNot

	if json.Unmarshal(data, &not) == nil {
		return errors.New("not constraint failed for NonBearerHTTPSecurityScheme")
	}

	mn := marshalNonBearerHTTPSecurityScheme(*n)

	err = json.Unmarshal(data, &mn)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"http"` {
		return fmt.Errorf(`bad const value for "type" ("http" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysNonBearerHTTPSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mn.MapOfAnything == nil {
				mn.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mn.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in NonBearerHTTPSecurityScheme: %v", offendingKeys)
	}

	*n = NonBearerHTTPSecurityScheme(mn)

	return nil
}

var (
	// constNonBearerHTTPSecurityScheme is unconditionally added to JSON.
	constNonBearerHTTPSecurityScheme = json.RawMessage(`{"type":"http"}`)
)

// MarshalJSON encodes JSON.
func (n NonBearerHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(constNonBearerHTTPSecurityScheme, marshalNonBearerHTTPSecurityScheme(n), n.MapOfAnything)
}

// NonBearerHTTPSecuritySchemeNot structure is generated from "#/definitions/NonBearerHTTPSecurityScheme->not".
type NonBearerHTTPSecuritySchemeNot struct {

}

// UnmarshalJSON decodes JSON.
func (n *NonBearerHTTPSecuritySchemeNot) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["scheme"]; exists && string(v) != `"bearer"` {
		return fmt.Errorf(`bad const value for "scheme" ("bearer" expected, %s received)`, v)
	}

	delete(rawMap, "scheme")

	return nil
}

var (
	// constNonBearerHTTPSecuritySchemeNot is unconditionally added to JSON.
	constNonBearerHTTPSecuritySchemeNot = json.RawMessage(`{"scheme":"bearer"}`)
)

// MarshalJSON encodes JSON.
func (n NonBearerHTTPSecuritySchemeNot) MarshalJSON() ([]byte, error) {
	return marshalUnion(constNonBearerHTTPSecuritySchemeNot)
}

// BearerHTTPSecurityScheme structure is generated from "#/definitions/BearerHTTPSecurityScheme".
type BearerHTTPSecurityScheme struct {
	BearerFormat  *string                `json:"bearerFormat,omitempty"`
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                      // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithBearerFormat sets BearerFormat value.
func (b *BearerHTTPSecurityScheme) WithBearerFormat(val string) *BearerHTTPSecurityScheme {
	b.BearerFormat = &val
	return b
}

// WithDescription sets Description value.
func (b *BearerHTTPSecurityScheme) WithDescription(val string) *BearerHTTPSecurityScheme {
	b.Description = &val
	return b
}

// WithMapOfAnything sets MapOfAnything value.
func (b *BearerHTTPSecurityScheme) WithMapOfAnything(val map[string]interface{}) *BearerHTTPSecurityScheme {
	b.MapOfAnything = val
	return b
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (b *BearerHTTPSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *BearerHTTPSecurityScheme {
	if b.MapOfAnything == nil {
		b.MapOfAnything = make(map[string]interface{}, 1)
	}

	b.MapOfAnything[key] = val

	return b
}

type marshalBearerHTTPSecurityScheme BearerHTTPSecurityScheme

var knownKeysBearerHTTPSecurityScheme = []string{
	"bearerFormat",
	"description",
	"scheme",
	"type",
}

// UnmarshalJSON decodes JSON.
func (b *BearerHTTPSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	mb := marshalBearerHTTPSecurityScheme(*b)

	err = json.Unmarshal(data, &mb)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["scheme"]; exists && string(v) != `"bearer"` {
		return fmt.Errorf(`bad const value for "scheme" ("bearer" expected, %s received)`, v)
	}

	delete(rawMap, "scheme")

	if v, exists := rawMap["type"]; exists && string(v) != `"http"` {
		return fmt.Errorf(`bad const value for "type" ("http" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysBearerHTTPSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mb.MapOfAnything == nil {
				mb.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mb.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in BearerHTTPSecurityScheme: %v", offendingKeys)
	}

	*b = BearerHTTPSecurityScheme(mb)

	return nil
}

var (
	// constBearerHTTPSecurityScheme is unconditionally added to JSON.
	constBearerHTTPSecurityScheme = json.RawMessage(`{"scheme":"bearer","type":"http"}`)
)

// MarshalJSON encodes JSON.
func (b BearerHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(constBearerHTTPSecurityScheme, marshalBearerHTTPSecurityScheme(b), b.MapOfAnything)
}

// APIKeyHTTPSecurityScheme structure is generated from "#/definitions/APIKeyHTTPSecurityScheme".
type APIKeyHTTPSecurityScheme struct {
	Name          string                     `json:"name"`                  // Required.
	In            APIKeyHTTPSecuritySchemeIn `json:"in"`                    // Required.
	Description   *string                    `json:"description,omitempty"`
	MapOfAnything map[string]interface{}     `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithName sets Name value.
func (a *APIKeyHTTPSecurityScheme) WithName(val string) *APIKeyHTTPSecurityScheme {
	a.Name = val
	return a
}

// WithIn sets In value.
func (a *APIKeyHTTPSecurityScheme) WithIn(val APIKeyHTTPSecuritySchemeIn) *APIKeyHTTPSecurityScheme {
	a.In = val
	return a
}

// WithDescription sets Description value.
func (a *APIKeyHTTPSecurityScheme) WithDescription(val string) *APIKeyHTTPSecurityScheme {
	a.Description = &val
	return a
}

// WithMapOfAnything sets MapOfAnything value.
func (a *APIKeyHTTPSecurityScheme) WithMapOfAnything(val map[string]interface{}) *APIKeyHTTPSecurityScheme {
	a.MapOfAnything = val
	return a
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (a *APIKeyHTTPSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *APIKeyHTTPSecurityScheme {
	if a.MapOfAnything == nil {
		a.MapOfAnything = make(map[string]interface{}, 1)
	}

	a.MapOfAnything[key] = val

	return a
}

type marshalAPIKeyHTTPSecurityScheme APIKeyHTTPSecurityScheme

var knownKeysAPIKeyHTTPSecurityScheme = []string{
	"name",
	"in",
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (a *APIKeyHTTPSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAPIKeyHTTPSecurityScheme(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"httpApiKey"` {
		return fmt.Errorf(`bad const value for "type" ("httpApiKey" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysAPIKeyHTTPSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ma.MapOfAnything == nil {
				ma.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ma.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in APIKeyHTTPSecurityScheme: %v", offendingKeys)
	}

	*a = APIKeyHTTPSecurityScheme(ma)

	return nil
}

var (
	// constAPIKeyHTTPSecurityScheme is unconditionally added to JSON.
	constAPIKeyHTTPSecurityScheme = json.RawMessage(`{"type":"httpApiKey"}`)
)

// MarshalJSON encodes JSON.
func (a APIKeyHTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(constAPIKeyHTTPSecurityScheme, marshalAPIKeyHTTPSecurityScheme(a), a.MapOfAnything)
}

// HTTPSecurityScheme structure is generated from "#/definitions/HTTPSecurityScheme".
type HTTPSecurityScheme struct {
	NonBearerHTTPSecurityScheme *NonBearerHTTPSecurityScheme `json:"-"`
	BearerHTTPSecurityScheme    *BearerHTTPSecurityScheme    `json:"-"`
	APIKeyHTTPSecurityScheme    *APIKeyHTTPSecurityScheme    `json:"-"`
}

// WithNonBearerHTTPSecurityScheme sets NonBearerHTTPSecurityScheme value.
func (h *HTTPSecurityScheme) WithNonBearerHTTPSecurityScheme(val NonBearerHTTPSecurityScheme) *HTTPSecurityScheme {
	h.NonBearerHTTPSecurityScheme = &val
	return h
}

// NonBearerHTTPSecuritySchemeEns ensures returned NonBearerHTTPSecurityScheme is not nil.
func (h *HTTPSecurityScheme) NonBearerHTTPSecuritySchemeEns() *NonBearerHTTPSecurityScheme {
	if h.NonBearerHTTPSecurityScheme == nil {
		h.NonBearerHTTPSecurityScheme = new(NonBearerHTTPSecurityScheme)
	}

	return h.NonBearerHTTPSecurityScheme
}

// WithBearerHTTPSecurityScheme sets BearerHTTPSecurityScheme value.
func (h *HTTPSecurityScheme) WithBearerHTTPSecurityScheme(val BearerHTTPSecurityScheme) *HTTPSecurityScheme {
	h.BearerHTTPSecurityScheme = &val
	return h
}

// BearerHTTPSecuritySchemeEns ensures returned BearerHTTPSecurityScheme is not nil.
func (h *HTTPSecurityScheme) BearerHTTPSecuritySchemeEns() *BearerHTTPSecurityScheme {
	if h.BearerHTTPSecurityScheme == nil {
		h.BearerHTTPSecurityScheme = new(BearerHTTPSecurityScheme)
	}

	return h.BearerHTTPSecurityScheme
}

// WithAPIKeyHTTPSecurityScheme sets APIKeyHTTPSecurityScheme value.
func (h *HTTPSecurityScheme) WithAPIKeyHTTPSecurityScheme(val APIKeyHTTPSecurityScheme) *HTTPSecurityScheme {
	h.APIKeyHTTPSecurityScheme = &val
	return h
}

// APIKeyHTTPSecuritySchemeEns ensures returned APIKeyHTTPSecurityScheme is not nil.
func (h *HTTPSecurityScheme) APIKeyHTTPSecuritySchemeEns() *APIKeyHTTPSecurityScheme {
	if h.APIKeyHTTPSecurityScheme == nil {
		h.APIKeyHTTPSecurityScheme = new(APIKeyHTTPSecurityScheme)
	}

	return h.APIKeyHTTPSecurityScheme
}

// UnmarshalJSON decodes JSON.
func (h *HTTPSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 3)
	oneOfValid := 0

	err = json.Unmarshal(data, &h.NonBearerHTTPSecurityScheme)
	if err != nil {
		oneOfErrors["NonBearerHTTPSecurityScheme"] = err
		h.NonBearerHTTPSecurityScheme = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &h.BearerHTTPSecurityScheme)
	if err != nil {
		oneOfErrors["BearerHTTPSecurityScheme"] = err
		h.BearerHTTPSecurityScheme = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &h.APIKeyHTTPSecurityScheme)
	if err != nil {
		oneOfErrors["APIKeyHTTPSecurityScheme"] = err
		h.APIKeyHTTPSecurityScheme = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for HTTPSecurityScheme with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (h HTTPSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(h.NonBearerHTTPSecurityScheme, h.BearerHTTPSecurityScheme, h.APIKeyHTTPSecurityScheme)
}

// Oauth2Flows structure is generated from "#/definitions/oauth2Flows".
type Oauth2Flows struct {
	Description   *string                `json:"description,omitempty"`
	Flows         Oauth2FlowsFlows       `json:"flows"`                 // Required.
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (o *Oauth2Flows) WithDescription(val string) *Oauth2Flows {
	o.Description = &val
	return o
}

// WithFlows sets Flows value.
func (o *Oauth2Flows) WithFlows(val Oauth2FlowsFlows) *Oauth2Flows {
	o.Flows = val
	return o
}

// WithMapOfAnything sets MapOfAnything value.
func (o *Oauth2Flows) WithMapOfAnything(val map[string]interface{}) *Oauth2Flows {
	o.MapOfAnything = val
	return o
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (o *Oauth2Flows) WithMapOfAnythingItem(key string, val interface{}) *Oauth2Flows {
	if o.MapOfAnything == nil {
		o.MapOfAnything = make(map[string]interface{}, 1)
	}

	o.MapOfAnything[key] = val

	return o
}

type marshalOauth2Flows Oauth2Flows

var knownKeysOauth2Flows = []string{
	"description",
	"flows",
	"type",
}

// UnmarshalJSON decodes JSON.
func (o *Oauth2Flows) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOauth2Flows(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"oauth2"` {
		return fmt.Errorf(`bad const value for "type" ("oauth2" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysOauth2Flows {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	*o = Oauth2Flows(mo)

	return nil
}

var (
	// constOauth2Flows is unconditionally added to JSON.
	constOauth2Flows = json.RawMessage(`{"type":"oauth2"}`)
)

// MarshalJSON encodes JSON.
func (o Oauth2Flows) MarshalJSON() ([]byte, error) {
	return marshalUnion(constOauth2Flows, marshalOauth2Flows(o), o.MapOfAnything)
}

// Oauth2FlowsFlows structure is generated from "#/definitions/oauth2Flows->flows".
type Oauth2FlowsFlows struct {
	Implicit          *Oauth2Flow `json:"implicit,omitempty"`
	Password          *Oauth2Flow `json:"password,omitempty"`
	ClientCredentials *Oauth2Flow `json:"clientCredentials,omitempty"`
	AuthorizationCode *Oauth2Flow `json:"authorizationCode,omitempty"`
}

// WithImplicit sets Implicit value.
func (o *Oauth2FlowsFlows) WithImplicit(val Oauth2Flow) *Oauth2FlowsFlows {
	o.Implicit = &val
	return o
}

// ImplicitEns ensures returned Implicit is not nil.
func (o *Oauth2FlowsFlows) ImplicitEns() *Oauth2Flow {
	if o.Implicit == nil {
		o.Implicit = new(Oauth2Flow)
	}

	return o.Implicit
}

// WithPassword sets Password value.
func (o *Oauth2FlowsFlows) WithPassword(val Oauth2Flow) *Oauth2FlowsFlows {
	o.Password = &val
	return o
}

// PasswordEns ensures returned Password is not nil.
func (o *Oauth2FlowsFlows) PasswordEns() *Oauth2Flow {
	if o.Password == nil {
		o.Password = new(Oauth2Flow)
	}

	return o.Password
}

// WithClientCredentials sets ClientCredentials value.
func (o *Oauth2FlowsFlows) WithClientCredentials(val Oauth2Flow) *Oauth2FlowsFlows {
	o.ClientCredentials = &val
	return o
}

// ClientCredentialsEns ensures returned ClientCredentials is not nil.
func (o *Oauth2FlowsFlows) ClientCredentialsEns() *Oauth2Flow {
	if o.ClientCredentials == nil {
		o.ClientCredentials = new(Oauth2Flow)
	}

	return o.ClientCredentials
}

// WithAuthorizationCode sets AuthorizationCode value.
func (o *Oauth2FlowsFlows) WithAuthorizationCode(val Oauth2Flow) *Oauth2FlowsFlows {
	o.AuthorizationCode = &val
	return o
}

// AuthorizationCodeEns ensures returned AuthorizationCode is not nil.
func (o *Oauth2FlowsFlows) AuthorizationCodeEns() *Oauth2Flow {
	if o.AuthorizationCode == nil {
		o.AuthorizationCode = new(Oauth2Flow)
	}

	return o.AuthorizationCode
}

type marshalOauth2FlowsFlows Oauth2FlowsFlows

var knownKeysOauth2FlowsFlows = []string{
	"implicit",
	"password",
	"clientCredentials",
	"authorizationCode",
}

// UnmarshalJSON decodes JSON.
func (o *Oauth2FlowsFlows) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOauth2FlowsFlows(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysOauth2FlowsFlows {
		delete(rawMap, key)
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Oauth2FlowsFlows: %v", offendingKeys)
	}

	*o = Oauth2FlowsFlows(mo)

	return nil
}


// Oauth2Flow structure is generated from "#/definitions/oauth2Flow".
type Oauth2Flow struct {
	AuthorizationURL *string                `json:"authorizationUrl,omitempty"` // Format: uri.
	TokenURL         *string                `json:"tokenUrl,omitempty"`         // Format: uri.
	RefreshURL       *string                `json:"refreshUrl,omitempty"`       // Format: uri.
	Scopes           map[string]string      `json:"scopes,omitempty"`
	MapOfAnything    map[string]interface{} `json:"-"`                          // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithAuthorizationURL sets AuthorizationURL value.
func (o *Oauth2Flow) WithAuthorizationURL(val string) *Oauth2Flow {
	o.AuthorizationURL = &val
	return o
}

// WithTokenURL sets TokenURL value.
func (o *Oauth2Flow) WithTokenURL(val string) *Oauth2Flow {
	o.TokenURL = &val
	return o
}

// WithRefreshURL sets RefreshURL value.
func (o *Oauth2Flow) WithRefreshURL(val string) *Oauth2Flow {
	o.RefreshURL = &val
	return o
}

// WithScopes sets Scopes value.
func (o *Oauth2Flow) WithScopes(val map[string]string) *Oauth2Flow {
	o.Scopes = val
	return o
}

// WithScopesItem sets Scopes item value.
func (o *Oauth2Flow) WithScopesItem(key string, val string) *Oauth2Flow {
	if o.Scopes == nil {
		o.Scopes = make(map[string]string, 1)
	}

	o.Scopes[key] = val

	return o
}

// WithMapOfAnything sets MapOfAnything value.
func (o *Oauth2Flow) WithMapOfAnything(val map[string]interface{}) *Oauth2Flow {
	o.MapOfAnything = val
	return o
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (o *Oauth2Flow) WithMapOfAnythingItem(key string, val interface{}) *Oauth2Flow {
	if o.MapOfAnything == nil {
		o.MapOfAnything = make(map[string]interface{}, 1)
	}

	o.MapOfAnything[key] = val

	return o
}

type marshalOauth2Flow Oauth2Flow

var knownKeysOauth2Flow = []string{
	"authorizationUrl",
	"tokenUrl",
	"refreshUrl",
	"scopes",
}

// UnmarshalJSON decodes JSON.
func (o *Oauth2Flow) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOauth2Flow(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysOauth2Flow {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in Oauth2Flow: %v", offendingKeys)
	}

	*o = Oauth2Flow(mo)

	return nil
}

// MarshalJSON encodes JSON.
func (o Oauth2Flow) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalOauth2Flow(o), o.MapOfAnything)
}

// OpenIDConnect structure is generated from "#/definitions/openIdConnect".
type OpenIDConnect struct {
	Description   *string                `json:"description,omitempty"`
	// Format: uri.
	// Required.
	URL           string                 `json:"openIdConnectUrl"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (o *OpenIDConnect) WithDescription(val string) *OpenIDConnect {
	o.Description = &val
	return o
}

// WithURL sets URL value.
func (o *OpenIDConnect) WithURL(val string) *OpenIDConnect {
	o.URL = val
	return o
}

// WithMapOfAnything sets MapOfAnything value.
func (o *OpenIDConnect) WithMapOfAnything(val map[string]interface{}) *OpenIDConnect {
	o.MapOfAnything = val
	return o
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (o *OpenIDConnect) WithMapOfAnythingItem(key string, val interface{}) *OpenIDConnect {
	if o.MapOfAnything == nil {
		o.MapOfAnything = make(map[string]interface{}, 1)
	}

	o.MapOfAnything[key] = val

	return o
}

type marshalOpenIDConnect OpenIDConnect

var knownKeysOpenIDConnect = []string{
	"description",
	"openIdConnectUrl",
	"type",
}

// UnmarshalJSON decodes JSON.
func (o *OpenIDConnect) UnmarshalJSON(data []byte) error {
	var err error

	mo := marshalOpenIDConnect(*o)

	err = json.Unmarshal(data, &mo)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"openIdConnect"` {
		return fmt.Errorf(`bad const value for "type" ("openIdConnect" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysOpenIDConnect {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if mo.MapOfAnything == nil {
				mo.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			mo.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in OpenIDConnect: %v", offendingKeys)
	}

	*o = OpenIDConnect(mo)

	return nil
}

var (
	// constOpenIDConnect is unconditionally added to JSON.
	constOpenIDConnect = json.RawMessage(`{"type":"openIdConnect"}`)
)

// MarshalJSON encodes JSON.
func (o OpenIDConnect) MarshalJSON() ([]byte, error) {
	return marshalUnion(constOpenIDConnect, marshalOpenIDConnect(o), o.MapOfAnything)
}

// SaslPlainSecurityScheme structure is generated from "#/definitions/SaslPlainSecurityScheme".
type SaslPlainSecurityScheme struct {
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (s *SaslPlainSecurityScheme) WithDescription(val string) *SaslPlainSecurityScheme {
	s.Description = &val
	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *SaslPlainSecurityScheme) WithMapOfAnything(val map[string]interface{}) *SaslPlainSecurityScheme {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *SaslPlainSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *SaslPlainSecurityScheme {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalSaslPlainSecurityScheme SaslPlainSecurityScheme

var knownKeysSaslPlainSecurityScheme = []string{
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (s *SaslPlainSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSaslPlainSecurityScheme(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"plain"` {
		return fmt.Errorf(`bad const value for "type" ("plain" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysSaslPlainSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in SaslPlainSecurityScheme: %v", offendingKeys)
	}

	*s = SaslPlainSecurityScheme(ms)

	return nil
}

var (
	// constSaslPlainSecurityScheme is unconditionally added to JSON.
	constSaslPlainSecurityScheme = json.RawMessage(`{"type":"plain"}`)
)

// MarshalJSON encodes JSON.
func (s SaslPlainSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(constSaslPlainSecurityScheme, marshalSaslPlainSecurityScheme(s), s.MapOfAnything)
}

// SaslScramSecurityScheme structure is generated from "#/definitions/SaslScramSecurityScheme".
type SaslScramSecurityScheme struct {
	Type          SaslScramSecuritySchemeType `json:"type"`                  // Required.
	Description   *string                     `json:"description,omitempty"`
	MapOfAnything map[string]interface{}      `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithType sets Type value.
func (s *SaslScramSecurityScheme) WithType(val SaslScramSecuritySchemeType) *SaslScramSecurityScheme {
	s.Type = val
	return s
}

// WithDescription sets Description value.
func (s *SaslScramSecurityScheme) WithDescription(val string) *SaslScramSecurityScheme {
	s.Description = &val
	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *SaslScramSecurityScheme) WithMapOfAnything(val map[string]interface{}) *SaslScramSecurityScheme {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *SaslScramSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *SaslScramSecurityScheme {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalSaslScramSecurityScheme SaslScramSecurityScheme

var knownKeysSaslScramSecurityScheme = []string{
	"type",
	"description",
}

// UnmarshalJSON decodes JSON.
func (s *SaslScramSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSaslScramSecurityScheme(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysSaslScramSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in SaslScramSecurityScheme: %v", offendingKeys)
	}

	*s = SaslScramSecurityScheme(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s SaslScramSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(marshalSaslScramSecurityScheme(s), s.MapOfAnything)
}

// SaslGssapiSecurityScheme structure is generated from "#/definitions/SaslGssapiSecurityScheme".
type SaslGssapiSecurityScheme struct {
	Description   *string                `json:"description,omitempty"`
	MapOfAnything map[string]interface{} `json:"-"`                     // Key must match pattern: `^x-[\w\d\.\x2d_]+$`.
}

// WithDescription sets Description value.
func (s *SaslGssapiSecurityScheme) WithDescription(val string) *SaslGssapiSecurityScheme {
	s.Description = &val
	return s
}

// WithMapOfAnything sets MapOfAnything value.
func (s *SaslGssapiSecurityScheme) WithMapOfAnything(val map[string]interface{}) *SaslGssapiSecurityScheme {
	s.MapOfAnything = val
	return s
}

// WithMapOfAnythingItem sets MapOfAnything item value.
func (s *SaslGssapiSecurityScheme) WithMapOfAnythingItem(key string, val interface{}) *SaslGssapiSecurityScheme {
	if s.MapOfAnything == nil {
		s.MapOfAnything = make(map[string]interface{}, 1)
	}

	s.MapOfAnything[key] = val

	return s
}

type marshalSaslGssapiSecurityScheme SaslGssapiSecurityScheme

var knownKeysSaslGssapiSecurityScheme = []string{
	"description",
	"type",
}

// UnmarshalJSON decodes JSON.
func (s *SaslGssapiSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSaslGssapiSecurityScheme(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	if v, exists := rawMap["type"]; exists && string(v) != `"gssapi"` {
		return fmt.Errorf(`bad const value for "type" ("gssapi" expected, %s received)`, v)
	}

	delete(rawMap, "type")

	for _, key := range knownKeysSaslGssapiSecurityScheme {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexXWDX2D.MatchString(key) {
			matched = true

			if ms.MapOfAnything == nil {
				ms.MapOfAnything = make(map[string]interface{}, 1)
			}

			var val interface{}

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			ms.MapOfAnything[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	if len(rawMap) != 0 {
		offendingKeys := make([]string, 0, len(rawMap))

		for key := range rawMap {
			offendingKeys = append(offendingKeys, key)
		}

		return fmt.Errorf("additional properties not allowed in SaslGssapiSecurityScheme: %v", offendingKeys)
	}

	*s = SaslGssapiSecurityScheme(ms)

	return nil
}

var (
	// constSaslGssapiSecurityScheme is unconditionally added to JSON.
	constSaslGssapiSecurityScheme = json.RawMessage(`{"type":"gssapi"}`)
)

// MarshalJSON encodes JSON.
func (s SaslGssapiSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(constSaslGssapiSecurityScheme, marshalSaslGssapiSecurityScheme(s), s.MapOfAnything)
}

// SaslSecurityScheme structure is generated from "#/definitions/SaslSecurityScheme".
type SaslSecurityScheme struct {
	SaslPlainSecurityScheme  *SaslPlainSecurityScheme  `json:"-"`
	SaslScramSecurityScheme  *SaslScramSecurityScheme  `json:"-"`
	SaslGssapiSecurityScheme *SaslGssapiSecurityScheme `json:"-"`
}

// WithSaslPlainSecurityScheme sets SaslPlainSecurityScheme value.
func (s *SaslSecurityScheme) WithSaslPlainSecurityScheme(val SaslPlainSecurityScheme) *SaslSecurityScheme {
	s.SaslPlainSecurityScheme = &val
	return s
}

// SaslPlainSecuritySchemeEns ensures returned SaslPlainSecurityScheme is not nil.
func (s *SaslSecurityScheme) SaslPlainSecuritySchemeEns() *SaslPlainSecurityScheme {
	if s.SaslPlainSecurityScheme == nil {
		s.SaslPlainSecurityScheme = new(SaslPlainSecurityScheme)
	}

	return s.SaslPlainSecurityScheme
}

// WithSaslScramSecurityScheme sets SaslScramSecurityScheme value.
func (s *SaslSecurityScheme) WithSaslScramSecurityScheme(val SaslScramSecurityScheme) *SaslSecurityScheme {
	s.SaslScramSecurityScheme = &val
	return s
}

// SaslScramSecuritySchemeEns ensures returned SaslScramSecurityScheme is not nil.
func (s *SaslSecurityScheme) SaslScramSecuritySchemeEns() *SaslScramSecurityScheme {
	if s.SaslScramSecurityScheme == nil {
		s.SaslScramSecurityScheme = new(SaslScramSecurityScheme)
	}

	return s.SaslScramSecurityScheme
}

// WithSaslGssapiSecurityScheme sets SaslGssapiSecurityScheme value.
func (s *SaslSecurityScheme) WithSaslGssapiSecurityScheme(val SaslGssapiSecurityScheme) *SaslSecurityScheme {
	s.SaslGssapiSecurityScheme = &val
	return s
}

// SaslGssapiSecuritySchemeEns ensures returned SaslGssapiSecurityScheme is not nil.
func (s *SaslSecurityScheme) SaslGssapiSecuritySchemeEns() *SaslGssapiSecurityScheme {
	if s.SaslGssapiSecurityScheme == nil {
		s.SaslGssapiSecurityScheme = new(SaslGssapiSecurityScheme)
	}

	return s.SaslGssapiSecurityScheme
}

// UnmarshalJSON decodes JSON.
func (s *SaslSecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 3)
	oneOfValid := 0

	err = json.Unmarshal(data, &s.SaslPlainSecurityScheme)
	if err != nil {
		oneOfErrors["SaslPlainSecurityScheme"] = err
		s.SaslPlainSecurityScheme = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.SaslScramSecurityScheme)
	if err != nil {
		oneOfErrors["SaslScramSecurityScheme"] = err
		s.SaslScramSecurityScheme = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.SaslGssapiSecurityScheme)
	if err != nil {
		oneOfErrors["SaslGssapiSecurityScheme"] = err
		s.SaslGssapiSecurityScheme = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for SaslSecurityScheme with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (s SaslSecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(s.SaslPlainSecurityScheme, s.SaslScramSecurityScheme, s.SaslGssapiSecurityScheme)
}

// SecurityScheme structure is generated from "#/definitions/SecurityScheme".
type SecurityScheme struct {
	UserPassword         *UserPassword         `json:"-"`
	APIKey               *APIKey               `json:"-"`
	X509                 *X509                 `json:"-"`
	SymmetricEncryption  *SymmetricEncryption  `json:"-"`
	AsymmetricEncryption *AsymmetricEncryption `json:"-"`
	HTTPSecurityScheme   *HTTPSecurityScheme   `json:"-"`
	Oauth2Flows          *Oauth2Flows          `json:"-"`
	OpenIDConnect        *OpenIDConnect        `json:"-"`
	SaslSecurityScheme   *SaslSecurityScheme   `json:"-"`
}

// WithUserPassword sets UserPassword value.
func (s *SecurityScheme) WithUserPassword(val UserPassword) *SecurityScheme {
	s.UserPassword = &val
	return s
}

// UserPasswordEns ensures returned UserPassword is not nil.
func (s *SecurityScheme) UserPasswordEns() *UserPassword {
	if s.UserPassword == nil {
		s.UserPassword = new(UserPassword)
	}

	return s.UserPassword
}

// WithAPIKey sets APIKey value.
func (s *SecurityScheme) WithAPIKey(val APIKey) *SecurityScheme {
	s.APIKey = &val
	return s
}

// APIKeyEns ensures returned APIKey is not nil.
func (s *SecurityScheme) APIKeyEns() *APIKey {
	if s.APIKey == nil {
		s.APIKey = new(APIKey)
	}

	return s.APIKey
}

// WithX509 sets X509 value.
func (s *SecurityScheme) WithX509(val X509) *SecurityScheme {
	s.X509 = &val
	return s
}

// X509Ens ensures returned X509 is not nil.
func (s *SecurityScheme) X509Ens() *X509 {
	if s.X509 == nil {
		s.X509 = new(X509)
	}

	return s.X509
}

// WithSymmetricEncryption sets SymmetricEncryption value.
func (s *SecurityScheme) WithSymmetricEncryption(val SymmetricEncryption) *SecurityScheme {
	s.SymmetricEncryption = &val
	return s
}

// SymmetricEncryptionEns ensures returned SymmetricEncryption is not nil.
func (s *SecurityScheme) SymmetricEncryptionEns() *SymmetricEncryption {
	if s.SymmetricEncryption == nil {
		s.SymmetricEncryption = new(SymmetricEncryption)
	}

	return s.SymmetricEncryption
}

// WithAsymmetricEncryption sets AsymmetricEncryption value.
func (s *SecurityScheme) WithAsymmetricEncryption(val AsymmetricEncryption) *SecurityScheme {
	s.AsymmetricEncryption = &val
	return s
}

// AsymmetricEncryptionEns ensures returned AsymmetricEncryption is not nil.
func (s *SecurityScheme) AsymmetricEncryptionEns() *AsymmetricEncryption {
	if s.AsymmetricEncryption == nil {
		s.AsymmetricEncryption = new(AsymmetricEncryption)
	}

	return s.AsymmetricEncryption
}

// WithHTTPSecurityScheme sets HTTPSecurityScheme value.
func (s *SecurityScheme) WithHTTPSecurityScheme(val HTTPSecurityScheme) *SecurityScheme {
	s.HTTPSecurityScheme = &val
	return s
}

// HTTPSecuritySchemeEns ensures returned HTTPSecurityScheme is not nil.
func (s *SecurityScheme) HTTPSecuritySchemeEns() *HTTPSecurityScheme {
	if s.HTTPSecurityScheme == nil {
		s.HTTPSecurityScheme = new(HTTPSecurityScheme)
	}

	return s.HTTPSecurityScheme
}

// WithOauth2Flows sets Oauth2Flows value.
func (s *SecurityScheme) WithOauth2Flows(val Oauth2Flows) *SecurityScheme {
	s.Oauth2Flows = &val
	return s
}

// Oauth2FlowsEns ensures returned Oauth2Flows is not nil.
func (s *SecurityScheme) Oauth2FlowsEns() *Oauth2Flows {
	if s.Oauth2Flows == nil {
		s.Oauth2Flows = new(Oauth2Flows)
	}

	return s.Oauth2Flows
}

// WithOpenIDConnect sets OpenIDConnect value.
func (s *SecurityScheme) WithOpenIDConnect(val OpenIDConnect) *SecurityScheme {
	s.OpenIDConnect = &val
	return s
}

// OpenIDConnectEns ensures returned OpenIDConnect is not nil.
func (s *SecurityScheme) OpenIDConnectEns() *OpenIDConnect {
	if s.OpenIDConnect == nil {
		s.OpenIDConnect = new(OpenIDConnect)
	}

	return s.OpenIDConnect
}

// WithSaslSecurityScheme sets SaslSecurityScheme value.
func (s *SecurityScheme) WithSaslSecurityScheme(val SaslSecurityScheme) *SecurityScheme {
	s.SaslSecurityScheme = &val
	return s
}

// SaslSecuritySchemeEns ensures returned SaslSecurityScheme is not nil.
func (s *SecurityScheme) SaslSecuritySchemeEns() *SaslSecurityScheme {
	if s.SaslSecurityScheme == nil {
		s.SaslSecurityScheme = new(SaslSecurityScheme)
	}

	return s.SaslSecurityScheme
}

// UnmarshalJSON decodes JSON.
func (s *SecurityScheme) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 9)
	oneOfValid := 0

	err = json.Unmarshal(data, &s.UserPassword)
	if err != nil {
		oneOfErrors["UserPassword"] = err
		s.UserPassword = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.APIKey)
	if err != nil {
		oneOfErrors["APIKey"] = err
		s.APIKey = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.X509)
	if err != nil {
		oneOfErrors["X509"] = err
		s.X509 = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.SymmetricEncryption)
	if err != nil {
		oneOfErrors["SymmetricEncryption"] = err
		s.SymmetricEncryption = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.AsymmetricEncryption)
	if err != nil {
		oneOfErrors["AsymmetricEncryption"] = err
		s.AsymmetricEncryption = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.HTTPSecurityScheme)
	if err != nil {
		oneOfErrors["HTTPSecurityScheme"] = err
		s.HTTPSecurityScheme = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.Oauth2Flows)
	if err != nil {
		oneOfErrors["Oauth2Flows"] = err
		s.Oauth2Flows = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.OpenIDConnect)
	if err != nil {
		oneOfErrors["OpenIDConnect"] = err
		s.OpenIDConnect = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &s.SaslSecurityScheme)
	if err != nil {
		oneOfErrors["SaslSecurityScheme"] = err
		s.SaslSecurityScheme = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for SecurityScheme with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (s SecurityScheme) MarshalJSON() ([]byte, error) {
	return marshalUnion(s.UserPassword, s.APIKey, s.X509, s.SymmetricEncryption, s.AsymmetricEncryption, s.HTTPSecurityScheme, s.Oauth2Flows, s.OpenIDConnect, s.SaslSecurityScheme)
}

// ComponentsSecuritySchemesWD structure is generated from "#/definitions/components->securitySchemes->^[\w\d\.\-_]+$".
type ComponentsSecuritySchemesWD struct {
	Reference      *Reference      `json:"-"`
	SecurityScheme *SecurityScheme `json:"-"`
}

// WithReference sets Reference value.
func (c *ComponentsSecuritySchemesWD) WithReference(val Reference) *ComponentsSecuritySchemesWD {
	c.Reference = &val
	return c
}

// ReferenceEns ensures returned Reference is not nil.
func (c *ComponentsSecuritySchemesWD) ReferenceEns() *Reference {
	if c.Reference == nil {
		c.Reference = new(Reference)
	}

	return c.Reference
}

// WithSecurityScheme sets SecurityScheme value.
func (c *ComponentsSecuritySchemesWD) WithSecurityScheme(val SecurityScheme) *ComponentsSecuritySchemesWD {
	c.SecurityScheme = &val
	return c
}

// SecuritySchemeEns ensures returned SecurityScheme is not nil.
func (c *ComponentsSecuritySchemesWD) SecuritySchemeEns() *SecurityScheme {
	if c.SecurityScheme == nil {
		c.SecurityScheme = new(SecurityScheme)
	}

	return c.SecurityScheme
}

// UnmarshalJSON decodes JSON.
func (c *ComponentsSecuritySchemesWD) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 2)
	oneOfValid := 0

	err = json.Unmarshal(data, &c.Reference)
	if err != nil {
		oneOfErrors["Reference"] = err
		c.Reference = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &c.SecurityScheme)
	if err != nil {
		oneOfErrors["SecurityScheme"] = err
		c.SecurityScheme = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for ComponentsSecuritySchemesWD with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (c ComponentsSecuritySchemesWD) MarshalJSON() ([]byte, error) {
	return marshalUnion(c.Reference, c.SecurityScheme)
}

// ComponentsSecuritySchemes structure is generated from "#/definitions/components->securitySchemes".
type ComponentsSecuritySchemes struct {
	MapOfComponentsSecuritySchemesWDValues map[string]ComponentsSecuritySchemesWD `json:"-"` // Key must match pattern: `^[\w\d\.\-_]+$`.
}

// WithMapOfComponentsSecuritySchemesWDValues sets MapOfComponentsSecuritySchemesWDValues value.
func (c *ComponentsSecuritySchemes) WithMapOfComponentsSecuritySchemesWDValues(val map[string]ComponentsSecuritySchemesWD) *ComponentsSecuritySchemes {
	c.MapOfComponentsSecuritySchemesWDValues = val
	return c
}

// WithMapOfComponentsSecuritySchemesWDValuesItem sets MapOfComponentsSecuritySchemesWDValues item value.
func (c *ComponentsSecuritySchemes) WithMapOfComponentsSecuritySchemesWDValuesItem(key string, val ComponentsSecuritySchemesWD) *ComponentsSecuritySchemes {
	if c.MapOfComponentsSecuritySchemesWDValues == nil {
		c.MapOfComponentsSecuritySchemesWDValues = make(map[string]ComponentsSecuritySchemesWD, 1)
	}

	c.MapOfComponentsSecuritySchemesWDValues[key] = val

	return c
}

// UnmarshalJSON decodes JSON.
func (c *ComponentsSecuritySchemes) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexWD.MatchString(key) {
			matched = true

			if c.MapOfComponentsSecuritySchemesWDValues == nil {
				c.MapOfComponentsSecuritySchemesWDValues = make(map[string]ComponentsSecuritySchemesWD, 1)
			}

			var val ComponentsSecuritySchemesWD

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			c.MapOfComponentsSecuritySchemesWDValues[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	return nil
}

// MarshalJSON encodes JSON.
func (c ComponentsSecuritySchemes) MarshalJSON() ([]byte, error) {
	return marshalUnion(c.MapOfComponentsSecuritySchemesWDValues)
}

// ComponentsCorrelationIdsWD structure is generated from "#/definitions/components->correlationIds->^[\w\d\.\-_]+$".
type ComponentsCorrelationIdsWD struct {
	Reference     *Reference     `json:"-"`
	CorrelationID *CorrelationID `json:"-"`
}

// WithReference sets Reference value.
func (c *ComponentsCorrelationIdsWD) WithReference(val Reference) *ComponentsCorrelationIdsWD {
	c.Reference = &val
	return c
}

// ReferenceEns ensures returned Reference is not nil.
func (c *ComponentsCorrelationIdsWD) ReferenceEns() *Reference {
	if c.Reference == nil {
		c.Reference = new(Reference)
	}

	return c.Reference
}

// WithCorrelationID sets CorrelationID value.
func (c *ComponentsCorrelationIdsWD) WithCorrelationID(val CorrelationID) *ComponentsCorrelationIdsWD {
	c.CorrelationID = &val
	return c
}

// CorrelationIDEns ensures returned CorrelationID is not nil.
func (c *ComponentsCorrelationIdsWD) CorrelationIDEns() *CorrelationID {
	if c.CorrelationID == nil {
		c.CorrelationID = new(CorrelationID)
	}

	return c.CorrelationID
}

// UnmarshalJSON decodes JSON.
func (c *ComponentsCorrelationIdsWD) UnmarshalJSON(data []byte) error {
	var err error

	oneOfErrors := make(map[string]error, 2)
	oneOfValid := 0

	err = json.Unmarshal(data, &c.Reference)
	if err != nil {
		oneOfErrors["Reference"] = err
		c.Reference = nil
	} else {
		oneOfValid++
	}

	err = json.Unmarshal(data, &c.CorrelationID)
	if err != nil {
		oneOfErrors["CorrelationID"] = err
		c.CorrelationID = nil
	} else {
		oneOfValid++
	}

	if oneOfValid != 1 {
		return fmt.Errorf("oneOf constraint failed for ComponentsCorrelationIdsWD with %d valid results: %v", oneOfValid, oneOfErrors)
	}

	return nil
}

// MarshalJSON encodes JSON.
func (c ComponentsCorrelationIdsWD) MarshalJSON() ([]byte, error) {
	return marshalUnion(c.Reference, c.CorrelationID)
}

// ComponentsCorrelationIds structure is generated from "#/definitions/components->correlationIds".
type ComponentsCorrelationIds struct {
	MapOfComponentsCorrelationIdsWDValues map[string]ComponentsCorrelationIdsWD `json:"-"` // Key must match pattern: `^[\w\d\.\-_]+$`.
}

// WithMapOfComponentsCorrelationIdsWDValues sets MapOfComponentsCorrelationIdsWDValues value.
func (c *ComponentsCorrelationIds) WithMapOfComponentsCorrelationIdsWDValues(val map[string]ComponentsCorrelationIdsWD) *ComponentsCorrelationIds {
	c.MapOfComponentsCorrelationIdsWDValues = val
	return c
}

// WithMapOfComponentsCorrelationIdsWDValuesItem sets MapOfComponentsCorrelationIdsWDValues item value.
func (c *ComponentsCorrelationIds) WithMapOfComponentsCorrelationIdsWDValuesItem(key string, val ComponentsCorrelationIdsWD) *ComponentsCorrelationIds {
	if c.MapOfComponentsCorrelationIdsWDValues == nil {
		c.MapOfComponentsCorrelationIdsWDValues = make(map[string]ComponentsCorrelationIdsWD, 1)
	}

	c.MapOfComponentsCorrelationIdsWDValues[key] = val

	return c
}

// UnmarshalJSON decodes JSON.
func (c *ComponentsCorrelationIds) UnmarshalJSON(data []byte) error {
	var err error

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for key, rawValue := range rawMap {
		matched := false

		if regexWD.MatchString(key) {
			matched = true

			if c.MapOfComponentsCorrelationIdsWDValues == nil {
				c.MapOfComponentsCorrelationIdsWDValues = make(map[string]ComponentsCorrelationIdsWD, 1)
			}

			var val ComponentsCorrelationIdsWD

			err = json.Unmarshal(rawValue, &val)
			if err != nil {
				return err
			}

			c.MapOfComponentsCorrelationIdsWDValues[key] = val
		}

		if matched {
			delete(rawMap, key)
		}
	}

	return nil
}

// MarshalJSON encodes JSON.
func (c ComponentsCorrelationIds) MarshalJSON() ([]byte, error) {
	return marshalUnion(c.MapOfComponentsCorrelationIdsWDValues)
}

// APIKeyIn is an enum type.
type APIKeyIn string

// APIKeyIn values enumeration.
const (
	APIKeyInUser = APIKeyIn("user")
	APIKeyInPassword = APIKeyIn("password")
)

// MarshalJSON encodes JSON.
func (i APIKeyIn) MarshalJSON() ([]byte, error) {
	switch i {
	case APIKeyInUser:
	case APIKeyInPassword:

	default:
		return nil, fmt.Errorf("unexpected APIKeyIn value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *APIKeyIn) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := APIKeyIn(ii)

	switch v {
	case APIKeyInUser:
	case APIKeyInPassword:

	default:
		return fmt.Errorf("unexpected APIKeyIn value: %v", v)
	}

	*i = v

	return nil
}

// APIKeyHTTPSecuritySchemeIn is an enum type.
type APIKeyHTTPSecuritySchemeIn string

// APIKeyHTTPSecuritySchemeIn values enumeration.
const (
	APIKeyHTTPSecuritySchemeInHeader = APIKeyHTTPSecuritySchemeIn("header")
	APIKeyHTTPSecuritySchemeInQuery = APIKeyHTTPSecuritySchemeIn("query")
	APIKeyHTTPSecuritySchemeInCookie = APIKeyHTTPSecuritySchemeIn("cookie")
)

// MarshalJSON encodes JSON.
func (i APIKeyHTTPSecuritySchemeIn) MarshalJSON() ([]byte, error) {
	switch i {
	case APIKeyHTTPSecuritySchemeInHeader:
	case APIKeyHTTPSecuritySchemeInQuery:
	case APIKeyHTTPSecuritySchemeInCookie:

	default:
		return nil, fmt.Errorf("unexpected APIKeyHTTPSecuritySchemeIn value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *APIKeyHTTPSecuritySchemeIn) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := APIKeyHTTPSecuritySchemeIn(ii)

	switch v {
	case APIKeyHTTPSecuritySchemeInHeader:
	case APIKeyHTTPSecuritySchemeInQuery:
	case APIKeyHTTPSecuritySchemeInCookie:

	default:
		return fmt.Errorf("unexpected APIKeyHTTPSecuritySchemeIn value: %v", v)
	}

	*i = v

	return nil
}

// SaslScramSecuritySchemeType is an enum type.
type SaslScramSecuritySchemeType string

// SaslScramSecuritySchemeType values enumeration.
const (
	SaslScramSecuritySchemeTypeScramSha256 = SaslScramSecuritySchemeType("scramSha256")
	SaslScramSecuritySchemeTypeScramSha512 = SaslScramSecuritySchemeType("scramSha512")
)

// MarshalJSON encodes JSON.
func (i SaslScramSecuritySchemeType) MarshalJSON() ([]byte, error) {
	switch i {
	case SaslScramSecuritySchemeTypeScramSha256:
	case SaslScramSecuritySchemeTypeScramSha512:

	default:
		return nil, fmt.Errorf("unexpected SaslScramSecuritySchemeType value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *SaslScramSecuritySchemeType) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := SaslScramSecuritySchemeType(ii)

	switch v {
	case SaslScramSecuritySchemeTypeScramSha256:
	case SaslScramSecuritySchemeTypeScramSha512:

	default:
		return fmt.Errorf("unexpected SaslScramSecuritySchemeType value: %v", v)
	}

	*i = v

	return nil
}

func marshalUnion(maps ...interface{}) ([]byte, error) {
	result := []byte("{")
	isObject := true

	for _, m := range maps {
		j, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}

		if string(j) == "{}" {
			continue
		}

		if string(j) == "null" {
			continue
		}

		if j[0] != '{' {
			if len(result) == 1 && (isObject || bytes.Equal(result, j)) {
				result = j
				isObject = false

				continue
			}

			return nil, errors.New("failed to union map: object expected, " + string(j) + " received")
		}

		if !isObject {
			return nil, errors.New("failed to union " + string(result) + " and " + string(j))
		}

		if len(result) > 1 {
			result[len(result)-1] = ','
		}

		result = append(result, j[1:]...)
	}

	// Close empty result.
	if isObject && len(result) == 1 {
		result = append(result, '}')
	}

	return result, nil
}
// Regular expressions for pattern properties.
var (
	regexXWDX2D = regexp.MustCompile(`^x-[\w\d\.\x2d_]+$`)
	regexWD = regexp.MustCompile(`^[\w\d\.\-_]+$`)
)
