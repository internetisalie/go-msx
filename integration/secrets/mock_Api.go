// Code generated by mockery v2.14.0. DO NOT EDIT.

package secrets

import (
	integration "cto-github.cisco.com/NFV-BU/go-msx/integration"
	mock "github.com/stretchr/testify/mock"
)

// MockSecrets is an autogenerated mock type for the Api type
type MockSecrets struct {
	mock.Mock
}

// AddSystemSecrets provides a mock function with given fields: scope, secrets
func (_m *MockSecrets) AddSystemSecrets(scope string, secrets map[string]string) (*integration.MsxResponse, error) {
	ret := _m.Called(scope, secrets)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, map[string]string) *integration.MsxResponse); ok {
		r0 = rf(scope, secrets)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]string) error); ok {
		r1 = rf(scope, secrets)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTenantSecrets provides a mock function with given fields: tenantId, scope, secrets
func (_m *MockSecrets) AddTenantSecrets(tenantId string, scope string, secrets map[string]string) (*integration.MsxResponse, error) {
	ret := _m.Called(tenantId, scope, secrets)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, string, map[string]string) *integration.MsxResponse); ok {
		r0 = rf(tenantId, scope, secrets)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, map[string]string) error); ok {
		r1 = rf(tenantId, scope, secrets)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSecretPolicy provides a mock function with given fields: name
func (_m *MockSecrets) DeleteSecretPolicy(name string) (*integration.MsxResponse, error) {
	ret := _m.Called(name)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string) *integration.MsxResponse); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EncryptSystemSecrets provides a mock function with given fields: scope, names, encrypt
func (_m *MockSecrets) EncryptSystemSecrets(scope string, names []string, encrypt EncryptSecretsDTO) (*integration.MsxResponse, error) {
	ret := _m.Called(scope, names, encrypt)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, []string, EncryptSecretsDTO) *integration.MsxResponse); ok {
		r0 = rf(scope, names, encrypt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []string, EncryptSecretsDTO) error); ok {
		r1 = rf(scope, names, encrypt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EncryptTenantSecrets provides a mock function with given fields: tenantId, scope, names, encrypt
func (_m *MockSecrets) EncryptTenantSecrets(tenantId string, scope string, names []string, encrypt EncryptSecretsDTO) (*integration.MsxResponse, error) {
	ret := _m.Called(tenantId, scope, names, encrypt)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, string, []string, EncryptSecretsDTO) *integration.MsxResponse); ok {
		r0 = rf(tenantId, scope, names, encrypt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, []string, EncryptSecretsDTO) error); ok {
		r1 = rf(tenantId, scope, names, encrypt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateSystemSecrets provides a mock function with given fields: scope, names, save
func (_m *MockSecrets) GenerateSystemSecrets(scope string, names []string, save bool) (*integration.MsxResponse, error) {
	ret := _m.Called(scope, names, save)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, []string, bool) *integration.MsxResponse); ok {
		r0 = rf(scope, names, save)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []string, bool) error); ok {
		r1 = rf(scope, names, save)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateTenantSecrets provides a mock function with given fields: tenantId, scope, names, save
func (_m *MockSecrets) GenerateTenantSecrets(tenantId string, scope string, names []string, save bool) (*integration.MsxResponse, error) {
	ret := _m.Called(tenantId, scope, names, save)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, string, []string, bool) *integration.MsxResponse); ok {
		r0 = rf(tenantId, scope, names, save)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, []string, bool) error); ok {
		r1 = rf(tenantId, scope, names, save)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAdminHealth provides a mock function with given fields:
func (_m *MockSecrets) GetAdminHealth() (*integration.MsxResponse, error) {
	ret := _m.Called()

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func() *integration.MsxResponse); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSecretPolicy provides a mock function with given fields: name
func (_m *MockSecrets) GetSecretPolicy(name string) (*integration.MsxResponse, error) {
	ret := _m.Called(name)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string) *integration.MsxResponse); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSystemSecrets provides a mock function with given fields: scope
func (_m *MockSecrets) GetSystemSecrets(scope string) (*integration.MsxResponse, error) {
	ret := _m.Called(scope)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string) *integration.MsxResponse); ok {
		r0 = rf(scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTenantSecrets provides a mock function with given fields: tenantId, scope
func (_m *MockSecrets) GetTenantSecrets(tenantId string, scope string) (*integration.MsxResponse, error) {
	ret := _m.Called(tenantId, scope)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, string) *integration.MsxResponse); ok {
		r0 = rf(tenantId, scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(tenantId, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveSystemSecrets provides a mock function with given fields: scope
func (_m *MockSecrets) RemoveSystemSecrets(scope string) (*integration.MsxResponse, error) {
	ret := _m.Called(scope)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string) *integration.MsxResponse); ok {
		r0 = rf(scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveSystemSecretsPermanent provides a mock function with given fields: scope, permanent
func (_m *MockSecrets) RemoveSystemSecretsPermanent(scope string, permanent *bool) (*integration.MsxResponse, error) {
	ret := _m.Called(scope, permanent)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, *bool) *integration.MsxResponse); ok {
		r0 = rf(scope, permanent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *bool) error); ok {
		r1 = rf(scope, permanent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveTenantSecrets provides a mock function with given fields: tenantId, scope
func (_m *MockSecrets) RemoveTenantSecrets(tenantId string, scope string) (*integration.MsxResponse, error) {
	ret := _m.Called(tenantId, scope)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, string) *integration.MsxResponse); ok {
		r0 = rf(tenantId, scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(tenantId, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceSystemSecrets provides a mock function with given fields: scope, secrets
func (_m *MockSecrets) ReplaceSystemSecrets(scope string, secrets map[string]string) (*integration.MsxResponse, error) {
	ret := _m.Called(scope, secrets)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, map[string]string) *integration.MsxResponse); ok {
		r0 = rf(scope, secrets)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]string) error); ok {
		r1 = rf(scope, secrets)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReplaceTenantSecrets provides a mock function with given fields: tenantId, scope, secrets
func (_m *MockSecrets) ReplaceTenantSecrets(tenantId string, scope string, secrets map[string]string) (*integration.MsxResponse, error) {
	ret := _m.Called(tenantId, scope, secrets)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, string, map[string]string) *integration.MsxResponse); ok {
		r0 = rf(tenantId, scope, secrets)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, map[string]string) error); ok {
		r1 = rf(tenantId, scope, secrets)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StoreSecretPolicy provides a mock function with given fields: name, policy
func (_m *MockSecrets) StoreSecretPolicy(name string, policy SecretPolicySetRequest) (*integration.MsxResponse, error) {
	ret := _m.Called(name, policy)

	var r0 *integration.MsxResponse
	if rf, ok := ret.Get(0).(func(string, SecretPolicySetRequest) *integration.MsxResponse); ok {
		r0 = rf(name, policy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*integration.MsxResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, SecretPolicySetRequest) error); ok {
		r1 = rf(name, policy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewMockSecrets interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockSecrets creates a new instance of MockSecrets. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockSecrets(t mockConstructorTestingTNewMockSecrets) *MockSecrets {
	mock := &MockSecrets{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
